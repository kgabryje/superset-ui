(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{2486:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ TableChart; });\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(2);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/node_modules/d3-array/src/max.js\nvar max = __webpack_require__(2476);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/node_modules/d3-array/src/extent.js\nvar extent = __webpack_require__(2477);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/react-icons/fa/index.esm.js + 4 modules\nvar index_esm = __webpack_require__(2432);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/translation/TranslatorSingleton.ts + 1 modules\nvar TranslatorSingleton = __webpack_require__(15);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/types.ts\nvar types = __webpack_require__(202);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/react-table/index.js\nvar react_table = __webpack_require__(2213);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/match-sorter/dist/match-sorter.esm.js + 1 modules\nvar match_sorter_esm = __webpack_require__(2435);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/regenerator-runtime/runtime.js\nvar runtime = __webpack_require__(429);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/useAsyncState.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n// useAsyncDebounce in dist build of `react-table` requires regeneratorRuntime\n\n/**\n * Hook useState to allow always return latest initialValue\n */\nfunction useAsyncState(initialValue, callback, wait = 200) {\n    const [value, setValue] = Object(react["useState"])(initialValue);\n    const valueRef = Object(react["useRef"])(initialValue);\n    const onChange = Object(react_table["useAsyncDebounce"])(callback, wait);\n    // sync updated initialValue\n    if (valueRef.current !== initialValue) {\n        valueRef.current = initialValue;\n        if (value !== initialValue) {\n            setValue(initialValue);\n        }\n    }\n    const setBoth = (newValue) => {\n        setValue(newValue);\n        onChange(newValue);\n    };\n    return [value, setBoth];\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/DataTable/components/GlobalFilter.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nfunction DefaultSearchInput({ count, value, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-global-filter" },\n        "Search",\n        \' \',\n        react_default.a.createElement("input", { className: "form-control input-sm", placeholder: `${count} records...`, value: value, onChange: onChange })));\n}\n/* harmony default export */ var components_GlobalFilter = (react_default.a.memo(function GlobalFilter({ preGlobalFilteredRows, filterValue = \'\', searchInput, setGlobalFilter, }) {\n    const count = preGlobalFilteredRows.length;\n    const [value, setValue] = useAsyncState(filterValue, (newValue) => {\n        setGlobalFilter(newValue || undefined);\n    }, 200);\n    const SearchInput = searchInput || DefaultSearchInput;\n    return (react_default.a.createElement(SearchInput, { count: count, value: value, onChange: e => {\n            const target = e.target;\n            e.preventDefault();\n            setValue(target.value);\n        } }));\n}));\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/DataTable/components/SelectPageSize.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nfunction DefaultSelectRenderer({ current, options, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-select-page-size form-inline" },\n        "Show",\n        \' \',\n        react_default.a.createElement("select", { className: "form-control input-sm", value: current, onBlur: () => { }, onChange: e => {\n                onChange(Number(e.target.value));\n            } }, options.map(option => {\n            const [size, text] = Array.isArray(option) ? option : [option, option];\n            return (react_default.a.createElement("option", { key: size, value: size }, text));\n        })),\n        \' \',\n        "entries"));\n}\nfunction getOptionValue(x) {\n    return Array.isArray(x) ? x[0] : x;\n}\n/* harmony default export */ var components_SelectPageSize = (react_default.a.memo(function SelectPageSize({ total, options: sizeOptions, current: currentSize, selectRenderer, onChange, }) {\n    const sizeOptionValues = sizeOptions.map(getOptionValue);\n    let options = [...sizeOptions];\n    // insert current size to list\n    if (currentSize !== undefined &&\n        (currentSize !== total || !sizeOptionValues.includes(0)) &&\n        !sizeOptionValues.includes(currentSize)) {\n        options = [...sizeOptions];\n        options.splice(sizeOptionValues.findIndex(x => x > currentSize), 0, currentSize);\n    }\n    const current = currentSize === undefined ? sizeOptionValues[0] : currentSize;\n    const SelectRenderer = selectRenderer || DefaultSelectRenderer;\n    return react_default.a.createElement(SelectRenderer, { current: current, options: options, onChange: onChange });\n}));\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/DataTable/components/Pagination.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n// first, ..., prev, current, next, ..., last\nconst MINIMAL_PAGE_ITEM_COUNT = 7;\n/**\n * Generate numeric page items around current page.\n *   - Always include first and last page\n *   - Add ellipsis if needed\n */\nfunction generatePageItems(total, current, width) {\n    if (width < MINIMAL_PAGE_ITEM_COUNT) {\n        throw new Error(`Must allow at least ${MINIMAL_PAGE_ITEM_COUNT} page items`);\n    }\n    if (width % 2 === 0) {\n        throw new Error(`Must allow odd number of page items`);\n    }\n    if (total < width) {\n        return [...new Array(total).keys()];\n    }\n    const left = Math.max(0, Math.min(total - width, current - Math.floor(width / 2)));\n    const items = new Array(width);\n    for (let i = 0; i < width; i += 1) {\n        items[i] = i + left;\n    }\n    // replace non-ending items with placeholders\n    if (items[0] > 0) {\n        items[0] = 0;\n        items[1] = \'prev-more\';\n    }\n    if (items[items.length - 1] < total - 1) {\n        items[items.length - 1] = total - 1;\n        items[items.length - 2] = \'next-more\';\n    }\n    return items;\n}\n/* harmony default export */ var components_Pagination = (react_default.a.memo(react_default.a.forwardRef(function Pagination({ style, pageCount, currentPage = 0, maxPageItemCount = 9, onPageChange }, ref) {\n    const pageItems = generatePageItems(pageCount, currentPage, maxPageItemCount);\n    return (react_default.a.createElement("div", { ref: ref, className: "dt-pagination", style: style },\n        react_default.a.createElement("ul", { className: "pagination pagination-sm" }, pageItems.map((item, i) => typeof item === \'number\' ? (\n        // actual page number\n        react_default.a.createElement("li", { key: item, className: currentPage === item ? \'active\' : undefined },\n            react_default.a.createElement("a", { href: `#page-${item}`, role: "button", onClick: e => {\n                    e.preventDefault();\n                    onPageChange(item);\n                } }, item + 1))) : (react_default.a.createElement("li", { key: item, className: "dt-pagination-ellipsis" },\n            react_default.a.createElement("span", null, "\\u2026")))))));\n})));\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/getScrollBarSize.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nlet cached;\nconst css = (x) => x.join(\'\\n\');\nfunction getScrollBarSize(forceRefresh = false) {\n    if (typeof document === \'undefined\') {\n        return 0;\n    }\n    if (cached === undefined || forceRefresh) {\n        const inner = document.createElement(\'div\');\n        const outer = document.createElement(\'div\');\n        inner.style.cssText = css `\n      width: auto;\n      height: 100%;\n      overflow: scroll;\n    `;\n        outer.style.cssText = css `\n      position: absolute;\n      visibility: hidden;\n      overflow: hidden;\n      width: 100px;\n      height: 50px;\n    `;\n        outer.append(inner);\n        document.body.append(outer);\n        cached = outer.clientWidth - inner.clientWidth;\n        outer.remove();\n    }\n    return cached;\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/needScrollBar.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/**\n * Whether a container need scroll bars when in another container.\n */\nfunction needScrollBar({ width, height, innerHeight, innerWidth, scrollBarSize, }) {\n    const hasVerticalScroll = innerHeight > height;\n    const hasHorizontalScroll = innerWidth > width - (hasVerticalScroll ? scrollBarSize : 0);\n    return [hasVerticalScroll, hasHorizontalScroll];\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/useMountedMemo.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * Execute a memoized callback only when mounted. Execute again when factory updated.\n * Returns undefined if not mounted yet.\n */\nfunction useMountedMemo(factory, deps) {\n    const mounted = Object(react["useRef"])();\n    Object(react["useLayoutEffect"])(() => {\n        mounted.current = factory;\n    });\n    return Object(react["useMemo"])(() => {\n        if (mounted.current) {\n            return factory();\n        }\n        return undefined;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [mounted.current, mounted.current === factory, ...(deps || [])]);\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/DataTable/hooks/useSticky.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\nvar ReducerActions;\n(function (ReducerActions) {\n    ReducerActions["init"] = "init";\n    ReducerActions["setStickyState"] = "setStickyState";\n})(ReducerActions || (ReducerActions = {}));\nconst sum = (a, b) => a + b;\nconst mergeStyleProp = (node, style) => ({\n    style: Object.assign(Object.assign({}, node.props.style), style),\n});\n/**\n * An HOC for generating sticky header and fixed-height scrollable area\n */\nfunction StickyWrap({ sticky = {}, width: maxWidth, height: maxHeight, children: table, setStickyState, }) {\n    if (!table || table.type !== \'table\') {\n        throw new Error(\'<StickyWrap> must have only one <table> element as child\');\n    }\n    let thead;\n    let tbody;\n    let colgroup;\n    react_default.a.Children.forEach(table.props.children, node => {\n        if (node.type === \'thead\') {\n            thead = node;\n        }\n        else if (node.type === \'tbody\') {\n            tbody = node;\n        }\n        else if (node.type === \'colgroup\') {\n            colgroup = node;\n        }\n    });\n    if (!thead || !tbody) {\n        throw new Error(\'<table> in <StickyWrap> must contain both thead and tbody.\');\n    }\n    const columnCount = Object(react["useMemo"])(() => {\n        const headerRows = react_default.a.Children.toArray(thead === null || thead === void 0 ? void 0 : thead.props.children).pop();\n        return headerRows.props.children.length;\n    }, [thead]);\n    const theadRef = Object(react["useRef"])(null); // original thead for layout computation\n    const scrollHeaderRef = Object(react["useRef"])(null); // fixed header\n    const scrollBodyRef = Object(react["useRef"])(null); // main body\n    const { bodyHeight, columnWidths } = sticky;\n    const needSizer = !columnWidths ||\n        sticky.width !== maxWidth ||\n        sticky.height !== maxHeight ||\n        sticky.setStickyState !== setStickyState;\n    const scrollBarSize = getScrollBarSize();\n    // update scrollable area and header column sizes when mounted\n    Object(react["useLayoutEffect"])(() => {\n        if (theadRef.current) {\n            const bodyThead = theadRef.current;\n            const theadHeight = bodyThead.clientHeight;\n            if (!theadHeight) {\n                return;\n            }\n            const fullTableHeight = bodyThead.parentNode.clientHeight;\n            const ths = bodyThead.childNodes[0].childNodes;\n            const widths = Array.from(ths).map(th => th.clientWidth);\n            const [hasVerticalScroll, hasHorizontalScroll] = needScrollBar({\n                width: maxWidth,\n                height: maxHeight - theadHeight,\n                innerHeight: fullTableHeight,\n                innerWidth: widths.reduce(sum),\n                scrollBarSize,\n            });\n            // real container height, include table header and space for\n            // horizontal scroll bar\n            const realHeight = Math.min(maxHeight, hasHorizontalScroll ? fullTableHeight + scrollBarSize : fullTableHeight);\n            setStickyState({\n                hasVerticalScroll,\n                hasHorizontalScroll,\n                setStickyState,\n                width: maxWidth,\n                height: maxHeight,\n                realHeight,\n                tableHeight: fullTableHeight,\n                bodyHeight: realHeight - theadHeight,\n                columnWidths: widths,\n            });\n        }\n    }, [maxWidth, maxHeight, setStickyState, scrollBarSize]);\n    let sizerTable;\n    let headerTable;\n    let bodyTable;\n    if (needSizer) {\n        const theadWithRef = react_default.a.cloneElement(thead, { ref: theadRef });\n        sizerTable = (react_default.a.createElement("div", { key: "sizer", style: {\n                height: maxHeight,\n                overflow: \'auto\',\n                visibility: \'hidden\',\n            } }, react_default.a.cloneElement(table, {}, colgroup, theadWithRef, tbody)));\n    }\n    // reuse previously column widths, will be updated by `useLayoutEffect` above\n    const colWidths = columnWidths === null || columnWidths === void 0 ? void 0 : columnWidths.slice(0, columnCount);\n    if (colWidths && bodyHeight) {\n        const tableStyle = { tableLayout: \'fixed\' };\n        const bodyCols = colWidths.map((w, i) => (\n        // eslint-disable-next-line react/no-array-index-key\n        react_default.a.createElement("col", { key: i, width: w })));\n        const bodyColgroup = react_default.a.createElement("colgroup", null, bodyCols);\n        // header columns do not have vertical scroll bars,\n        // so we add scroll bar size to the last column\n        const headerColgroup = sticky.hasVerticalScroll && scrollBarSize ? (react_default.a.createElement("colgroup", null, colWidths.map((x, i) => (\n        // eslint-disable-next-line react/no-array-index-key\n        react_default.a.createElement("col", { key: i, width: x + (i === colWidths.length - 1 ? scrollBarSize : 0) }))))) : (bodyColgroup);\n        headerTable = (react_default.a.createElement("div", { key: "header", ref: scrollHeaderRef, style: {\n                overflow: \'hidden\',\n            } },\n            react_default.a.cloneElement(table, mergeStyleProp(table, tableStyle), headerColgroup, thead),\n            headerTable));\n        const onScroll = e => {\n            if (scrollHeaderRef.current) {\n                scrollHeaderRef.current.scrollLeft = e.currentTarget.scrollLeft;\n            }\n        };\n        bodyTable = (react_default.a.createElement("div", { key: "body", ref: scrollBodyRef, style: {\n                height: bodyHeight,\n                overflow: \'auto\',\n            }, onScroll: sticky.hasHorizontalScroll ? onScroll : undefined }, react_default.a.cloneElement(table, mergeStyleProp(table, tableStyle), bodyColgroup, tbody)));\n    }\n    return (react_default.a.createElement("div", { style: {\n            width: maxWidth,\n            height: sticky.realHeight || maxHeight,\n            overflow: \'hidden\',\n        } },\n        headerTable,\n        bodyTable,\n        sizerTable));\n}\nfunction useInstance(instance) {\n    const { dispatch, state: { sticky }, data, page, rows, getTableSize = () => undefined, } = instance;\n    const setStickyState = Object(react["useCallback"])((size) => {\n        dispatch({\n            type: ReducerActions.setStickyState,\n            size,\n        });\n    }, \n    // turning pages would also trigger a resize\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [dispatch, getTableSize, page, rows]);\n    const useStickyWrap = (renderer) => {\n        const { width, height } = useMountedMemo(getTableSize, [getTableSize]) || sticky;\n        // only change of data should trigger re-render\n        const table = Object(react["useMemo"])(renderer, [page, rows]);\n        Object(react["useLayoutEffect"])(() => {\n            if (!width || !height) {\n                setStickyState();\n            }\n        }, [width, height]);\n        if (!width || !height) {\n            return null;\n        }\n        if (data.length === 0) {\n            return table;\n        }\n        return (react_default.a.createElement(StickyWrap, { width: width, height: height, sticky: sticky, setStickyState: setStickyState }, table));\n    };\n    Object.assign(instance, {\n        setStickyState,\n        wrapStickyTable: useStickyWrap,\n    });\n}\nfunction useSticky(hooks) {\n    hooks.useInstance.push(useInstance);\n    hooks.stateReducers.push((newState, action_, previousState, instance) => {\n        const action = action_;\n        if (action.type === ReducerActions.init) {\n            return Object.assign(Object.assign({}, newState), { sticky: newState.sticky || {} });\n        }\n        if (action.type === ReducerActions.setStickyState) {\n            const { size } = action;\n            if (!size) {\n                return Object.assign({}, newState);\n            }\n            return Object.assign(Object.assign({}, newState), { sticky: Object.assign(Object.assign({}, newState.sticky), action.size) });\n        }\n        return newState;\n    });\n}\nuseSticky.pluginName = \'useSticky\';\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/DataTable/DataTable.tsx\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n// Be sure to pass our updateMyData and the skipReset option\nfunction DataTable(_a) {\n    var { tableClassName, columns, data, width: initialWidth = \'100%\', height: initialHeight = 300, pageSize: initialPageSize = 0, initialState: initialState_ = {}, pageSizeOptions = [10, 25, 50, 100, 200], maxPageItemCount = 9, sticky: doSticky, searchInput = true, selectPageSize, noResults = \'No data found\', hooks, wrapperRef: userWrapperRef } = _a, moreUseTableOptions = __rest(_a, ["tableClassName", "columns", "data", "width", "height", "pageSize", "initialState", "pageSizeOptions", "maxPageItemCount", "sticky", "searchInput", "selectPageSize", "noResults", "hooks", "wrapperRef"]);\n    const tableHooks = [\n        react_table["useGlobalFilter"],\n        react_table["useSortBy"],\n        react_table["usePagination"],\n        doSticky ? useSticky : [],\n        hooks || [],\n    ].flat();\n    const sortByRef = Object(react["useRef"])([]); // cache initial `sortby` so sorting doesn\'t trigger page reset\n    const pageSizeRef = Object(react["useRef"])([initialPageSize, data.length]);\n    const hasPagination = initialPageSize > 0 && data.length > 0; // pageSize == 0 means no pagination\n    const hasGlobalControl = hasPagination || !!searchInput;\n    const initialState = Object.assign(Object.assign({}, initialState_), { \n        // zero length means all pages, the `usePagination` plugin does not\n        // understand pageSize = 0\n        sortBy: sortByRef.current, pageSize: initialPageSize > 0 ? initialPageSize : data.length || 10 });\n    const defaultWrapperRef = Object(react["useRef"])(null);\n    const globalControlRef = Object(react["useRef"])(null);\n    const paginationRef = Object(react["useRef"])(null);\n    const wrapperRef = userWrapperRef || defaultWrapperRef;\n    const defaultGetTableSize = Object(react["useCallback"])(() => {\n        var _a, _b;\n        if (wrapperRef.current) {\n            // `initialWidth` and `initialHeight` could be also parameters like `100%`\n            // `Number` reaturns `NaN` on them, then we fallback to computed size\n            const width = Number(initialWidth) || wrapperRef.current.clientWidth;\n            const height = (Number(initialHeight) || wrapperRef.current.clientHeight) -\n                (((_a = globalControlRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight) || 0) -\n                (((_b = paginationRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight) || 0);\n            return { width, height };\n        }\n        return undefined;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [initialHeight, initialWidth, wrapperRef, hasPagination, hasGlobalControl]);\n    const defaultGlobalFilter = Object(react["useCallback"])((rows, columnIds, filterValue) => {\n        // allow searching by "col1 col2"\n        const joinedString = (row) => {\n            return columnIds.map(x => row.values[x]).join(\' \');\n        };\n        return Object(match_sorter_esm["a" /* default */])(rows, filterValue, {\n            keys: [...columnIds, joinedString],\n            threshold: match_sorter_esm["a" /* default */].rankings.ACRONYM,\n        });\n    }, []);\n    const { getTableProps, getTableBodyProps, prepareRow, headerGroups, page, pageCount, gotoPage, preGlobalFilteredRows, setGlobalFilter, setPageSize: setPageSize_, wrapStickyTable, state: { pageIndex, pageSize, globalFilter: filterValue, sticky = {} }, } = Object(react_table["useTable"])(Object.assign({ columns,\n        data,\n        initialState, getTableSize: defaultGetTableSize, globalFilter: defaultGlobalFilter }, moreUseTableOptions), ...tableHooks);\n    // make setPageSize accept 0\n    const setPageSize = (size) => {\n        // keep the original size if data is empty\n        if (size || data.length !== 0) {\n            setPageSize_(size === 0 ? data.length : size);\n        }\n    };\n    const renderTable = () => (react_default.a.createElement("table", Object.assign({}, getTableProps({ className: tableClassName })),\n        react_default.a.createElement("thead", null, headerGroups.map(headerGroup => {\n            const _a = headerGroup.getHeaderGroupProps(), { key: headerGroupKey } = _a, headerGroupProps = __rest(_a, ["key"]);\n            return (react_default.a.createElement("tr", Object.assign({ key: headerGroupKey || headerGroup.id }, headerGroupProps), headerGroup.headers.map(column => {\n                return column.render(\'Header\', Object.assign({ key: column.id }, column.getSortByToggleProps()));\n            })));\n        })),\n        react_default.a.createElement("tbody", Object.assign({}, getTableBodyProps()), page && page.length > 0 ? (page.map(row => {\n            prepareRow(row);\n            const _a = row.getRowProps(), { key: rowKey } = _a, rowProps = __rest(_a, ["key"]);\n            return (react_default.a.createElement("tr", Object.assign({ key: rowKey || row.id }, rowProps), row.cells.map(cell => cell.render(\'Cell\', { key: cell.column.id }))));\n        })) : (react_default.a.createElement("tr", null,\n            react_default.a.createElement("td", { className: "dt-no-results", colSpan: columns.length }, typeof noResults === \'function\' ? noResults(filterValue) : noResults))))));\n    // force upate the pageSize when it\'s been update from the initial state\n    if (pageSizeRef.current[0] !== initialPageSize ||\n        // when initialPageSize stays as zero, but total number of records changed,\n        // we\'d also need to update page size\n        (initialPageSize === 0 && pageSizeRef.current[1] !== data.length)) {\n        pageSizeRef.current = [initialPageSize, data.length];\n        setPageSize(initialPageSize);\n    }\n    return (react_default.a.createElement("div", { ref: wrapperRef, style: { width: initialWidth, height: initialHeight } },\n        hasGlobalControl ? (react_default.a.createElement("div", { ref: globalControlRef, className: "form-inline dt-controls" },\n            react_default.a.createElement("div", { className: "row" },\n                react_default.a.createElement("div", { className: "col-sm-6" }, hasPagination ? (react_default.a.createElement(components_SelectPageSize, { total: data.length, current: pageSize, options: pageSizeOptions, selectRenderer: typeof selectPageSize === \'boolean\' ? undefined : selectPageSize, onChange: setPageSize })) : null),\n                searchInput ? (react_default.a.createElement("div", { className: "col-sm-6" },\n                    react_default.a.createElement(components_GlobalFilter, { searchInput: typeof searchInput === \'boolean\' ? undefined : searchInput, preGlobalFilteredRows: preGlobalFilteredRows, setGlobalFilter: setGlobalFilter, filterValue: filterValue }))) : null))) : null,\n        wrapStickyTable ? wrapStickyTable(renderTable) : renderTable(),\n        hasPagination ? (react_default.a.createElement(components_Pagination, { ref: paginationRef, style: sticky.height ? undefined : { visibility: \'hidden\' }, maxPageItemCount: maxPageItemCount, pageCount: pageCount, currentPage: pageIndex, onPageChange: gotoPage })) : null));\n}\n\n// EXTERNAL MODULE: ../superset-ui-core/src/style/index.ts\nvar src_style = __webpack_require__(536);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/Styles.tsx\n\n/* harmony default export */ var Styles = (src_style["c" /* styled */].div `\n  table {\n    width: 100%;\n    min-width: auto;\n    max-width: none;\n    margin: 0;\n  }\n\n  th,\n  td {\n    min-width: 4.3em;\n  }\n\n  thead > tr > th {\n    padding-right: 1.4em;\n    position: relative;\n    background: #fff;\n  }\n  th svg {\n    color: #ccc;\n    position: absolute;\n    bottom: 0.6em;\n    right: 0.2em;\n  }\n  th.is-sorted svg {\n    color: #a8a8a8;\n  }\n  .table > tbody > tr:first-of-type > td,\n  .table > tbody > tr:first-of-type > th {\n    border-top: 0;\n  }\n\n  .dt-controls {\n    padding-bottom: 0.65em;\n  }\n  .dt-metric {\n    text-align: right;\n  }\n  td.dt-is-filter {\n    cursor: pointer;\n  }\n  td.dt-is-filter:hover {\n    background-color: linen;\n  }\n  td.dt-is-active-filter,\n  td.dt-is-active-filter:hover {\n    background-color: lightcyan;\n  }\n\n  .dt-global-filter {\n    float: right;\n  }\n\n  .dt-pagination {\n    text-align: right;\n    /* use padding instead of margin so clientHeight can capture it */\n    padding-top: 0.5em;\n  }\n  .dt-pagination .pagination {\n    margin: 0;\n  }\n\n  .pagination > li > span.dt-pagination-ellipsis:focus,\n  .pagination > li > span.dt-pagination-ellipsis:hover {\n    background: #fff;\n  }\n\n  .dt-no-results {\n    text-align: center;\n    padding: 1em 0.6em;\n  }\n`);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/xss/lib/index.js\nvar lib = __webpack_require__(2372);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/utils/formatValue.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nconst xss = new lib["FilterXSS"]({\n    whiteList: Object.assign(Object.assign({}, Object(lib["getDefaultWhiteList"])()), { span: [\'style\', \'class\', \'title\'], div: [\'style\', \'class\'], a: [\'style\', \'class\', \'href\', \'title\', \'target\'], img: [\'style\', \'class\', \'src\', \'alt\', \'title\', \'width\', \'height\'] }),\n    stripIgnoreTag: true,\n    css: false,\n});\nfunction isProbablyHTML(text) {\n    return /<[^>]+>/.test(text);\n}\n/**\n * Format text for cell value\n */\nfunction formatValue({ formatter }, value) {\n    if (value === null) {\n        return [false, \'N/A\'];\n    }\n    if (formatter) {\n        // in case percent metric can specify percent format in the future\n        return [false, formatter(value)];\n    }\n    if (typeof value === \'string\') {\n        return isProbablyHTML(value) ? [true, xss.process(value)] : [false, value];\n    }\n    return [false, value.toString()];\n}\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/controlPanel.tsx + 1 modules\nvar controlPanel = __webpack_require__(1036);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-table/src/TableChart.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n\n\n/**\n * Return sortType based on data type\n */\nfunction getSortTypeByDataType(dataType) {\n    if (dataType === types["a" /* DataType */].DateTime) {\n        return \'datetime\';\n    }\n    if (dataType === types["a" /* DataType */].String) {\n        return \'alphanumeric\';\n    }\n    return \'basic\';\n}\n/**\n * Cell background to render columns as horizontal bar chart\n */\nfunction cellBar({ value, valueRange, colorPositiveNegative = false, alignPositiveNegative, }) {\n    const [minValue, maxValue] = valueRange;\n    const r = colorPositiveNegative && value < 0 ? 150 : 0;\n    if (alignPositiveNegative) {\n        const perc = Math.abs(Math.round((value / maxValue) * 100));\n        // The 0.01 to 0.001 is a workaround for what appears to be a\n        // CSS rendering bug on flat, transparent colors\n        return (`linear-gradient(to right, rgba(${r},0,0,0.2), rgba(${r},0,0,0.2) ${perc}%, ` +\n            `rgba(0,0,0,0.01) ${perc}%, rgba(0,0,0,0.001) 100%)`);\n    }\n    const posExtent = Math.abs(Math.max(maxValue, 0));\n    const negExtent = Math.abs(Math.min(minValue, 0));\n    const tot = posExtent + negExtent;\n    const perc1 = Math.round((Math.min(negExtent + value, negExtent) / tot) * 100);\n    const perc2 = Math.round((Math.abs(value) / tot) * 100);\n    // The 0.01 to 0.001 is a workaround for what appears to be a\n    // CSS rendering bug on flat, transparent colors\n    return (`linear-gradient(to right, rgba(0,0,0,0.01), rgba(0,0,0,0.001) ${perc1}%, ` +\n        `rgba(${r},0,0,0.2) ${perc1}%, rgba(${r},0,0,0.2) ${perc1 + perc2}%, ` +\n        `rgba(0,0,0,0.01) ${perc1 + perc2}%, rgba(0,0,0,0.001) 100%)`);\n}\nfunction SortIcon({ column }) {\n    const { isSorted, isSortedDesc } = column;\n    let sortIcon = react_default.a.createElement(index_esm["a" /* FaSort */], null);\n    if (isSorted) {\n        sortIcon = isSortedDesc ? react_default.a.createElement(index_esm["b" /* FaSortDown */], null) : react_default.a.createElement(index_esm["c" /* FaSortUp */], null);\n    }\n    return sortIcon;\n}\nfunction TableChart_SearchInput({ count, value, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-global-filter" },\n        Object(TranslatorSingleton["e" /* t */])(\'Search\'),\n        \' \',\n        react_default.a.createElement("input", { className: "form-control input-sm", placeholder: Object(TranslatorSingleton["f" /* tn */])(\'search.num_records\', count), value: value, onChange: onChange })));\n}\nfunction TableChart_SelectPageSize({ options, current, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-select-page-size form-inline" },\n        Object(TranslatorSingleton["e" /* t */])(\'page_size.show\'),\n        \' \',\n        react_default.a.createElement("select", { className: "form-control input-sm", value: current, onBlur: () => { }, onChange: e => {\n                onChange(Number(e.target.value));\n            } }, options.map(option => {\n            const [size, text] = Array.isArray(option) ? option : [option, option];\n            return (react_default.a.createElement("option", { key: size, value: size }, text));\n        })),\n        \' \',\n        Object(TranslatorSingleton["e" /* t */])(\'page_size.entries\')));\n}\nfunction TableChart(props) {\n    const { height, width, data, columns: columnsMeta, alignPositiveNegative = false, colorPositiveNegative = false, includeSearch = false, pageSize = 0, showCellBars = true, emitFilter = false, sortDesc = false, onChangeFilter, filters: initialFilters, sticky = true, } = props;\n    const [filters, setFilters] = Object(react["useState"])(initialFilters);\n    // only take relevant page size options\n    const pageSizeOptions = Object(react["useMemo"])(() => controlPanel["a" /* PAGE_SIZE_OPTIONS */].filter(([n, _]) => n <= 2 * data.length), [data.length]);\n    const getValueRange = Object(react["useCallback"])(function getValueRange(key) {\n        var _a;\n        if (typeof ((_a = data === null || data === void 0 ? void 0 : data[0]) === null || _a === void 0 ? void 0 : _a[key]) === \'number\') {\n            const nums = data.map(row => row[key]);\n            return (alignPositiveNegative\n                ? [0, Object(max["a" /* default */])(nums.map(Math.abs))]\n                : Object(extent["a" /* default */])(nums));\n        }\n        return null;\n    }, [alignPositiveNegative, data]);\n    const isActiveFilterValue = Object(react["useCallback"])(function isActiveFilterValue(key, val) {\n        var _a;\n        return !!filters && ((_a = filters[key]) === null || _a === void 0 ? void 0 : _a.includes(val));\n    }, [filters]);\n    const toggleFilter = Object(react["useCallback"])(function toggleFilter(key, val) {\n        const updatedFilters = Object.assign({}, (filters || {}));\n        if (filters && isActiveFilterValue(key, val)) {\n            updatedFilters[key] = filters[key].filter((x) => x !== val);\n        }\n        else {\n            updatedFilters[key] = [...((filters === null || filters === void 0 ? void 0 : filters[key]) || []), val];\n        }\n        setFilters(updatedFilters);\n        if (onChangeFilter) {\n            onChangeFilter(updatedFilters);\n        }\n    }, [filters, isActiveFilterValue, onChangeFilter]);\n    const getColumnConfigs = Object(react["useCallback"])((column, i) => {\n        const { key, label, dataType } = column;\n        let className = \'\';\n        if (dataType === types["a" /* DataType */].Number) {\n            className += \' dt-metric\';\n        }\n        else if (emitFilter) {\n            className += \' dt-is-filter\';\n        }\n        const valueRange = showCellBars && getValueRange(key);\n        return {\n            id: String(i),\n            // must use custom accessor to allow `.` in column names\n            // typing is incorrect in current version of `@types/react-table`\n            // so we ask TS not to check.\n            accessor: ((datum) => datum[key]),\n            Cell: ({ column: col, value }) => {\n                const [isHtml, text] = formatValue(column, value);\n                const style = {\n                    background: valueRange\n                        ? cellBar({\n                            value: value,\n                            valueRange,\n                            alignPositiveNegative,\n                            colorPositiveNegative,\n                        })\n                        : undefined,\n                };\n                const html = isHtml ? { __html: text } : undefined;\n                const cellProps = {\n                    // show raw number in title in case of numeric values\n                    title: typeof value === \'number\' ? String(value) : undefined,\n                    onClick: emitFilter && !valueRange ? () => toggleFilter(key, value) : undefined,\n                    className: `${className}${isActiveFilterValue(key, value) ? \' dt-is-active-filter\' : \'\'}`,\n                    style,\n                };\n                if (html) {\n                    // eslint-disable-next-line react/no-danger\n                    return react_default.a.createElement("td", Object.assign({}, cellProps, { dangerouslySetInnerHTML: html }));\n                }\n                // If cellProps renderes textContent already, then we don\'t have to\n                // render `Cell`. This saves some time for large tables.\n                return react_default.a.createElement("td", Object.assign({}, cellProps), text);\n            },\n            Header: ({ column: col, title, onClick, style }) => {\n                return (react_default.a.createElement("th", { title: title, className: col.isSorted ? `${className || \'\'} is-sorted` : className, style: style, onClick: onClick },\n                    label,\n                    react_default.a.createElement(SortIcon, { column: col })));\n            },\n            sortDescFirst: sortDesc,\n            sortType: getSortTypeByDataType(dataType),\n        };\n    }, [\n        alignPositiveNegative,\n        colorPositiveNegative,\n        emitFilter,\n        getValueRange,\n        isActiveFilterValue,\n        showCellBars,\n        sortDesc,\n        toggleFilter,\n    ]);\n    const columns = Object(react["useMemo"])(() => {\n        return columnsMeta.map(getColumnConfigs);\n    }, [columnsMeta, getColumnConfigs]);\n    return (react_default.a.createElement(Styles, null,\n        react_default.a.createElement(DataTable, { columns: columns, data: data, tableClassName: "table table-striped table-condensed", pageSize: pageSize, pageSizeOptions: pageSizeOptions, width: width, height: height, \n            // 9 page items in > 340px works well even for 100+ pages\n            maxPageItemCount: width > 340 ? 9 : 7, noResults: (filter) => Object(TranslatorSingleton["e" /* t */])(filter ? \'No matching records found\' : \'No records found\'), searchInput: includeSearch && TableChart_SearchInput, selectPageSize: pageSize !== null && TableChart_SelectPageSize, \n            // not in use in Superset, but needed for unit tests\n            sticky: sticky })));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ4Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL3V0aWxzL3VzZUFzeW5jU3RhdGUudHM/YjUzNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9jb21wb25lbnRzL0dsb2JhbEZpbHRlci50c3g/NzNjYSIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9jb21wb25lbnRzL1NlbGVjdFBhZ2VTaXplLnRzeD80YTExIiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL2NvbXBvbmVudHMvUGFnaW5hdGlvbi50c3g/NDMzNyIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS91dGlscy9nZXRTY3JvbGxCYXJTaXplLnRzPzcxMjgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXRhYmxlL3NyYy9EYXRhVGFibGUvdXRpbHMvbmVlZFNjcm9sbEJhci50cz82Y2ZkIiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL3V0aWxzL3VzZU1vdW50ZWRNZW1vLnRzPzJiNDYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXRhYmxlL3NyYy9EYXRhVGFibGUvaG9va3MvdXNlU3RpY2t5LnRzeD84MTQ5Iiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL0RhdGFUYWJsZS50c3g/ZGNjMyIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL1N0eWxlcy50c3g/Y2E4ZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL3V0aWxzL2Zvcm1hdFZhbHVlLnRzPzcwNzgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXRhYmxlL3NyYy9UYWJsZUNoYXJ0LnRzeD8yNzBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VBc3luY0RlYm91bmNlIH0gZnJvbSAncmVhY3QtdGFibGUnO1xuXG4vLyB1c2VBc3luY0RlYm91bmNlIGluIGRpc3QgYnVpbGQgb2YgYHJlYWN0LXRhYmxlYCByZXF1aXJlcyByZWdlbmVyYXRvclJ1bnRpbWVcbmltcG9ydCAncmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lJztcblxuLyoqXG4gKiBIb29rIHVzZVN0YXRlIHRvIGFsbG93IGFsd2F5cyByZXR1cm4gbGF0ZXN0IGluaXRpYWxWYWx1ZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VBc3luY1N0YXRlPFQsIEYgZXh0ZW5kcyAobmV3VmFsdWU6IFQpID0+IHVua25vd24+KFxuICBpbml0aWFsVmFsdWU6IFQsXG4gIGNhbGxiYWNrOiBGLFxuICB3YWl0OiBudW1iZXIgPSAyMDAsXG4pIHtcbiAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VTdGF0ZShpbml0aWFsVmFsdWUpO1xuICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZihpbml0aWFsVmFsdWUpO1xuICBjb25zdCBvbkNoYW5nZSA9IHVzZUFzeW5jRGVib3VuY2UoY2FsbGJhY2ssIHdhaXQpO1xuXG4gIC8vIHN5bmMgdXBkYXRlZCBpbml0aWFsVmFsdWVcbiAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgIT09IGluaXRpYWxWYWx1ZSkge1xuICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBpbml0aWFsVmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHNldFZhbHVlKGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2V0Qm90aCA9IChuZXdWYWx1ZTogVCkgPT4ge1xuICAgIHNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICBvbkNoYW5nZShuZXdWYWx1ZSk7XG4gIH07XG5cbiAgcmV0dXJuIFt2YWx1ZSwgc2V0Qm90aF0gYXMgW3R5cGVvZiB2YWx1ZSwgdHlwZW9mIHNldFZhbHVlXTtcbn1cbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnRUeXBlLCBDaGFuZ2VFdmVudEhhbmRsZXIgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBSb3csIEZpbHRlclZhbHVlIH0gZnJvbSAncmVhY3QtdGFibGUnO1xuaW1wb3J0IHVzZUFzeW5jU3RhdGUgZnJvbSAnLi4vdXRpbHMvdXNlQXN5bmNTdGF0ZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoSW5wdXRQcm9wcyB7XG4gIGNvdW50OiBudW1iZXI7XG4gIHZhbHVlOiBzdHJpbmc7XG4gIG9uQ2hhbmdlOiBDaGFuZ2VFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2xvYmFsRmlsdGVyUHJvcHM8RCBleHRlbmRzIG9iamVjdD4ge1xuICBwcmVHbG9iYWxGaWx0ZXJlZFJvd3M6IFJvdzxEPltdO1xuICAvLyBmaWx0ZXIgdmFsdWUgY2Fubm90IGJlIGB1bmRlZmluZWRgIG90aGVyd2lzZSBSZWFjdCB3aWxsIHJlcG9ydCBjb21wb25lbnRcbiAgLy8gY29udHJvbCB0eXBlIHVuZGVmaW5lZCBlcnJvclxuICBmaWx0ZXJWYWx1ZTogc3RyaW5nO1xuICBzZXRHbG9iYWxGaWx0ZXI6IChmaWx0ZXJWYWx1ZTogRmlsdGVyVmFsdWUpID0+IHZvaWQ7XG4gIHNlYXJjaElucHV0PzogQ29tcG9uZW50VHlwZTxTZWFyY2hJbnB1dFByb3BzPjtcbn1cblxuZnVuY3Rpb24gRGVmYXVsdFNlYXJjaElucHV0KHsgY291bnQsIHZhbHVlLCBvbkNoYW5nZSB9OiBTZWFyY2hJbnB1dFByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiZHQtZ2xvYmFsLWZpbHRlclwiPlxuICAgICAgU2VhcmNoeycgJ31cbiAgICAgIDxpbnB1dFxuICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2wgaW5wdXQtc21cIlxuICAgICAgICBwbGFjZWhvbGRlcj17YCR7Y291bnR9IHJlY29yZHMuLi5gfVxuICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIC8+XG4gICAgPC9zcGFuPlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoUmVhY3QubWVtbyBhcyA8VD4oZm46IFQpID0+IFQpKGZ1bmN0aW9uIEdsb2JhbEZpbHRlcjxEIGV4dGVuZHMgb2JqZWN0Pih7XG4gIHByZUdsb2JhbEZpbHRlcmVkUm93cyxcbiAgZmlsdGVyVmFsdWUgPSAnJyxcbiAgc2VhcmNoSW5wdXQsXG4gIHNldEdsb2JhbEZpbHRlcixcbn06IEdsb2JhbEZpbHRlclByb3BzPEQ+KSB7XG4gIGNvbnN0IGNvdW50ID0gcHJlR2xvYmFsRmlsdGVyZWRSb3dzLmxlbmd0aDtcbiAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VBc3luY1N0YXRlKFxuICAgIGZpbHRlclZhbHVlLFxuICAgIChuZXdWYWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICBzZXRHbG9iYWxGaWx0ZXIobmV3VmFsdWUgfHwgdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIDIwMCxcbiAgKTtcblxuICBjb25zdCBTZWFyY2hJbnB1dCA9IHNlYXJjaElucHV0IHx8IERlZmF1bHRTZWFyY2hJbnB1dDtcblxuICByZXR1cm4gKFxuICAgIDxTZWFyY2hJbnB1dFxuICAgICAgY291bnQ9e2NvdW50fVxuICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldFZhbHVlKHRhcmdldC52YWx1ZSk7XG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59KTtcbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCB0eXBlIFNpemVPcHRpb24gPSBudW1iZXIgfCBbbnVtYmVyLCBzdHJpbmddO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdFBhZ2VTaXplUmVuZGVyZXJQcm9wcyB7XG4gIGN1cnJlbnQ6IG51bWJlcjtcbiAgb3B0aW9uczogU2l6ZU9wdGlvbltdO1xuICBvbkNoYW5nZTogU2VsZWN0UGFnZVNpemVQcm9wc1snb25DaGFuZ2UnXTtcbn1cblxuZnVuY3Rpb24gRGVmYXVsdFNlbGVjdFJlbmRlcmVyKHsgY3VycmVudCwgb3B0aW9ucywgb25DaGFuZ2UgfTogU2VsZWN0UGFnZVNpemVSZW5kZXJlclByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiZHQtc2VsZWN0LXBhZ2Utc2l6ZSBmb3JtLWlubGluZVwiPlxuICAgICAgU2hvd3snICd9XG4gICAgICA8c2VsZWN0XG4gICAgICAgIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbCBpbnB1dC1zbVwiXG4gICAgICAgIHZhbHVlPXtjdXJyZW50fVxuICAgICAgICBvbkJsdXI9eygpID0+IHt9fVxuICAgICAgICBvbkNoYW5nZT17ZSA9PiB7XG4gICAgICAgICAgb25DaGFuZ2UoTnVtYmVyKChlLnRhcmdldCBhcyBIVE1MU2VsZWN0RWxlbWVudCkudmFsdWUpKTtcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge29wdGlvbnMubWFwKG9wdGlvbiA9PiB7XG4gICAgICAgICAgY29uc3QgW3NpemUsIHRleHRdID0gQXJyYXkuaXNBcnJheShvcHRpb24pID8gb3B0aW9uIDogW29wdGlvbiwgb3B0aW9uXTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9e3NpemV9IHZhbHVlPXtzaXplfT5cbiAgICAgICAgICAgICAge3RleHR9XG4gICAgICAgICAgICA8L29wdGlvbj5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvc2VsZWN0PnsnICd9XG4gICAgICBlbnRyaWVzXG4gICAgPC9zcGFuPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdFBhZ2VTaXplUHJvcHMgZXh0ZW5kcyBTZWxlY3RQYWdlU2l6ZVJlbmRlcmVyUHJvcHMge1xuICB0b3RhbD86IG51bWJlcjtcbiAgc2VsZWN0UmVuZGVyZXI/OiB0eXBlb2YgRGVmYXVsdFNlbGVjdFJlbmRlcmVyO1xuICBvbkNoYW5nZTogKHBhZ2VTaXplOiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvblZhbHVlKHg6IFNpemVPcHRpb24pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgPyB4WzBdIDogeDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhmdW5jdGlvbiBTZWxlY3RQYWdlU2l6ZSh7XG4gIHRvdGFsLFxuICBvcHRpb25zOiBzaXplT3B0aW9ucyxcbiAgY3VycmVudDogY3VycmVudFNpemUsXG4gIHNlbGVjdFJlbmRlcmVyLFxuICBvbkNoYW5nZSxcbn06IFNlbGVjdFBhZ2VTaXplUHJvcHMpIHtcbiAgY29uc3Qgc2l6ZU9wdGlvblZhbHVlcyA9IHNpemVPcHRpb25zLm1hcChnZXRPcHRpb25WYWx1ZSk7XG4gIGxldCBvcHRpb25zID0gWy4uLnNpemVPcHRpb25zXTtcbiAgLy8gaW5zZXJ0IGN1cnJlbnQgc2l6ZSB0byBsaXN0XG4gIGlmIChcbiAgICBjdXJyZW50U2l6ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgKGN1cnJlbnRTaXplICE9PSB0b3RhbCB8fCAhc2l6ZU9wdGlvblZhbHVlcy5pbmNsdWRlcygwKSkgJiZcbiAgICAhc2l6ZU9wdGlvblZhbHVlcy5pbmNsdWRlcyhjdXJyZW50U2l6ZSlcbiAgKSB7XG4gICAgb3B0aW9ucyA9IFsuLi5zaXplT3B0aW9uc107XG4gICAgb3B0aW9ucy5zcGxpY2UoXG4gICAgICBzaXplT3B0aW9uVmFsdWVzLmZpbmRJbmRleCh4ID0+IHggPiBjdXJyZW50U2l6ZSksXG4gICAgICAwLFxuICAgICAgY3VycmVudFNpemUsXG4gICAgKTtcbiAgfVxuICBjb25zdCBjdXJyZW50ID0gY3VycmVudFNpemUgPT09IHVuZGVmaW5lZCA/IHNpemVPcHRpb25WYWx1ZXNbMF0gOiBjdXJyZW50U2l6ZTtcbiAgY29uc3QgU2VsZWN0UmVuZGVyZXIgPSBzZWxlY3RSZW5kZXJlciB8fCBEZWZhdWx0U2VsZWN0UmVuZGVyZXI7XG4gIHJldHVybiA8U2VsZWN0UmVuZGVyZXIgY3VycmVudD17Y3VycmVudH0gb3B0aW9ucz17b3B0aW9uc30gb25DaGFuZ2U9e29uQ2hhbmdlfSAvPjtcbn0pO1xuIiwiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnaW5hdGlvblByb3BzIHtcbiAgcGFnZUNvdW50OiBudW1iZXI7IC8vIG51bWJlciBvZiBwYWdlc1xuICBjdXJyZW50UGFnZT86IG51bWJlcjsgLy8gaW5kZXggb2YgY3VycmVudCBwYWdlLCB6ZXJvLWJhc2VkXG4gIG1heFBhZ2VJdGVtQ291bnQ/OiBudW1iZXI7XG4gIGVsbGlwc2lzPzogc3RyaW5nOyAvLyBjb250ZW50IGZvciBlbGxpcHNpcyBpdGVtXG4gIG9uUGFnZUNoYW5nZTogKHBhZ2U6IG51bWJlcikgPT4gdm9pZDsgLy8gYHBhZ2VgIGlzIHplcm8tYmFzZWRcbiAgc3R5bGU/OiBDU1NQcm9wZXJ0aWVzO1xufVxuXG4vLyBmaXJzdCwgLi4uLCBwcmV2LCBjdXJyZW50LCBuZXh0LCAuLi4sIGxhc3RcbmNvbnN0IE1JTklNQUxfUEFHRV9JVEVNX0NPVU5UID0gNztcblxuLyoqXG4gKiBHZW5lcmF0ZSBudW1lcmljIHBhZ2UgaXRlbXMgYXJvdW5kIGN1cnJlbnQgcGFnZS5cbiAqICAgLSBBbHdheXMgaW5jbHVkZSBmaXJzdCBhbmQgbGFzdCBwYWdlXG4gKiAgIC0gQWRkIGVsbGlwc2lzIGlmIG5lZWRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQYWdlSXRlbXModG90YWw6IG51bWJlciwgY3VycmVudDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKSB7XG4gIGlmICh3aWR0aCA8IE1JTklNQUxfUEFHRV9JVEVNX0NPVU5UKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNdXN0IGFsbG93IGF0IGxlYXN0ICR7TUlOSU1BTF9QQUdFX0lURU1fQ09VTlR9IHBhZ2UgaXRlbXNgKTtcbiAgfVxuICBpZiAod2lkdGggJSAyID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNdXN0IGFsbG93IG9kZCBudW1iZXIgb2YgcGFnZSBpdGVtc2ApO1xuICB9XG4gIGlmICh0b3RhbCA8IHdpZHRoKSB7XG4gICAgcmV0dXJuIFsuLi5uZXcgQXJyYXkodG90YWwpLmtleXMoKV07XG4gIH1cbiAgY29uc3QgbGVmdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRvdGFsIC0gd2lkdGgsIGN1cnJlbnQgLSBNYXRoLmZsb29yKHdpZHRoIC8gMikpKTtcbiAgY29uc3QgaXRlbXM6IChzdHJpbmcgfCBudW1iZXIpW10gPSBuZXcgQXJyYXkod2lkdGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpICs9IDEpIHtcbiAgICBpdGVtc1tpXSA9IGkgKyBsZWZ0O1xuICB9XG4gIC8vIHJlcGxhY2Ugbm9uLWVuZGluZyBpdGVtcyB3aXRoIHBsYWNlaG9sZGVyc1xuICBpZiAoaXRlbXNbMF0gPiAwKSB7XG4gICAgaXRlbXNbMF0gPSAwO1xuICAgIGl0ZW1zWzFdID0gJ3ByZXYtbW9yZSc7XG4gIH1cbiAgaWYgKGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdIDwgdG90YWwgLSAxKSB7XG4gICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0gPSB0b3RhbCAtIDE7XG4gICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMl0gPSAnbmV4dC1tb3JlJztcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlYWN0Lm1lbW8oXG4gIFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gUGFnaW5hdGlvbihcbiAgICB7IHN0eWxlLCBwYWdlQ291bnQsIGN1cnJlbnRQYWdlID0gMCwgbWF4UGFnZUl0ZW1Db3VudCA9IDksIG9uUGFnZUNoYW5nZSB9OiBQYWdpbmF0aW9uUHJvcHMsXG4gICAgcmVmOiBSZWFjdC5SZWY8SFRNTERpdkVsZW1lbnQ+LFxuICApIHtcbiAgICBjb25zdCBwYWdlSXRlbXMgPSBnZW5lcmF0ZVBhZ2VJdGVtcyhwYWdlQ291bnQsIGN1cnJlbnRQYWdlLCBtYXhQYWdlSXRlbUNvdW50KTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiByZWY9e3JlZn0gY2xhc3NOYW1lPVwiZHQtcGFnaW5hdGlvblwiIHN0eWxlPXtzdHlsZX0+XG4gICAgICAgIDx1bCBjbGFzc05hbWU9XCJwYWdpbmF0aW9uIHBhZ2luYXRpb24tc21cIj5cbiAgICAgICAgICB7cGFnZUl0ZW1zLm1hcCgoaXRlbSwgaSkgPT5cbiAgICAgICAgICAgIHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyA/IChcbiAgICAgICAgICAgICAgLy8gYWN0dWFsIHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAgIDxsaSBrZXk9e2l0ZW19IGNsYXNzTmFtZT17Y3VycmVudFBhZ2UgPT09IGl0ZW0gPyAnYWN0aXZlJyA6IHVuZGVmaW5lZH0+XG4gICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgIGhyZWY9e2AjcGFnZS0ke2l0ZW19YH1cbiAgICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgb25DbGljaz17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgb25QYWdlQ2hhbmdlKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7aXRlbSArIDF9XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgPGxpIGtleT17aXRlbX0gY2xhc3NOYW1lPVwiZHQtcGFnaW5hdGlvbi1lbGxpcHNpc1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuPuKApjwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICksXG4gICAgICAgICAgKX1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH0pLFxuKTtcbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmxldCBjYWNoZWQ6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuY29uc3QgY3NzID0gKHg6IFRlbXBsYXRlU3RyaW5nc0FycmF5KSA9PiB4LmpvaW4oJ1xcbicpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxCYXJTaXplKGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGNhY2hlZCA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGNvbnN0IGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3Qgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbm5lci5zdHlsZS5jc3NUZXh0ID0gY3NzYFxuICAgICAgd2lkdGg6IGF1dG87XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBvdmVyZmxvdzogc2Nyb2xsO1xuICAgIGA7XG4gICAgb3V0ZXIuc3R5bGUuY3NzVGV4dCA9IGNzc2BcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB3aWR0aDogMTAwcHg7XG4gICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgYDtcbiAgICBvdXRlci5hcHBlbmQoaW5uZXIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKG91dGVyKTtcbiAgICBjYWNoZWQgPSBvdXRlci5jbGllbnRXaWR0aCAtIGlubmVyLmNsaWVudFdpZHRoO1xuICAgIG91dGVyLnJlbW92ZSgpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFdoZXRoZXIgYSBjb250YWluZXIgbmVlZCBzY3JvbGwgYmFycyB3aGVuIGluIGFub3RoZXIgY29udGFpbmVyLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBuZWVkU2Nyb2xsQmFyKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgaW5uZXJIZWlnaHQsXG4gIGlubmVyV2lkdGgsXG4gIHNjcm9sbEJhclNpemUsXG59OiB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBpbm5lckhlaWdodDogbnVtYmVyO1xuICBzY3JvbGxCYXJTaXplOiBudW1iZXI7XG4gIGlubmVyV2lkdGg6IG51bWJlcjtcbn0pOiBbYm9vbGVhbiwgYm9vbGVhbl0ge1xuICBjb25zdCBoYXNWZXJ0aWNhbFNjcm9sbCA9IGlubmVySGVpZ2h0ID4gaGVpZ2h0O1xuICBjb25zdCBoYXNIb3Jpem9udGFsU2Nyb2xsID0gaW5uZXJXaWR0aCA+IHdpZHRoIC0gKGhhc1ZlcnRpY2FsU2Nyb2xsID8gc2Nyb2xsQmFyU2l6ZSA6IDApO1xuICByZXR1cm4gW2hhc1ZlcnRpY2FsU2Nyb2xsLCBoYXNIb3Jpem9udGFsU2Nyb2xsXTtcbn1cbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlUmVmLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBtZW1vaXplZCBjYWxsYmFjayBvbmx5IHdoZW4gbW91bnRlZC4gRXhlY3V0ZSBhZ2FpbiB3aGVuIGZhY3RvcnkgdXBkYXRlZC5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vdCBtb3VudGVkIHlldC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTW91bnRlZE1lbW88VD4oZmFjdG9yeTogKCkgPT4gVCwgZGVwcz86IHVua25vd25bXSk6IFQgfCB1bmRlZmluZWQge1xuICBjb25zdCBtb3VudGVkID0gdXNlUmVmPHR5cGVvZiBmYWN0b3J5PigpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIG1vdW50ZWQuY3VycmVudCA9IGZhY3Rvcnk7XG4gIH0pO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKG1vdW50ZWQuY3VycmVudCkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFttb3VudGVkLmN1cnJlbnQsIG1vdW50ZWQuY3VycmVudCA9PT0gZmFjdG9yeSwgLi4uKGRlcHMgfHwgW10pXSk7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHtcbiAgdXNlUmVmLFxuICB1c2VNZW1vLFxuICB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZUNhbGxiYWNrLFxuICBSZWFjdE5vZGUsXG4gIFJlYWN0RWxlbWVudCxcbiAgQ29tcG9uZW50UHJvcHNXaXRoUmVmLFxuICBDU1NQcm9wZXJ0aWVzLFxuICBVSUV2ZW50SGFuZGxlcixcbn0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVGFibGVJbnN0YW5jZSwgSG9va3MgfSBmcm9tICdyZWFjdC10YWJsZSc7XG5pbXBvcnQgZ2V0U2Nyb2xsQmFyU2l6ZSBmcm9tICcuLi91dGlscy9nZXRTY3JvbGxCYXJTaXplJztcbmltcG9ydCBuZWVkU2Nyb2xsQmFyIGZyb20gJy4uL3V0aWxzL25lZWRTY3JvbGxCYXInO1xuaW1wb3J0IHVzZU1vdW50ZWRNZW1vIGZyb20gJy4uL3V0aWxzL3VzZU1vdW50ZWRNZW1vJztcblxudHlwZSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48XG4gIFQgZXh0ZW5kcyBrZXlvZiBKU1guSW50cmluc2ljRWxlbWVudHMsXG4gIEMgZXh0ZW5kcyBSZWFjdE5vZGUgPSBSZWFjdE5vZGVcbj4gPSBSZWFjdEVsZW1lbnQ8Q29tcG9uZW50UHJvcHNXaXRoUmVmPFQ+ICYgeyBjaGlsZHJlbjogQyB9LCBUPjtcblxudHlwZSBUaCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndGgnPjtcbnR5cGUgVGQgPSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48J3RkJz47XG50eXBlIFRyV2l0aFRoID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCd0cicsIFRoW10+O1xudHlwZSBUcldpdGhUZCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndHInLCBUZFtdPjtcbnR5cGUgVGhlYWQgPSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48J3RoZWFkJywgVHJXaXRoVGg+O1xudHlwZSBUYm9keSA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndGJvZHknLCBUcldpdGhUZD47XG50eXBlIENvbCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwnY29sJywgbnVsbD47XG50eXBlIENvbEdyb3VwID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCdjb2xncm91cCcsIENvbD47XG5cbmV4cG9ydCB0eXBlIFRhYmxlID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCd0YWJsZScsIChUaGVhZCB8IFRib2R5IHwgQ29sR3JvdXApW10+O1xuZXhwb3J0IHR5cGUgVGFibGVSZW5kZXJlciA9ICgpID0+IFRhYmxlO1xuZXhwb3J0IHR5cGUgR2V0VGFibGVTaXplID0gKCkgPT4gUGFydGlhbDxTdGlja3lTdGF0ZT4gfCB1bmRlZmluZWQ7XG5leHBvcnQgdHlwZSBTZXRTdGlja3lTdGF0ZSA9IChzaXplPzogU3RpY2t5U3RhdGUpID0+IHZvaWQ7XG5cbmV4cG9ydCBlbnVtIFJlZHVjZXJBY3Rpb25zIHtcbiAgaW5pdCA9ICdpbml0JywgLy8gdGhpcyBpcyBmcm9tIGdsb2JhbCByZWR1Y2VyXG4gIHNldFN0aWNreVN0YXRlID0gJ3NldFN0aWNreVN0YXRlJyxcbn1cblxuZXhwb3J0IHR5cGUgUmVkdWNlckFjdGlvbjxUIGV4dGVuZHMgc3RyaW5nLCBQIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+ID0gUCAmIHsgdHlwZTogVCB9O1xuXG5leHBvcnQgdHlwZSBDb2x1bW5XaWR0aHMgPSBudW1iZXJbXTtcblxuZXhwb3J0IGludGVyZmFjZSBTdGlja3lTdGF0ZSB7XG4gIHdpZHRoPzogbnVtYmVyOyAvLyBtYXhpbXVtIGZ1bGwgdGFibGUgd2lkdGhcbiAgaGVpZ2h0PzogbnVtYmVyOyAvLyBtYXhpbXVtIGZ1bGwgdGFibGUgaGVpZ2h0XG4gIHJlYWxIZWlnaHQ/OiBudW1iZXI7IC8vIGFjdHVhbCB0YWJsZSB2aWV3cG9ydCBoZWlnaHQgKGhlYWRlciArIHNjcm9sbGFibGUgYXJlYSlcbiAgYm9keUhlaWdodD86IG51bWJlcjsgLy8gc2Nyb2xsYWJsZSBhcmVhIGhlaWdodFxuICB0YWJsZUhlaWdodD86IG51bWJlcjsgLy8gdGhlIGZ1bGwgdGFibGUgaGVpZ2h0XG4gIGNvbHVtbldpZHRocz86IENvbHVtbldpZHRocztcbiAgaGFzSG9yaXpvbnRhbFNjcm9sbD86IGJvb2xlYW47XG4gIGhhc1ZlcnRpY2FsU2Nyb2xsPzogYm9vbGVhbjtcbiAgcmVuZGVyaW5nPzogYm9vbGVhbjtcbiAgc2V0U3RpY2t5U3RhdGU/OiBTZXRTdGlja3lTdGF0ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTdGlja3lUYWJsZU9wdGlvbnMge1xuICBnZXRUYWJsZVNpemU/OiBHZXRUYWJsZVNpemU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU3RpY2t5SW5zdGFuY2VQcm9wcyB7XG4gIC8vIG1hbmlwdWxhdGUgRE9NcyBpbiA8dGFibGU+IHRvIG1ha2UgdGhlIGhlYWRlciBzdGlja3lcbiAgd3JhcFN0aWNreVRhYmxlOiAocmVuZGVyZXI6IFRhYmxlUmVuZGVyZXIpID0+IFJlYWN0Tm9kZTtcbiAgLy8gdXBkYXRlIG9yIHJlY29tcHV0ZSB0aGUgc3RpY2t5IHRhYmxlIHNpemVcbiAgc2V0U3RpY2t5U3RhdGU6IFNldFN0aWNreVN0YXRlO1xufVxuXG5leHBvcnQgdHlwZSBVc2VTdGlja3lTdGF0ZSA9IHtcbiAgc3RpY2t5OiBTdGlja3lTdGF0ZTtcbn07XG5cbmNvbnN0IHN1bSA9IChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSArIGI7XG5jb25zdCBtZXJnZVN0eWxlUHJvcCA9IChub2RlOiBSZWFjdEVsZW1lbnQ8eyBzdHlsZT86IENTU1Byb3BlcnRpZXMgfT4sIHN0eWxlOiBDU1NQcm9wZXJ0aWVzKSA9PiAoe1xuICBzdHlsZToge1xuICAgIC4uLm5vZGUucHJvcHMuc3R5bGUsXG4gICAgLi4uc3R5bGUsXG4gIH0sXG59KTtcblxuLyoqXG4gKiBBbiBIT0MgZm9yIGdlbmVyYXRpbmcgc3RpY2t5IGhlYWRlciBhbmQgZml4ZWQtaGVpZ2h0IHNjcm9sbGFibGUgYXJlYVxuICovXG5mdW5jdGlvbiBTdGlja3lXcmFwKHtcbiAgc3RpY2t5ID0ge30sXG4gIHdpZHRoOiBtYXhXaWR0aCxcbiAgaGVpZ2h0OiBtYXhIZWlnaHQsXG4gIGNoaWxkcmVuOiB0YWJsZSxcbiAgc2V0U3RpY2t5U3RhdGUsXG59OiB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBzZXRTdGlja3lTdGF0ZTogU2V0U3RpY2t5U3RhdGU7XG4gIGNoaWxkcmVuOiBUYWJsZTtcbiAgc3RpY2t5PzogU3RpY2t5U3RhdGU7IC8vIGN1cnJlbnQgc3RpY2t5IGVsZW1lbnQgc2l6ZXNcbn0pIHtcbiAgaWYgKCF0YWJsZSB8fCB0YWJsZS50eXBlICE9PSAndGFibGUnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc8U3RpY2t5V3JhcD4gbXVzdCBoYXZlIG9ubHkgb25lIDx0YWJsZT4gZWxlbWVudCBhcyBjaGlsZCcpO1xuICB9XG4gIGxldCB0aGVhZDogVGhlYWQgfCB1bmRlZmluZWQ7XG4gIGxldCB0Ym9keTogVGJvZHkgfCB1bmRlZmluZWQ7XG4gIGxldCBjb2xncm91cDogQ29sR3JvdXAgfCB1bmRlZmluZWQ7XG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2godGFibGUucHJvcHMuY2hpbGRyZW4sIG5vZGUgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09ICd0aGVhZCcpIHtcbiAgICAgIHRoZWFkID0gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ3Rib2R5Jykge1xuICAgICAgdGJvZHkgPSBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnY29sZ3JvdXAnKSB7XG4gICAgICBjb2xncm91cCA9IG5vZGU7XG4gICAgfVxuICB9KTtcbiAgaWYgKCF0aGVhZCB8fCAhdGJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzx0YWJsZT4gaW4gPFN0aWNreVdyYXA+IG11c3QgY29udGFpbiBib3RoIHRoZWFkIGFuZCB0Ym9keS4nKTtcbiAgfVxuICBjb25zdCBjb2x1bW5Db3VudCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGhlYWRlclJvd3MgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KHRoZWFkPy5wcm9wcy5jaGlsZHJlbikucG9wKCkgYXMgVHJXaXRoVGg7XG4gICAgcmV0dXJuIGhlYWRlclJvd3MucHJvcHMuY2hpbGRyZW4ubGVuZ3RoO1xuICB9LCBbdGhlYWRdKTtcblxuICBjb25zdCB0aGVhZFJlZiA9IHVzZVJlZjxIVE1MVGFibGVTZWN0aW9uRWxlbWVudD4obnVsbCk7IC8vIG9yaWdpbmFsIHRoZWFkIGZvciBsYXlvdXQgY29tcHV0YXRpb25cbiAgY29uc3Qgc2Nyb2xsSGVhZGVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTsgLy8gZml4ZWQgaGVhZGVyXG4gIGNvbnN0IHNjcm9sbEJvZHlSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpOyAvLyBtYWluIGJvZHlcblxuICBjb25zdCB7IGJvZHlIZWlnaHQsIGNvbHVtbldpZHRocyB9ID0gc3RpY2t5O1xuICBjb25zdCBuZWVkU2l6ZXIgPVxuICAgICFjb2x1bW5XaWR0aHMgfHxcbiAgICBzdGlja3kud2lkdGggIT09IG1heFdpZHRoIHx8XG4gICAgc3RpY2t5LmhlaWdodCAhPT0gbWF4SGVpZ2h0IHx8XG4gICAgc3RpY2t5LnNldFN0aWNreVN0YXRlICE9PSBzZXRTdGlja3lTdGF0ZTtcbiAgY29uc3Qgc2Nyb2xsQmFyU2l6ZSA9IGdldFNjcm9sbEJhclNpemUoKTtcblxuICAvLyB1cGRhdGUgc2Nyb2xsYWJsZSBhcmVhIGFuZCBoZWFkZXIgY29sdW1uIHNpemVzIHdoZW4gbW91bnRlZFxuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0aGVhZFJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zdCBib2R5VGhlYWQgPSB0aGVhZFJlZi5jdXJyZW50O1xuICAgICAgY29uc3QgdGhlYWRIZWlnaHQgPSBib2R5VGhlYWQuY2xpZW50SGVpZ2h0O1xuICAgICAgaWYgKCF0aGVhZEhlaWdodCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmdWxsVGFibGVIZWlnaHQgPSAoYm9keVRoZWFkLnBhcmVudE5vZGUgYXMgSFRNTFRhYmxlRWxlbWVudCkuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3QgdGhzID0gYm9keVRoZWFkLmNoaWxkTm9kZXNbMF0uY2hpbGROb2RlcyBhcyBOb2RlTGlzdE9mPEhUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50PjtcbiAgICAgIGNvbnN0IHdpZHRocyA9IEFycmF5LmZyb20odGhzKS5tYXAodGggPT4gdGguY2xpZW50V2lkdGgpO1xuICAgICAgY29uc3QgW2hhc1ZlcnRpY2FsU2Nyb2xsLCBoYXNIb3Jpem9udGFsU2Nyb2xsXSA9IG5lZWRTY3JvbGxCYXIoe1xuICAgICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICAgIGhlaWdodDogbWF4SGVpZ2h0IC0gdGhlYWRIZWlnaHQsXG4gICAgICAgIGlubmVySGVpZ2h0OiBmdWxsVGFibGVIZWlnaHQsXG4gICAgICAgIGlubmVyV2lkdGg6IHdpZHRocy5yZWR1Y2Uoc3VtKSxcbiAgICAgICAgc2Nyb2xsQmFyU2l6ZSxcbiAgICAgIH0pO1xuICAgICAgLy8gcmVhbCBjb250YWluZXIgaGVpZ2h0LCBpbmNsdWRlIHRhYmxlIGhlYWRlciBhbmQgc3BhY2UgZm9yXG4gICAgICAvLyBob3Jpem9udGFsIHNjcm9sbCBiYXJcbiAgICAgIGNvbnN0IHJlYWxIZWlnaHQgPSBNYXRoLm1pbihcbiAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICBoYXNIb3Jpem9udGFsU2Nyb2xsID8gZnVsbFRhYmxlSGVpZ2h0ICsgc2Nyb2xsQmFyU2l6ZSA6IGZ1bGxUYWJsZUhlaWdodCxcbiAgICAgICk7XG4gICAgICBzZXRTdGlja3lTdGF0ZSh7XG4gICAgICAgIGhhc1ZlcnRpY2FsU2Nyb2xsLFxuICAgICAgICBoYXNIb3Jpem9udGFsU2Nyb2xsLFxuICAgICAgICBzZXRTdGlja3lTdGF0ZSxcbiAgICAgICAgd2lkdGg6IG1heFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IG1heEhlaWdodCxcbiAgICAgICAgcmVhbEhlaWdodCxcbiAgICAgICAgdGFibGVIZWlnaHQ6IGZ1bGxUYWJsZUhlaWdodCxcbiAgICAgICAgYm9keUhlaWdodDogcmVhbEhlaWdodCAtIHRoZWFkSGVpZ2h0LFxuICAgICAgICBjb2x1bW5XaWR0aHM6IHdpZHRocyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW21heFdpZHRoLCBtYXhIZWlnaHQsIHNldFN0aWNreVN0YXRlLCBzY3JvbGxCYXJTaXplXSk7XG5cbiAgbGV0IHNpemVyVGFibGU6IFJlYWN0RWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgbGV0IGhlYWRlclRhYmxlOiBSZWFjdEVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gIGxldCBib2R5VGFibGU6IFJlYWN0RWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgaWYgKG5lZWRTaXplcikge1xuICAgIGNvbnN0IHRoZWFkV2l0aFJlZiA9IFJlYWN0LmNsb25lRWxlbWVudCh0aGVhZCwgeyByZWY6IHRoZWFkUmVmIH0pO1xuICAgIHNpemVyVGFibGUgPSAoXG4gICAgICA8ZGl2XG4gICAgICAgIGtleT1cInNpemVyXCJcbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBoZWlnaHQ6IG1heEhlaWdodCxcbiAgICAgICAgICBvdmVyZmxvdzogJ2F1dG8nLFxuICAgICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7UmVhY3QuY2xvbmVFbGVtZW50KHRhYmxlLCB7fSwgY29sZ3JvdXAsIHRoZWFkV2l0aFJlZiwgdGJvZHkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIC8vIHJldXNlIHByZXZpb3VzbHkgY29sdW1uIHdpZHRocywgd2lsbCBiZSB1cGRhdGVkIGJ5IGB1c2VMYXlvdXRFZmZlY3RgIGFib3ZlXG4gIGNvbnN0IGNvbFdpZHRocyA9IGNvbHVtbldpZHRocz8uc2xpY2UoMCwgY29sdW1uQ291bnQpO1xuICBpZiAoY29sV2lkdGhzICYmIGJvZHlIZWlnaHQpIHtcbiAgICBjb25zdCB0YWJsZVN0eWxlOiBDU1NQcm9wZXJ0aWVzID0geyB0YWJsZUxheW91dDogJ2ZpeGVkJyB9O1xuXG4gICAgY29uc3QgYm9keUNvbHMgPSBjb2xXaWR0aHMubWFwKCh3LCBpKSA9PiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICA8Y29sIGtleT17aX0gd2lkdGg9e3d9IC8+XG4gICAgKSk7XG4gICAgY29uc3QgYm9keUNvbGdyb3VwID0gPGNvbGdyb3VwPntib2R5Q29sc308L2NvbGdyb3VwPjtcblxuICAgIC8vIGhlYWRlciBjb2x1bW5zIGRvIG5vdCBoYXZlIHZlcnRpY2FsIHNjcm9sbCBiYXJzLFxuICAgIC8vIHNvIHdlIGFkZCBzY3JvbGwgYmFyIHNpemUgdG8gdGhlIGxhc3QgY29sdW1uXG4gICAgY29uc3QgaGVhZGVyQ29sZ3JvdXAgPVxuICAgICAgc3RpY2t5Lmhhc1ZlcnRpY2FsU2Nyb2xsICYmIHNjcm9sbEJhclNpemUgPyAoXG4gICAgICAgIDxjb2xncm91cD5cbiAgICAgICAgICB7Y29sV2lkdGhzLm1hcCgoeCwgaSkgPT4gKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgICAgPGNvbCBrZXk9e2l9IHdpZHRoPXt4ICsgKGkgPT09IGNvbFdpZHRocy5sZW5ndGggLSAxID8gc2Nyb2xsQmFyU2l6ZSA6IDApfSAvPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L2NvbGdyb3VwPlxuICAgICAgKSA6IChcbiAgICAgICAgYm9keUNvbGdyb3VwXG4gICAgICApO1xuXG4gICAgaGVhZGVyVGFibGUgPSAoXG4gICAgICA8ZGl2XG4gICAgICAgIGtleT1cImhlYWRlclwiXG4gICAgICAgIHJlZj17c2Nyb2xsSGVhZGVyUmVmfVxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge1JlYWN0LmNsb25lRWxlbWVudCh0YWJsZSwgbWVyZ2VTdHlsZVByb3AodGFibGUsIHRhYmxlU3R5bGUpLCBoZWFkZXJDb2xncm91cCwgdGhlYWQpfVxuICAgICAgICB7aGVhZGVyVGFibGV9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuXG4gICAgY29uc3Qgb25TY3JvbGw6IFVJRXZlbnRIYW5kbGVyPEhUTUxEaXZFbGVtZW50PiA9IGUgPT4ge1xuICAgICAgaWYgKHNjcm9sbEhlYWRlclJlZi5jdXJyZW50KSB7XG4gICAgICAgIHNjcm9sbEhlYWRlclJlZi5jdXJyZW50LnNjcm9sbExlZnQgPSBlLmN1cnJlbnRUYXJnZXQuc2Nyb2xsTGVmdDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGJvZHlUYWJsZSA9IChcbiAgICAgIDxkaXZcbiAgICAgICAga2V5PVwiYm9keVwiXG4gICAgICAgIHJlZj17c2Nyb2xsQm9keVJlZn1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBoZWlnaHQ6IGJvZHlIZWlnaHQsXG4gICAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgICAgfX1cbiAgICAgICAgb25TY3JvbGw9e3N0aWNreS5oYXNIb3Jpem9udGFsU2Nyb2xsID8gb25TY3JvbGwgOiB1bmRlZmluZWR9XG4gICAgICA+XG4gICAgICAgIHtSZWFjdC5jbG9uZUVsZW1lbnQodGFibGUsIG1lcmdlU3R5bGVQcm9wKHRhYmxlLCB0YWJsZVN0eWxlKSwgYm9keUNvbGdyb3VwLCB0Ym9keSl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBzdHlsZT17e1xuICAgICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICAgIGhlaWdodDogc3RpY2t5LnJlYWxIZWlnaHQgfHwgbWF4SGVpZ2h0LFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtoZWFkZXJUYWJsZX1cbiAgICAgIHtib2R5VGFibGV9XG4gICAgICB7c2l6ZXJUYWJsZX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gdXNlSW5zdGFuY2U8RCBleHRlbmRzIG9iamVjdD4oaW5zdGFuY2U6IFRhYmxlSW5zdGFuY2U8RD4pIHtcbiAgY29uc3Qge1xuICAgIGRpc3BhdGNoLFxuICAgIHN0YXRlOiB7IHN0aWNreSB9LFxuICAgIGRhdGEsXG4gICAgcGFnZSxcbiAgICByb3dzLFxuICAgIGdldFRhYmxlU2l6ZSA9ICgpID0+IHVuZGVmaW5lZCxcbiAgfSA9IGluc3RhbmNlO1xuXG4gIGNvbnN0IHNldFN0aWNreVN0YXRlID0gdXNlQ2FsbGJhY2soXG4gICAgKHNpemU/OiBQYXJ0aWFsPFN0aWNreVN0YXRlPikgPT4ge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBSZWR1Y2VyQWN0aW9ucy5zZXRTdGlja3lTdGF0ZSxcbiAgICAgICAgc2l6ZSxcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gdHVybmluZyBwYWdlcyB3b3VsZCBhbHNvIHRyaWdnZXIgYSByZXNpemVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW2Rpc3BhdGNoLCBnZXRUYWJsZVNpemUsIHBhZ2UsIHJvd3NdLFxuICApO1xuXG4gIGNvbnN0IHVzZVN0aWNreVdyYXAgPSAocmVuZGVyZXI6IFRhYmxlUmVuZGVyZXIpID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHVzZU1vdW50ZWRNZW1vKGdldFRhYmxlU2l6ZSwgW2dldFRhYmxlU2l6ZV0pIHx8IHN0aWNreTtcbiAgICAvLyBvbmx5IGNoYW5nZSBvZiBkYXRhIHNob3VsZCB0cmlnZ2VyIHJlLXJlbmRlclxuICAgIGNvbnN0IHRhYmxlID0gdXNlTWVtbyhyZW5kZXJlciwgW3BhZ2UsIHJvd3NdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgc2V0U3RpY2t5U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9LCBbd2lkdGgsIGhlaWdodF0pO1xuXG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICA8U3RpY2t5V3JhcCB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSBzdGlja3k9e3N0aWNreX0gc2V0U3RpY2t5U3RhdGU9e3NldFN0aWNreVN0YXRlfT5cbiAgICAgICAge3RhYmxlfVxuICAgICAgPC9TdGlja3lXcmFwPlxuICAgICk7XG4gIH07XG5cbiAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgIHNldFN0aWNreVN0YXRlLFxuICAgIHdyYXBTdGlja3lUYWJsZTogdXNlU3RpY2t5V3JhcCxcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVN0aWNreTxEIGV4dGVuZHMgb2JqZWN0Pihob29rczogSG9va3M8RD4pIHtcbiAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSk7XG4gIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaCgobmV3U3RhdGUsIGFjdGlvbl8sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSA9PiB7XG4gICAgY29uc3QgYWN0aW9uID0gYWN0aW9uXyBhcyBSZWR1Y2VyQWN0aW9uPFJlZHVjZXJBY3Rpb25zLCB7IHNpemU6IFN0aWNreVN0YXRlIH0+O1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gUmVkdWNlckFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgIHN0aWNreTogbmV3U3RhdGUuc3RpY2t5IHx8IHt9LFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBSZWR1Y2VyQWN0aW9ucy5zZXRTdGlja3lTdGF0ZSkge1xuICAgICAgY29uc3QgeyBzaXplIH0gPSBhY3Rpb247XG4gICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ubmV3U3RhdGUgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICBzdGlja3k6IHtcbiAgICAgICAgICAuLi5uZXdTdGF0ZS5zdGlja3ksXG4gICAgICAgICAgLi4uYWN0aW9uLnNpemUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH0pO1xufVxudXNlU3RpY2t5LnBsdWdpbk5hbWUgPSAndXNlU3RpY2t5JztcbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlUmVmLCBSZWFjdE5vZGUsIEhUTUxQcm9wcywgTXV0YWJsZVJlZk9iamVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7XG4gIHVzZVRhYmxlLFxuICB1c2VQYWdpbmF0aW9uLFxuICB1c2VTb3J0QnksXG4gIHVzZUdsb2JhbEZpbHRlcixcbiAgUGx1Z2luSG9vayxcbiAgVGFibGVPcHRpb25zLFxuICBGaWx0ZXJUeXBlLFxuICBJZFR5cGUsXG4gIFJvdyxcbn0gZnJvbSAncmVhY3QtdGFibGUnO1xuaW1wb3J0IG1hdGNoU29ydGVyIGZyb20gJ21hdGNoLXNvcnRlcic7XG5pbXBvcnQgR2xvYmFsRmlsdGVyLCB7IEdsb2JhbEZpbHRlclByb3BzIH0gZnJvbSAnLi9jb21wb25lbnRzL0dsb2JhbEZpbHRlcic7XG5pbXBvcnQgU2VsZWN0UGFnZVNpemUsIHsgU2VsZWN0UGFnZVNpemVQcm9wcywgU2l6ZU9wdGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy9TZWxlY3RQYWdlU2l6ZSc7XG5pbXBvcnQgU2ltcGxlUGFnaW5hdGlvbiBmcm9tICcuL2NvbXBvbmVudHMvUGFnaW5hdGlvbic7XG5pbXBvcnQgdXNlU3RpY2t5IGZyb20gJy4vaG9va3MvdXNlU3RpY2t5JztcblxuZXhwb3J0IGludGVyZmFjZSBEYXRhVGFibGVQcm9wczxEIGV4dGVuZHMgb2JqZWN0PiBleHRlbmRzIFRhYmxlT3B0aW9uczxEPiB7XG4gIHRhYmxlQ2xhc3NOYW1lPzogc3RyaW5nO1xuICBzZWFyY2hJbnB1dD86IGJvb2xlYW4gfCBHbG9iYWxGaWx0ZXJQcm9wczxEPlsnc2VhcmNoSW5wdXQnXTtcbiAgc2VsZWN0UGFnZVNpemU/OiBib29sZWFuIHwgU2VsZWN0UGFnZVNpemVQcm9wc1snc2VsZWN0UmVuZGVyZXInXTtcbiAgcGFnZVNpemVPcHRpb25zPzogU2l6ZU9wdGlvbltdOyAvLyBhdmFpbGFibGUgcGFnZSBzaXplIG9wdGlvbnNcbiAgbWF4UGFnZUl0ZW1Db3VudD86IG51bWJlcjtcbiAgaG9va3M/OiBQbHVnaW5Ib29rPEQ+W107IC8vIGFueSBhZGRpdGlvbmFsIGhvb2tzXG4gIHdpZHRoPzogc3RyaW5nIHwgbnVtYmVyO1xuICBoZWlnaHQ/OiBzdHJpbmcgfCBudW1iZXI7XG4gIHBhZ2VTaXplPzogbnVtYmVyO1xuICBub1Jlc3VsdHM/OiBzdHJpbmcgfCAoKGZpbHRlclN0cmluZzogc3RyaW5nKSA9PiBSZWFjdE5vZGUpO1xuICBzdGlja3k/OiBib29sZWFuO1xuICB3cmFwcGVyUmVmPzogTXV0YWJsZVJlZk9iamVjdDxIVE1MRGl2RWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVuZGVySFRNTENlbGxQcm9wcyBleHRlbmRzIEhUTUxQcm9wczxIVE1MVGFibGVDZWxsRWxlbWVudD4ge1xuICBjZWxsQ29udGVudDogUmVhY3ROb2RlO1xufVxuXG4vLyBCZSBzdXJlIHRvIHBhc3Mgb3VyIHVwZGF0ZU15RGF0YSBhbmQgdGhlIHNraXBSZXNldCBvcHRpb25cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhdGFUYWJsZTxEIGV4dGVuZHMgb2JqZWN0Pih7XG4gIHRhYmxlQ2xhc3NOYW1lLFxuICBjb2x1bW5zLFxuICBkYXRhLFxuICB3aWR0aDogaW5pdGlhbFdpZHRoID0gJzEwMCUnLFxuICBoZWlnaHQ6IGluaXRpYWxIZWlnaHQgPSAzMDAsXG4gIHBhZ2VTaXplOiBpbml0aWFsUGFnZVNpemUgPSAwLFxuICBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZV8gPSB7fSxcbiAgcGFnZVNpemVPcHRpb25zID0gWzEwLCAyNSwgNTAsIDEwMCwgMjAwXSxcbiAgbWF4UGFnZUl0ZW1Db3VudCA9IDksXG4gIHN0aWNreTogZG9TdGlja3ksXG4gIHNlYXJjaElucHV0ID0gdHJ1ZSxcbiAgc2VsZWN0UGFnZVNpemUsXG4gIG5vUmVzdWx0cyA9ICdObyBkYXRhIGZvdW5kJyxcbiAgaG9va3MsXG4gIHdyYXBwZXJSZWY6IHVzZXJXcmFwcGVyUmVmLFxuICAuLi5tb3JlVXNlVGFibGVPcHRpb25zXG59OiBEYXRhVGFibGVQcm9wczxEPikge1xuICBjb25zdCB0YWJsZUhvb2tzOiBQbHVnaW5Ib29rPEQ+W10gPSBbXG4gICAgdXNlR2xvYmFsRmlsdGVyLFxuICAgIHVzZVNvcnRCeSxcbiAgICB1c2VQYWdpbmF0aW9uLFxuICAgIGRvU3RpY2t5ID8gdXNlU3RpY2t5IDogW10sXG4gICAgaG9va3MgfHwgW10sXG4gIF0uZmxhdCgpO1xuICBjb25zdCBzb3J0QnlSZWYgPSB1c2VSZWYoW10pOyAvLyBjYWNoZSBpbml0aWFsIGBzb3J0YnlgIHNvIHNvcnRpbmcgZG9lc24ndCB0cmlnZ2VyIHBhZ2UgcmVzZXRcbiAgY29uc3QgcGFnZVNpemVSZWYgPSB1c2VSZWYoW2luaXRpYWxQYWdlU2l6ZSwgZGF0YS5sZW5ndGhdKTtcbiAgY29uc3QgaGFzUGFnaW5hdGlvbiA9IGluaXRpYWxQYWdlU2l6ZSA+IDAgJiYgZGF0YS5sZW5ndGggPiAwOyAvLyBwYWdlU2l6ZSA9PSAwIG1lYW5zIG5vIHBhZ2luYXRpb25cbiAgY29uc3QgaGFzR2xvYmFsQ29udHJvbCA9IGhhc1BhZ2luYXRpb24gfHwgISFzZWFyY2hJbnB1dDtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgIC4uLmluaXRpYWxTdGF0ZV8sXG4gICAgLy8gemVybyBsZW5ndGggbWVhbnMgYWxsIHBhZ2VzLCB0aGUgYHVzZVBhZ2luYXRpb25gIHBsdWdpbiBkb2VzIG5vdFxuICAgIC8vIHVuZGVyc3RhbmQgcGFnZVNpemUgPSAwXG4gICAgc29ydEJ5OiBzb3J0QnlSZWYuY3VycmVudCxcbiAgICBwYWdlU2l6ZTogaW5pdGlhbFBhZ2VTaXplID4gMCA/IGluaXRpYWxQYWdlU2l6ZSA6IGRhdGEubGVuZ3RoIHx8IDEwLFxuICB9O1xuXG4gIGNvbnN0IGRlZmF1bHRXcmFwcGVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgZ2xvYmFsQ29udHJvbFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IHBhZ2luYXRpb25SZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCB3cmFwcGVyUmVmID0gdXNlcldyYXBwZXJSZWYgfHwgZGVmYXVsdFdyYXBwZXJSZWY7XG5cbiAgY29uc3QgZGVmYXVsdEdldFRhYmxlU2l6ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAod3JhcHBlclJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBgaW5pdGlhbFdpZHRoYCBhbmQgYGluaXRpYWxIZWlnaHRgIGNvdWxkIGJlIGFsc28gcGFyYW1ldGVycyBsaWtlIGAxMDAlYFxuICAgICAgLy8gYE51bWJlcmAgcmVhdHVybnMgYE5hTmAgb24gdGhlbSwgdGhlbiB3ZSBmYWxsYmFjayB0byBjb21wdXRlZCBzaXplXG4gICAgICBjb25zdCB3aWR0aCA9IE51bWJlcihpbml0aWFsV2lkdGgpIHx8IHdyYXBwZXJSZWYuY3VycmVudC5jbGllbnRXaWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9XG4gICAgICAgIChOdW1iZXIoaW5pdGlhbEhlaWdodCkgfHwgd3JhcHBlclJlZi5jdXJyZW50LmNsaWVudEhlaWdodCkgLVxuICAgICAgICAoZ2xvYmFsQ29udHJvbFJlZi5jdXJyZW50Py5jbGllbnRIZWlnaHQgfHwgMCkgLVxuICAgICAgICAocGFnaW5hdGlvblJlZi5jdXJyZW50Py5jbGllbnRIZWlnaHQgfHwgMCk7XG4gICAgICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0IH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbaW5pdGlhbEhlaWdodCwgaW5pdGlhbFdpZHRoLCB3cmFwcGVyUmVmLCBoYXNQYWdpbmF0aW9uLCBoYXNHbG9iYWxDb250cm9sXSk7XG5cbiAgY29uc3QgZGVmYXVsdEdsb2JhbEZpbHRlcjogRmlsdGVyVHlwZTxEPiA9IHVzZUNhbGxiYWNrKFxuICAgIChyb3dzOiBSb3c8RD5bXSwgY29sdW1uSWRzOiBJZFR5cGU8RD5bXSwgZmlsdGVyVmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgLy8gYWxsb3cgc2VhcmNoaW5nIGJ5IFwiY29sMSBjb2wyXCJcbiAgICAgIGNvbnN0IGpvaW5lZFN0cmluZyA9IChyb3c6IFJvdzxEPikgPT4ge1xuICAgICAgICByZXR1cm4gY29sdW1uSWRzLm1hcCh4ID0+IHJvdy52YWx1ZXNbeF0pLmpvaW4oJyAnKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gbWF0Y2hTb3J0ZXIocm93cywgZmlsdGVyVmFsdWUsIHtcbiAgICAgICAga2V5czogWy4uLmNvbHVtbklkcywgam9pbmVkU3RyaW5nXSxcbiAgICAgICAgdGhyZXNob2xkOiBtYXRjaFNvcnRlci5yYW5raW5ncy5BQ1JPTllNLFxuICAgICAgfSkgYXMgdHlwZW9mIHJvd3M7XG4gICAgfSxcbiAgICBbXSxcbiAgKTtcblxuICBjb25zdCB7XG4gICAgZ2V0VGFibGVQcm9wcyxcbiAgICBnZXRUYWJsZUJvZHlQcm9wcyxcbiAgICBwcmVwYXJlUm93LFxuICAgIGhlYWRlckdyb3VwcyxcbiAgICBwYWdlLFxuICAgIHBhZ2VDb3VudCxcbiAgICBnb3RvUGFnZSxcbiAgICBwcmVHbG9iYWxGaWx0ZXJlZFJvd3MsXG4gICAgc2V0R2xvYmFsRmlsdGVyLFxuICAgIHNldFBhZ2VTaXplOiBzZXRQYWdlU2l6ZV8sXG4gICAgd3JhcFN0aWNreVRhYmxlLFxuICAgIHN0YXRlOiB7IHBhZ2VJbmRleCwgcGFnZVNpemUsIGdsb2JhbEZpbHRlcjogZmlsdGVyVmFsdWUsIHN0aWNreSA9IHt9IH0sXG4gIH0gPSB1c2VUYWJsZTxEPihcbiAgICB7XG4gICAgICBjb2x1bW5zLFxuICAgICAgZGF0YSxcbiAgICAgIGluaXRpYWxTdGF0ZSxcbiAgICAgIGdldFRhYmxlU2l6ZTogZGVmYXVsdEdldFRhYmxlU2l6ZSxcbiAgICAgIGdsb2JhbEZpbHRlcjogZGVmYXVsdEdsb2JhbEZpbHRlcixcbiAgICAgIC4uLm1vcmVVc2VUYWJsZU9wdGlvbnMsXG4gICAgfSxcbiAgICAuLi50YWJsZUhvb2tzLFxuICApO1xuICAvLyBtYWtlIHNldFBhZ2VTaXplIGFjY2VwdCAwXG4gIGNvbnN0IHNldFBhZ2VTaXplID0gKHNpemU6IG51bWJlcikgPT4ge1xuICAgIC8vIGtlZXAgdGhlIG9yaWdpbmFsIHNpemUgaWYgZGF0YSBpcyBlbXB0eVxuICAgIGlmIChzaXplIHx8IGRhdGEubGVuZ3RoICE9PSAwKSB7XG4gICAgICBzZXRQYWdlU2l6ZV8oc2l6ZSA9PT0gMCA/IGRhdGEubGVuZ3RoIDogc2l6ZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlbmRlclRhYmxlID0gKCkgPT4gKFxuICAgIDx0YWJsZSB7Li4uZ2V0VGFibGVQcm9wcyh7IGNsYXNzTmFtZTogdGFibGVDbGFzc05hbWUgfSl9PlxuICAgICAgPHRoZWFkPlxuICAgICAgICB7aGVhZGVyR3JvdXBzLm1hcChoZWFkZXJHcm91cCA9PiB7XG4gICAgICAgICAgY29uc3QgeyBrZXk6IGhlYWRlckdyb3VwS2V5LCAuLi5oZWFkZXJHcm91cFByb3BzIH0gPSBoZWFkZXJHcm91cC5nZXRIZWFkZXJHcm91cFByb3BzKCk7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDx0ciBrZXk9e2hlYWRlckdyb3VwS2V5IHx8IGhlYWRlckdyb3VwLmlkfSB7Li4uaGVhZGVyR3JvdXBQcm9wc30+XG4gICAgICAgICAgICAgIHtoZWFkZXJHcm91cC5oZWFkZXJzLm1hcChjb2x1bW4gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW4ucmVuZGVyKCdIZWFkZXInLCB7XG4gICAgICAgICAgICAgICAgICBrZXk6IGNvbHVtbi5pZCxcbiAgICAgICAgICAgICAgICAgIC4uLmNvbHVtbi5nZXRTb3J0QnlUb2dnbGVQcm9wcygpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSl9XG4gICAgICA8L3RoZWFkPlxuICAgICAgPHRib2R5IHsuLi5nZXRUYWJsZUJvZHlQcm9wcygpfT5cbiAgICAgICAge3BhZ2UgJiYgcGFnZS5sZW5ndGggPiAwID8gKFxuICAgICAgICAgIHBhZ2UubWFwKHJvdyA9PiB7XG4gICAgICAgICAgICBwcmVwYXJlUm93KHJvdyk7XG4gICAgICAgICAgICBjb25zdCB7IGtleTogcm93S2V5LCAuLi5yb3dQcm9wcyB9ID0gcm93LmdldFJvd1Byb3BzKCk7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8dHIga2V5PXtyb3dLZXkgfHwgcm93LmlkfSB7Li4ucm93UHJvcHN9PlxuICAgICAgICAgICAgICAgIHtyb3cuY2VsbHMubWFwKGNlbGwgPT4gY2VsbC5yZW5kZXIoJ0NlbGwnLCB7IGtleTogY2VsbC5jb2x1bW4uaWQgfSkpfVxuICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KVxuICAgICAgICApIDogKFxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgIDx0ZCBjbGFzc05hbWU9XCJkdC1uby1yZXN1bHRzXCIgY29sU3Bhbj17Y29sdW1ucy5sZW5ndGh9PlxuICAgICAgICAgICAgICB7dHlwZW9mIG5vUmVzdWx0cyA9PT0gJ2Z1bmN0aW9uJyA/IG5vUmVzdWx0cyhmaWx0ZXJWYWx1ZSBhcyBzdHJpbmcpIDogbm9SZXN1bHRzfVxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICA8L3RyPlxuICAgICAgICApfVxuICAgICAgPC90Ym9keT5cbiAgICA8L3RhYmxlPlxuICApO1xuXG4gIC8vIGZvcmNlIHVwYXRlIHRoZSBwYWdlU2l6ZSB3aGVuIGl0J3MgYmVlbiB1cGRhdGUgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZVxuICBpZiAoXG4gICAgcGFnZVNpemVSZWYuY3VycmVudFswXSAhPT0gaW5pdGlhbFBhZ2VTaXplIHx8XG4gICAgLy8gd2hlbiBpbml0aWFsUGFnZVNpemUgc3RheXMgYXMgemVybywgYnV0IHRvdGFsIG51bWJlciBvZiByZWNvcmRzIGNoYW5nZWQsXG4gICAgLy8gd2UnZCBhbHNvIG5lZWQgdG8gdXBkYXRlIHBhZ2Ugc2l6ZVxuICAgIChpbml0aWFsUGFnZVNpemUgPT09IDAgJiYgcGFnZVNpemVSZWYuY3VycmVudFsxXSAhPT0gZGF0YS5sZW5ndGgpXG4gICkge1xuICAgIHBhZ2VTaXplUmVmLmN1cnJlbnQgPSBbaW5pdGlhbFBhZ2VTaXplLCBkYXRhLmxlbmd0aF07XG4gICAgc2V0UGFnZVNpemUoaW5pdGlhbFBhZ2VTaXplKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiByZWY9e3dyYXBwZXJSZWZ9IHN0eWxlPXt7IHdpZHRoOiBpbml0aWFsV2lkdGgsIGhlaWdodDogaW5pdGlhbEhlaWdodCB9fT5cbiAgICAgIHtoYXNHbG9iYWxDb250cm9sID8gKFxuICAgICAgICA8ZGl2IHJlZj17Z2xvYmFsQ29udHJvbFJlZn0gY2xhc3NOYW1lPVwiZm9ybS1pbmxpbmUgZHQtY29udHJvbHNcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tNlwiPlxuICAgICAgICAgICAgICB7aGFzUGFnaW5hdGlvbiA/IChcbiAgICAgICAgICAgICAgICA8U2VsZWN0UGFnZVNpemVcbiAgICAgICAgICAgICAgICAgIHRvdGFsPXtkYXRhLmxlbmd0aH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQ9e3BhZ2VTaXplfVxuICAgICAgICAgICAgICAgICAgb3B0aW9ucz17cGFnZVNpemVPcHRpb25zfVxuICAgICAgICAgICAgICAgICAgc2VsZWN0UmVuZGVyZXI9e3R5cGVvZiBzZWxlY3RQYWdlU2l6ZSA9PT0gJ2Jvb2xlYW4nID8gdW5kZWZpbmVkIDogc2VsZWN0UGFnZVNpemV9XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c2V0UGFnZVNpemV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHtzZWFyY2hJbnB1dCA/IChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tNlwiPlxuICAgICAgICAgICAgICAgIDxHbG9iYWxGaWx0ZXI8RD5cbiAgICAgICAgICAgICAgICAgIHNlYXJjaElucHV0PXt0eXBlb2Ygc2VhcmNoSW5wdXQgPT09ICdib29sZWFuJyA/IHVuZGVmaW5lZCA6IHNlYXJjaElucHV0fVxuICAgICAgICAgICAgICAgICAgcHJlR2xvYmFsRmlsdGVyZWRSb3dzPXtwcmVHbG9iYWxGaWx0ZXJlZFJvd3N9XG4gICAgICAgICAgICAgICAgICBzZXRHbG9iYWxGaWx0ZXI9e3NldEdsb2JhbEZpbHRlcn1cbiAgICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlPXtmaWx0ZXJWYWx1ZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICkgOiBudWxsfVxuICAgICAge3dyYXBTdGlja3lUYWJsZSA/IHdyYXBTdGlja3lUYWJsZShyZW5kZXJUYWJsZSkgOiByZW5kZXJUYWJsZSgpfVxuICAgICAge2hhc1BhZ2luYXRpb24gPyAoXG4gICAgICAgIDxTaW1wbGVQYWdpbmF0aW9uXG4gICAgICAgICAgcmVmPXtwYWdpbmF0aW9uUmVmfVxuICAgICAgICAgIHN0eWxlPXtzdGlja3kuaGVpZ2h0ID8gdW5kZWZpbmVkIDogeyB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9fVxuICAgICAgICAgIG1heFBhZ2VJdGVtQ291bnQ9e21heFBhZ2VJdGVtQ291bnR9XG4gICAgICAgICAgcGFnZUNvdW50PXtwYWdlQ291bnR9XG4gICAgICAgICAgY3VycmVudFBhZ2U9e3BhZ2VJbmRleH1cbiAgICAgICAgICBvblBhZ2VDaGFuZ2U9e2dvdG9QYWdlfVxuICAgICAgICAvPlxuICAgICAgKSA6IG51bGx9XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlZC5kaXZgXG4gIHRhYmxlIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBtaW4td2lkdGg6IGF1dG87XG4gICAgbWF4LXdpZHRoOiBub25lO1xuICAgIG1hcmdpbjogMDtcbiAgfVxuXG4gIHRoLFxuICB0ZCB7XG4gICAgbWluLXdpZHRoOiA0LjNlbTtcbiAgfVxuXG4gIHRoZWFkID4gdHIgPiB0aCB7XG4gICAgcGFkZGluZy1yaWdodDogMS40ZW07XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gIH1cbiAgdGggc3ZnIHtcbiAgICBjb2xvcjogI2NjYztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm90dG9tOiAwLjZlbTtcbiAgICByaWdodDogMC4yZW07XG4gIH1cbiAgdGguaXMtc29ydGVkIHN2ZyB7XG4gICAgY29sb3I6ICNhOGE4YTg7XG4gIH1cbiAgLnRhYmxlID4gdGJvZHkgPiB0cjpmaXJzdC1vZi10eXBlID4gdGQsXG4gIC50YWJsZSA+IHRib2R5ID4gdHI6Zmlyc3Qtb2YtdHlwZSA+IHRoIHtcbiAgICBib3JkZXItdG9wOiAwO1xuICB9XG5cbiAgLmR0LWNvbnRyb2xzIHtcbiAgICBwYWRkaW5nLWJvdHRvbTogMC42NWVtO1xuICB9XG4gIC5kdC1tZXRyaWMge1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICB9XG4gIHRkLmR0LWlzLWZpbHRlciB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICB9XG4gIHRkLmR0LWlzLWZpbHRlcjpob3ZlciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogbGluZW47XG4gIH1cbiAgdGQuZHQtaXMtYWN0aXZlLWZpbHRlcixcbiAgdGQuZHQtaXMtYWN0aXZlLWZpbHRlcjpob3ZlciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogbGlnaHRjeWFuO1xuICB9XG5cbiAgLmR0LWdsb2JhbC1maWx0ZXIge1xuICAgIGZsb2F0OiByaWdodDtcbiAgfVxuXG4gIC5kdC1wYWdpbmF0aW9uIHtcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICAvKiB1c2UgcGFkZGluZyBpbnN0ZWFkIG9mIG1hcmdpbiBzbyBjbGllbnRIZWlnaHQgY2FuIGNhcHR1cmUgaXQgKi9cbiAgICBwYWRkaW5nLXRvcDogMC41ZW07XG4gIH1cbiAgLmR0LXBhZ2luYXRpb24gLnBhZ2luYXRpb24ge1xuICAgIG1hcmdpbjogMDtcbiAgfVxuXG4gIC5wYWdpbmF0aW9uID4gbGkgPiBzcGFuLmR0LXBhZ2luYXRpb24tZWxsaXBzaXM6Zm9jdXMsXG4gIC5wYWdpbmF0aW9uID4gbGkgPiBzcGFuLmR0LXBhZ2luYXRpb24tZWxsaXBzaXM6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gIH1cblxuICAuZHQtbm8tcmVzdWx0cyB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIHBhZGRpbmc6IDFlbSAwLjZlbTtcbiAgfVxuYDtcbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEZpbHRlclhTUywgZ2V0RGVmYXVsdFdoaXRlTGlzdCB9IGZyb20gJ3hzcyc7XG5pbXBvcnQgeyBEYXRhUmVjb3JkVmFsdWUgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgeyBEYXRhQ29sdW1uTWV0YSB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgeHNzID0gbmV3IEZpbHRlclhTUyh7XG4gIHdoaXRlTGlzdDoge1xuICAgIC4uLmdldERlZmF1bHRXaGl0ZUxpc3QoKSxcbiAgICBzcGFuOiBbJ3N0eWxlJywgJ2NsYXNzJywgJ3RpdGxlJ10sXG4gICAgZGl2OiBbJ3N0eWxlJywgJ2NsYXNzJ10sXG4gICAgYTogWydzdHlsZScsICdjbGFzcycsICdocmVmJywgJ3RpdGxlJywgJ3RhcmdldCddLFxuICAgIGltZzogWydzdHlsZScsICdjbGFzcycsICdzcmMnLCAnYWx0JywgJ3RpdGxlJywgJ3dpZHRoJywgJ2hlaWdodCddLFxuICB9LFxuICBzdHJpcElnbm9yZVRhZzogdHJ1ZSxcbiAgY3NzOiBmYWxzZSxcbn0pO1xuXG5mdW5jdGlvbiBpc1Byb2JhYmx5SFRNTCh0ZXh0OiBzdHJpbmcpIHtcbiAgcmV0dXJuIC88W14+XSs+Ly50ZXN0KHRleHQpO1xufVxuLyoqXG4gKiBGb3JtYXQgdGV4dCBmb3IgY2VsbCB2YWx1ZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXRWYWx1ZShcbiAgeyBmb3JtYXR0ZXIgfTogRGF0YUNvbHVtbk1ldGEsXG4gIHZhbHVlOiBEYXRhUmVjb3JkVmFsdWUsXG4pOiBbYm9vbGVhbiwgc3RyaW5nXSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbZmFsc2UsICdOL0EnXTtcbiAgfVxuICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgLy8gaW4gY2FzZSBwZXJjZW50IG1ldHJpYyBjYW4gc3BlY2lmeSBwZXJjZW50IGZvcm1hdCBpbiB0aGUgZnV0dXJlXG4gICAgcmV0dXJuIFtmYWxzZSwgZm9ybWF0dGVyKHZhbHVlIGFzIG51bWJlcildO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGlzUHJvYmFibHlIVE1MKHZhbHVlKSA/IFt0cnVlLCB4c3MucHJvY2Vzcyh2YWx1ZSldIDogW2ZhbHNlLCB2YWx1ZV07XG4gIH1cbiAgcmV0dXJuIFtmYWxzZSwgdmFsdWUudG9TdHJpbmcoKV07XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZU1lbW8sIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ29sdW1uSW5zdGFuY2UsIERlZmF1bHRTb3J0VHlwZXMsIENvbHVtbldpdGhMb29zZUFjY2Vzc29yIH0gZnJvbSAncmVhY3QtdGFibGUnO1xuaW1wb3J0IHsgZXh0ZW50IGFzIGQzRXh0ZW50LCBtYXggYXMgZDNNYXggfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyBGYVNvcnQsIEZhU29ydFVwIGFzIEZhU29ydEFzYywgRmFTb3J0RG93biBhcyBGYVNvcnREZXNjIH0gZnJvbSAncmVhY3QtaWNvbnMvZmEnO1xuaW1wb3J0IHsgdCwgdG4sIERhdGFSZWNvcmRWYWx1ZSwgRGF0YVJlY29yZCB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcblxuaW1wb3J0IHsgVGFibGVDaGFydFRyYW5zZm9ybWVkUHJvcHMsIERhdGFUeXBlLCBEYXRhQ29sdW1uTWV0YSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IERhdGFUYWJsZSwge1xuICBEYXRhVGFibGVQcm9wcyxcbiAgU2VhcmNoSW5wdXRQcm9wcyxcbiAgU2VsZWN0UGFnZVNpemVSZW5kZXJlclByb3BzLFxuICBTaXplT3B0aW9uLFxufSBmcm9tICcuL0RhdGFUYWJsZSc7XG5pbXBvcnQgU3R5bGVzIGZyb20gJy4vU3R5bGVzJztcbmltcG9ydCBmb3JtYXRWYWx1ZSBmcm9tICcuL3V0aWxzL2Zvcm1hdFZhbHVlJztcbmltcG9ydCB7IFBBR0VfU0laRV9PUFRJT05TIH0gZnJvbSAnLi9jb250cm9sUGFuZWwnO1xuXG50eXBlIFZhbHVlUmFuZ2UgPSBbbnVtYmVyLCBudW1iZXJdO1xuXG4vKipcbiAqIFJldHVybiBzb3J0VHlwZSBiYXNlZCBvbiBkYXRhIHR5cGVcbiAqL1xuZnVuY3Rpb24gZ2V0U29ydFR5cGVCeURhdGFUeXBlKGRhdGFUeXBlOiBEYXRhVHlwZSk6IERlZmF1bHRTb3J0VHlwZXMge1xuICBpZiAoZGF0YVR5cGUgPT09IERhdGFUeXBlLkRhdGVUaW1lKSB7XG4gICAgcmV0dXJuICdkYXRldGltZSc7XG4gIH1cbiAgaWYgKGRhdGFUeXBlID09PSBEYXRhVHlwZS5TdHJpbmcpIHtcbiAgICByZXR1cm4gJ2FscGhhbnVtZXJpYyc7XG4gIH1cbiAgcmV0dXJuICdiYXNpYyc7XG59XG5cbi8qKlxuICogQ2VsbCBiYWNrZ3JvdW5kIHRvIHJlbmRlciBjb2x1bW5zIGFzIGhvcml6b250YWwgYmFyIGNoYXJ0XG4gKi9cbmZ1bmN0aW9uIGNlbGxCYXIoe1xuICB2YWx1ZSxcbiAgdmFsdWVSYW5nZSxcbiAgY29sb3JQb3NpdGl2ZU5lZ2F0aXZlID0gZmFsc2UsXG4gIGFsaWduUG9zaXRpdmVOZWdhdGl2ZSxcbn06IHtcbiAgdmFsdWU6IG51bWJlcjtcbiAgdmFsdWVSYW5nZTogVmFsdWVSYW5nZTtcbiAgY29sb3JQb3NpdGl2ZU5lZ2F0aXZlOiBib29sZWFuO1xuICBhbGlnblBvc2l0aXZlTmVnYXRpdmU6IGJvb2xlYW47XG59KSB7XG4gIGNvbnN0IFttaW5WYWx1ZSwgbWF4VmFsdWVdID0gdmFsdWVSYW5nZTtcbiAgY29uc3QgciA9IGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSAmJiB2YWx1ZSA8IDAgPyAxNTAgOiAwO1xuICBpZiAoYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlKSB7XG4gICAgY29uc3QgcGVyYyA9IE1hdGguYWJzKE1hdGgucm91bmQoKHZhbHVlIC8gbWF4VmFsdWUpICogMTAwKSk7XG4gICAgLy8gVGhlIDAuMDEgdG8gMC4wMDEgaXMgYSB3b3JrYXJvdW5kIGZvciB3aGF0IGFwcGVhcnMgdG8gYmUgYVxuICAgIC8vIENTUyByZW5kZXJpbmcgYnVnIG9uIGZsYXQsIHRyYW5zcGFyZW50IGNvbG9yc1xuICAgIHJldHVybiAoXG4gICAgICBgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCByZ2JhKCR7cn0sMCwwLDAuMiksIHJnYmEoJHtyfSwwLDAsMC4yKSAke3BlcmN9JSwgYCArXG4gICAgICBgcmdiYSgwLDAsMCwwLjAxKSAke3BlcmN9JSwgcmdiYSgwLDAsMCwwLjAwMSkgMTAwJSlgXG4gICAgKTtcbiAgfVxuICBjb25zdCBwb3NFeHRlbnQgPSBNYXRoLmFicyhNYXRoLm1heChtYXhWYWx1ZSwgMCkpO1xuICBjb25zdCBuZWdFeHRlbnQgPSBNYXRoLmFicyhNYXRoLm1pbihtaW5WYWx1ZSwgMCkpO1xuICBjb25zdCB0b3QgPSBwb3NFeHRlbnQgKyBuZWdFeHRlbnQ7XG4gIGNvbnN0IHBlcmMxID0gTWF0aC5yb3VuZCgoTWF0aC5taW4obmVnRXh0ZW50ICsgdmFsdWUsIG5lZ0V4dGVudCkgLyB0b3QpICogMTAwKTtcbiAgY29uc3QgcGVyYzIgPSBNYXRoLnJvdW5kKChNYXRoLmFicyh2YWx1ZSkgLyB0b3QpICogMTAwKTtcbiAgLy8gVGhlIDAuMDEgdG8gMC4wMDEgaXMgYSB3b3JrYXJvdW5kIGZvciB3aGF0IGFwcGVhcnMgdG8gYmUgYVxuICAvLyBDU1MgcmVuZGVyaW5nIGJ1ZyBvbiBmbGF0LCB0cmFuc3BhcmVudCBjb2xvcnNcbiAgcmV0dXJuIChcbiAgICBgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCByZ2JhKDAsMCwwLDAuMDEpLCByZ2JhKDAsMCwwLDAuMDAxKSAke3BlcmMxfSUsIGAgK1xuICAgIGByZ2JhKCR7cn0sMCwwLDAuMikgJHtwZXJjMX0lLCByZ2JhKCR7cn0sMCwwLDAuMikgJHtwZXJjMSArIHBlcmMyfSUsIGAgK1xuICAgIGByZ2JhKDAsMCwwLDAuMDEpICR7cGVyYzEgKyBwZXJjMn0lLCByZ2JhKDAsMCwwLDAuMDAxKSAxMDAlKWBcbiAgKTtcbn1cblxuZnVuY3Rpb24gU29ydEljb248RCBleHRlbmRzIG9iamVjdD4oeyBjb2x1bW4gfTogeyBjb2x1bW46IENvbHVtbkluc3RhbmNlPEQ+IH0pIHtcbiAgY29uc3QgeyBpc1NvcnRlZCwgaXNTb3J0ZWREZXNjIH0gPSBjb2x1bW47XG4gIGxldCBzb3J0SWNvbiA9IDxGYVNvcnQgLz47XG4gIGlmIChpc1NvcnRlZCkge1xuICAgIHNvcnRJY29uID0gaXNTb3J0ZWREZXNjID8gPEZhU29ydERlc2MgLz4gOiA8RmFTb3J0QXNjIC8+O1xuICB9XG4gIHJldHVybiBzb3J0SWNvbjtcbn1cblxuZnVuY3Rpb24gU2VhcmNoSW5wdXQoeyBjb3VudCwgdmFsdWUsIG9uQ2hhbmdlIH06IFNlYXJjaElucHV0UHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8c3BhbiBjbGFzc05hbWU9XCJkdC1nbG9iYWwtZmlsdGVyXCI+XG4gICAgICB7dCgnU2VhcmNoJyl9eycgJ31cbiAgICAgIDxpbnB1dFxuICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2wgaW5wdXQtc21cIlxuICAgICAgICBwbGFjZWhvbGRlcj17dG4oJ3NlYXJjaC5udW1fcmVjb3JkcycsIGNvdW50KX1cbiAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAvPlxuICAgIDwvc3Bhbj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gU2VsZWN0UGFnZVNpemUoeyBvcHRpb25zLCBjdXJyZW50LCBvbkNoYW5nZSB9OiBTZWxlY3RQYWdlU2l6ZVJlbmRlcmVyUHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8c3BhbiBjbGFzc05hbWU9XCJkdC1zZWxlY3QtcGFnZS1zaXplIGZvcm0taW5saW5lXCI+XG4gICAgICB7dCgncGFnZV9zaXplLnNob3cnKX17JyAnfVxuICAgICAgPHNlbGVjdFxuICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2wgaW5wdXQtc21cIlxuICAgICAgICB2YWx1ZT17Y3VycmVudH1cbiAgICAgICAgb25CbHVyPXsoKSA9PiB7fX1cbiAgICAgICAgb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgIG9uQ2hhbmdlKE51bWJlcigoZS50YXJnZXQgYXMgSFRNTFNlbGVjdEVsZW1lbnQpLnZhbHVlKSk7XG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtvcHRpb25zLm1hcChvcHRpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IFtzaXplLCB0ZXh0XSA9IEFycmF5LmlzQXJyYXkob3B0aW9uKSA/IG9wdGlvbiA6IFtvcHRpb24sIG9wdGlvbl07XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PXtzaXplfSB2YWx1ZT17c2l6ZX0+XG4gICAgICAgICAgICAgIHt0ZXh0fVxuICAgICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSl9XG4gICAgICA8L3NlbGVjdD57JyAnfVxuICAgICAge3QoJ3BhZ2Vfc2l6ZS5lbnRyaWVzJyl9XG4gICAgPC9zcGFuPlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUYWJsZUNoYXJ0PEQgZXh0ZW5kcyBEYXRhUmVjb3JkID0gRGF0YVJlY29yZD4oXG4gIHByb3BzOiBUYWJsZUNoYXJ0VHJhbnNmb3JtZWRQcm9wczxEPiAmIHtcbiAgICBzdGlja3k/OiBEYXRhVGFibGVQcm9wczxEPlsnc3RpY2t5J107XG4gIH0sXG4pIHtcbiAgY29uc3Qge1xuICAgIGhlaWdodCxcbiAgICB3aWR0aCxcbiAgICBkYXRhLFxuICAgIGNvbHVtbnM6IGNvbHVtbnNNZXRhLFxuICAgIGFsaWduUG9zaXRpdmVOZWdhdGl2ZSA9IGZhbHNlLFxuICAgIGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSA9IGZhbHNlLFxuICAgIGluY2x1ZGVTZWFyY2ggPSBmYWxzZSxcbiAgICBwYWdlU2l6ZSA9IDAsXG4gICAgc2hvd0NlbGxCYXJzID0gdHJ1ZSxcbiAgICBlbWl0RmlsdGVyID0gZmFsc2UsXG4gICAgc29ydERlc2MgPSBmYWxzZSxcbiAgICBvbkNoYW5nZUZpbHRlcixcbiAgICBmaWx0ZXJzOiBpbml0aWFsRmlsdGVycyxcbiAgICBzdGlja3kgPSB0cnVlLCAvLyB3aGV0aGVyIHRvIHVzZSBzdGlja3kgaGVhZGVyXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCBbZmlsdGVycywgc2V0RmlsdGVyc10gPSB1c2VTdGF0ZShpbml0aWFsRmlsdGVycyk7XG5cbiAgLy8gb25seSB0YWtlIHJlbGV2YW50IHBhZ2Ugc2l6ZSBvcHRpb25zXG4gIGNvbnN0IHBhZ2VTaXplT3B0aW9ucyA9IHVzZU1lbW8oXG4gICAgKCkgPT4gUEFHRV9TSVpFX09QVElPTlMuZmlsdGVyKChbbiwgX10pID0+IG4gPD0gMiAqIGRhdGEubGVuZ3RoKSBhcyBTaXplT3B0aW9uW10sXG4gICAgW2RhdGEubGVuZ3RoXSxcbiAgKTtcblxuICBjb25zdCBnZXRWYWx1ZVJhbmdlID0gdXNlQ2FsbGJhY2soXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVSYW5nZShrZXk6IHN0cmluZykge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhPy5bMF0/LltrZXldID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBudW1zID0gZGF0YS5tYXAocm93ID0+IHJvd1trZXldKSBhcyBudW1iZXJbXTtcbiAgICAgICAgcmV0dXJuIChhbGlnblBvc2l0aXZlTmVnYXRpdmVcbiAgICAgICAgICA/IFswLCBkM01heChudW1zLm1hcChNYXRoLmFicykpXVxuICAgICAgICAgIDogZDNFeHRlbnQobnVtcykpIGFzIFZhbHVlUmFuZ2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIFthbGlnblBvc2l0aXZlTmVnYXRpdmUsIGRhdGFdLFxuICApO1xuXG4gIGNvbnN0IGlzQWN0aXZlRmlsdGVyVmFsdWUgPSB1c2VDYWxsYmFjayhcbiAgICBmdW5jdGlvbiBpc0FjdGl2ZUZpbHRlclZhbHVlKGtleTogc3RyaW5nLCB2YWw6IERhdGFSZWNvcmRWYWx1ZSkge1xuICAgICAgcmV0dXJuICEhZmlsdGVycyAmJiBmaWx0ZXJzW2tleV0/LmluY2x1ZGVzKHZhbCk7XG4gICAgfSxcbiAgICBbZmlsdGVyc10sXG4gICk7XG5cbiAgY29uc3QgdG9nZ2xlRmlsdGVyID0gdXNlQ2FsbGJhY2soXG4gICAgZnVuY3Rpb24gdG9nZ2xlRmlsdGVyKGtleTogc3RyaW5nLCB2YWw6IERhdGFSZWNvcmRWYWx1ZSkge1xuICAgICAgY29uc3QgdXBkYXRlZEZpbHRlcnMgPSB7IC4uLihmaWx0ZXJzIHx8IHt9KSB9O1xuICAgICAgaWYgKGZpbHRlcnMgJiYgaXNBY3RpdmVGaWx0ZXJWYWx1ZShrZXksIHZhbCkpIHtcbiAgICAgICAgdXBkYXRlZEZpbHRlcnNba2V5XSA9IGZpbHRlcnNba2V5XS5maWx0ZXIoKHg6IERhdGFSZWNvcmRWYWx1ZSkgPT4geCAhPT0gdmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRGaWx0ZXJzW2tleV0gPSBbLi4uKGZpbHRlcnM/LltrZXldIHx8IFtdKSwgdmFsXTtcbiAgICAgIH1cbiAgICAgIHNldEZpbHRlcnModXBkYXRlZEZpbHRlcnMpO1xuICAgICAgaWYgKG9uQ2hhbmdlRmlsdGVyKSB7XG4gICAgICAgIG9uQ2hhbmdlRmlsdGVyKHVwZGF0ZWRGaWx0ZXJzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtmaWx0ZXJzLCBpc0FjdGl2ZUZpbHRlclZhbHVlLCBvbkNoYW5nZUZpbHRlcl0sXG4gICk7XG5cbiAgY29uc3QgZ2V0Q29sdW1uQ29uZmlncyA9IHVzZUNhbGxiYWNrKFxuICAgIChjb2x1bW46IERhdGFDb2x1bW5NZXRhLCBpOiBudW1iZXIpOiBDb2x1bW5XaXRoTG9vc2VBY2Nlc3NvcjxEPiA9PiB7XG4gICAgICBjb25zdCB7IGtleSwgbGFiZWwsIGRhdGFUeXBlIH0gPSBjb2x1bW47XG4gICAgICBsZXQgY2xhc3NOYW1lID0gJyc7XG4gICAgICBpZiAoZGF0YVR5cGUgPT09IERhdGFUeXBlLk51bWJlcikge1xuICAgICAgICBjbGFzc05hbWUgKz0gJyBkdC1tZXRyaWMnO1xuICAgICAgfSBlbHNlIGlmIChlbWl0RmlsdGVyKSB7XG4gICAgICAgIGNsYXNzTmFtZSArPSAnIGR0LWlzLWZpbHRlcic7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZVJhbmdlID0gc2hvd0NlbGxCYXJzICYmIGdldFZhbHVlUmFuZ2Uoa2V5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBTdHJpbmcoaSksIC8vIHRvIGFsbG93IGR1cGxpY2F0ZSBjb2x1bW4ga2V5c1xuICAgICAgICAvLyBtdXN0IHVzZSBjdXN0b20gYWNjZXNzb3IgdG8gYWxsb3cgYC5gIGluIGNvbHVtbiBuYW1lc1xuICAgICAgICAvLyB0eXBpbmcgaXMgaW5jb3JyZWN0IGluIGN1cnJlbnQgdmVyc2lvbiBvZiBgQHR5cGVzL3JlYWN0LXRhYmxlYFxuICAgICAgICAvLyBzbyB3ZSBhc2sgVFMgbm90IHRvIGNoZWNrLlxuICAgICAgICBhY2Nlc3NvcjogKChkYXR1bTogRCkgPT4gZGF0dW1ba2V5XSkgYXMgbmV2ZXIsXG4gICAgICAgIENlbGw6ICh7IGNvbHVtbjogY29sLCB2YWx1ZSB9OiB7IGNvbHVtbjogQ29sdW1uSW5zdGFuY2U8RD47IHZhbHVlOiBEYXRhUmVjb3JkVmFsdWUgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IFtpc0h0bWwsIHRleHRdID0gZm9ybWF0VmFsdWUoY29sdW1uLCB2YWx1ZSk7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB2YWx1ZVJhbmdlXG4gICAgICAgICAgICAgID8gY2VsbEJhcih7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgYXMgbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgdmFsdWVSYW5nZSxcbiAgICAgICAgICAgICAgICAgIGFsaWduUG9zaXRpdmVOZWdhdGl2ZSxcbiAgICAgICAgICAgICAgICAgIGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGh0bWwgPSBpc0h0bWwgPyB7IF9faHRtbDogdGV4dCB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IGNlbGxQcm9wcyA9IHtcbiAgICAgICAgICAgIC8vIHNob3cgcmF3IG51bWJlciBpbiB0aXRsZSBpbiBjYXNlIG9mIG51bWVyaWMgdmFsdWVzXG4gICAgICAgICAgICB0aXRsZTogdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IFN0cmluZyh2YWx1ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvbkNsaWNrOiBlbWl0RmlsdGVyICYmICF2YWx1ZVJhbmdlID8gKCkgPT4gdG9nZ2xlRmlsdGVyKGtleSwgdmFsdWUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBgJHtjbGFzc05hbWV9JHtcbiAgICAgICAgICAgICAgaXNBY3RpdmVGaWx0ZXJWYWx1ZShrZXksIHZhbHVlKSA/ICcgZHQtaXMtYWN0aXZlLWZpbHRlcicgOiAnJ1xuICAgICAgICAgICAgfWAsXG4gICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChodG1sKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZGFuZ2VyXG4gICAgICAgICAgICByZXR1cm4gPHRkIHsuLi5jZWxsUHJvcHN9IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXtodG1sfSAvPjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgY2VsbFByb3BzIHJlbmRlcmVzIHRleHRDb250ZW50IGFscmVhZHksIHRoZW4gd2UgZG9uJ3QgaGF2ZSB0b1xuICAgICAgICAgIC8vIHJlbmRlciBgQ2VsbGAuIFRoaXMgc2F2ZXMgc29tZSB0aW1lIGZvciBsYXJnZSB0YWJsZXMuXG4gICAgICAgICAgcmV0dXJuIDx0ZCB7Li4uY2VsbFByb3BzfT57dGV4dH08L3RkPjtcbiAgICAgICAgfSxcbiAgICAgICAgSGVhZGVyOiAoeyBjb2x1bW46IGNvbCwgdGl0bGUsIG9uQ2xpY2ssIHN0eWxlIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHRoXG4gICAgICAgICAgICAgIHRpdGxlPXt0aXRsZX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjb2wuaXNTb3J0ZWQgPyBgJHtjbGFzc05hbWUgfHwgJyd9IGlzLXNvcnRlZGAgOiBjbGFzc05hbWV9XG4gICAgICAgICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgICAgICAgICAgb25DbGljaz17b25DbGlja31cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge2xhYmVsfVxuICAgICAgICAgICAgICA8U29ydEljb24gY29sdW1uPXtjb2x9IC8+XG4gICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHNvcnREZXNjRmlyc3Q6IHNvcnREZXNjLFxuICAgICAgICBzb3J0VHlwZTogZ2V0U29ydFR5cGVCeURhdGFUeXBlKGRhdGFUeXBlKSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBbXG4gICAgICBhbGlnblBvc2l0aXZlTmVnYXRpdmUsXG4gICAgICBjb2xvclBvc2l0aXZlTmVnYXRpdmUsXG4gICAgICBlbWl0RmlsdGVyLFxuICAgICAgZ2V0VmFsdWVSYW5nZSxcbiAgICAgIGlzQWN0aXZlRmlsdGVyVmFsdWUsXG4gICAgICBzaG93Q2VsbEJhcnMsXG4gICAgICBzb3J0RGVzYyxcbiAgICAgIHRvZ2dsZUZpbHRlcixcbiAgICBdLFxuICApO1xuXG4gIGNvbnN0IGNvbHVtbnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gY29sdW1uc01ldGEubWFwKGdldENvbHVtbkNvbmZpZ3MpO1xuICB9LCBbY29sdW1uc01ldGEsIGdldENvbHVtbkNvbmZpZ3NdKTtcblxuICByZXR1cm4gKFxuICAgIDxTdHlsZXM+XG4gICAgICA8RGF0YVRhYmxlPEQ+XG4gICAgICAgIGNvbHVtbnM9e2NvbHVtbnN9XG4gICAgICAgIGRhdGE9e2RhdGF9XG4gICAgICAgIHRhYmxlQ2xhc3NOYW1lPVwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWRcIlxuICAgICAgICBwYWdlU2l6ZT17cGFnZVNpemV9XG4gICAgICAgIHBhZ2VTaXplT3B0aW9ucz17cGFnZVNpemVPcHRpb25zfVxuICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgICAvLyA5IHBhZ2UgaXRlbXMgaW4gPiAzNDBweCB3b3JrcyB3ZWxsIGV2ZW4gZm9yIDEwMCsgcGFnZXNcbiAgICAgICAgbWF4UGFnZUl0ZW1Db3VudD17d2lkdGggPiAzNDAgPyA5IDogN31cbiAgICAgICAgbm9SZXN1bHRzPXsoZmlsdGVyOiBzdHJpbmcpID0+IHQoZmlsdGVyID8gJ05vIG1hdGNoaW5nIHJlY29yZHMgZm91bmQnIDogJ05vIHJlY29yZHMgZm91bmQnKX1cbiAgICAgICAgc2VhcmNoSW5wdXQ9e2luY2x1ZGVTZWFyY2ggJiYgU2VhcmNoSW5wdXR9XG4gICAgICAgIHNlbGVjdFBhZ2VTaXplPXtwYWdlU2l6ZSAhPT0gbnVsbCAmJiBTZWxlY3RQYWdlU2l6ZX1cbiAgICAgICAgLy8gbm90IGluIHVzZSBpbiBTdXBlcnNldCwgYnV0IG5lZWRlZCBmb3IgdW5pdCB0ZXN0c1xuICAgICAgICBzdGlja3k9e3N0aWNreX1cbiAgICAgIC8+XG4gICAgPC9TdHlsZXM+XG4gICk7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQ2xEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUVBO0FBaUJBO0FBQ0E7O0FBRUE7QUFDQTtBQVFBO0FBRUE7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUMvRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFVQTtBQUNBOztBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUVBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekZBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBV0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFPQTtBQU9BOzs7QUNqR0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7O0FBRUE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBcUJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFrQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTs7QUFFQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFPQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBU0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDcldBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcUJBO0FBQ0E7QUFBQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFnQkE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFHQTtBQUlBO0FBR0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFTQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFXQTtBQUVBO0FBV0E7QUFDQTtBQVlBOzs7Ozs7QUMzUEE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1RUE7Ozs7OztBQ3pFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUlBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN2REE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBUUE7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBS0E7QUFpQkE7QUFFQTtBQUNBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBUUE7QUFDQTtBQUlBO0FBQ0E7QUFJQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2486\n')}}]);