(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{2499:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(2);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/translation/TranslatorSingleton.ts + 1 modules\nvar TranslatorSingleton = __webpack_require__(15);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@vx/zoom/esm/Zoom.js + 6 modules\nvar Zoom = __webpack_require__(2490);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-choropleth-map/node_modules/@vx/event/esm/localPoint.js + 4 modules\nvar localPoint = __webpack_require__(2495);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@vx/clip-path/esm/clip-paths/RectClipPath.js + 1 modules\nvar RectClipPath = __webpack_require__(2517);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-choropleth-map/node_modules/@vx/tooltip/esm/enhancers/withTooltip.js + 1 modules\nvar withTooltip = __webpack_require__(2518);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/lodash/lodash.js\nvar lodash = __webpack_require__(104);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-geo/src/path/index.js + 5 modules\nvar src_path = __webpack_require__(2492);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-choropleth-map/src/chart/loadMap.ts + 2 modules\nvar loadMap = __webpack_require__(1034);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/style/index.ts\nvar style = __webpack_require__(536);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-choropleth-map/src/chart/components.ts\n\nconst PADDING = style["d" /* supersetTheme */].gridUnit * 4;\nconst RelativeDiv = style["c" /* styled */].div `\n  position: relative;\n`;\nconst ZoomControls = style["c" /* styled */].div `\n  position: absolute;\n  top: ${PADDING}px;\n  right: ${PADDING}px;\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n`;\nconst MiniMapControl = style["c" /* styled */].div `\n  position: absolute;\n  bottom: ${PADDING + 6}px;\n  right: ${PADDING + 1}px;\n`;\nconst IconButton = style["c" /* styled */].button `\n  width: ${({ theme }) => theme.gridUnit * 6}px;\n  font-size: ${({ theme }) => theme.typography.sizes.xl}px;\n  text-align: center;\n  color: #222;\n  margin: 0px;\n  margin-bottom: 2px;\n  background: #f5f8fb;\n  padding: 0px ${({ theme }) => theme.gridUnit}px;\n  border-radius: ${({ theme }) => theme.borderRadius}px;\n  border: none;\n`;\nconst TextButton = style["c" /* styled */].button `\n  text-align: center;\n  font-size: ${({ theme }) => theme.typography.sizes.s}px;\n  color: #222;\n  margin: 0px;\n  background: #f5f8fb;\n  padding: ${({ theme }) => theme.gridUnit / 2}px ${({ theme }) => theme.gridUnit * 1.5}px;\n  border-radius: ${({ theme }) => theme.borderRadius}px;\n  border: none;\n`;\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/encodable/esm/encoders/createEncoderFactory.js\nvar createEncoderFactory = __webpack_require__(1138);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-choropleth-map/src/chart/Encoder.ts\n\nconst DefaultChannelOutputs = {\n    key: \'\',\n    fill: \'#f0f0f0\',\n    opacity: 1,\n    stroke: \'#ccc\',\n    strokeWidth: 1,\n};\nconst choroplethMapEncoderFactory = Object(createEncoderFactory["a" /* default */])({\n    channelTypes: {\n        key: \'Text\',\n        fill: \'Color\',\n        opacity: \'Numeric\',\n        stroke: \'Color\',\n        strokeWidth: \'Numeric\',\n        tooltip: \'Text\',\n    },\n    defaultEncoding: {\n        key: { field: \'key\', title: \'Location\' },\n        fill: { value: DefaultChannelOutputs.fill },\n        opacity: { value: DefaultChannelOutputs.opacity },\n        stroke: { value: DefaultChannelOutputs.stroke },\n        strokeWidth: { value: DefaultChannelOutputs.strokeWidth },\n        tooltip: [],\n    },\n});\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/encodable/esm/typeGuards/CompleteChannelDef.js\nvar CompleteChannelDef = __webpack_require__(811);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-choropleth-map/node_modules/@vx/tooltip/esm/tooltips/Tooltip.js\nvar Tooltip = __webpack_require__(2472);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/tooltip/TooltipFrame.tsx\nvar TooltipFrame = __webpack_require__(982);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/tooltip/TooltipTable.tsx\nvar TooltipTable = __webpack_require__(983);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-choropleth-map/src/chart/MapTooltip.tsx\n\n\n\n\n\nfunction MapTooltip({ encoder, left, top, tooltipData }) {\n    if (!tooltipData) {\n        return null;\n    }\n    const { channels } = encoder;\n    const { key, fill, stroke, strokeWidth, opacity, tooltip } = channels;\n    const { datum } = tooltipData;\n    const tooltipRows = [\n        { key: \'key\', keyColumn: key.getTitle(), valueColumn: key.formatDatum(datum) },\n    ];\n    [fill, stroke, opacity, strokeWidth].forEach(channel => {\n        if (Object(CompleteChannelDef["a" /* isCompleteFieldDef */])(channel.definition)) {\n            tooltipRows.push({\n                key: channel.name,\n                keyColumn: channel.getTitle(),\n                valueColumn: channel.formatDatum(datum),\n            });\n        }\n    });\n    tooltip.forEach(g => {\n        tooltipRows.push({\n            key: `${g.name}`,\n            keyColumn: g.getTitle(),\n            valueColumn: g.formatDatum(datum),\n        });\n    });\n    return (react_default.a.createElement(Tooltip["a" /* default */], { top: top, left: left },\n        react_default.a.createElement(TooltipFrame["a" /* default */], null,\n            react_default.a.createElement(TooltipTable["a" /* default */], { data: Object(lodash["uniqBy"])(tooltipRows, row => row.keyColumn) }))));\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/plugin-chart-choropleth-map/src/chart/ChoroplethMap.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\nconst INITIAL_TRANSFORM = {\n    scaleX: 1,\n    scaleY: 1,\n    translateX: 0,\n    translateY: 0,\n    skewX: 0,\n    skewY: 0,\n};\nconst defaultProps = {\n    data: [],\n    encoding: {},\n    map: \'world\',\n};\nconst missingItem = DefaultChannelOutputs;\nclass ChoroplethMap_ChoroplethMap extends react_default.a.PureComponent {\n    constructor(props) {\n        super(props);\n        this.createEncoder = choroplethMapEncoderFactory.createSelector();\n        this.toggleMiniMap = () => {\n            const { showMiniMap } = this.state;\n            this.setState({\n                showMiniMap: !showMiniMap,\n            });\n        };\n        this.handleMouseOver = (event, datum) => {\n            const coords = Object(localPoint["a" /* default */])(event);\n            this.props.showTooltip({\n                tooltipLeft: coords === null || coords === void 0 ? void 0 : coords.x,\n                tooltipTop: coords === null || coords === void 0 ? void 0 : coords.y,\n                tooltipData: datum,\n            });\n        };\n        this.state = {\n            mapData: {},\n            mapShape: undefined,\n            showMiniMap: true,\n        };\n    }\n    componentDidMount() {\n        this.loadMap();\n        this.processData();\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.map !== this.props.map) {\n            this.loadMap();\n        }\n        if (prevProps.data !== this.props.data || prevProps.encoding !== this.props.encoding) {\n            this.processData();\n        }\n    }\n    processData() {\n        const { data, encoding } = this.props;\n        const encoder = this.createEncoder(encoding);\n        const { key, fill, opacity, stroke, strokeWidth } = encoder.channels;\n        encoder.setDomainFromDataset(data);\n        const mapData = Object(lodash["keyBy"])(data.map(d => ({\n            key: key.getValueFromDatum(d, DefaultChannelOutputs.key),\n            fill: fill.encodeDatum(d, DefaultChannelOutputs.fill),\n            opacity: opacity.encodeDatum(d, DefaultChannelOutputs.opacity),\n            stroke: stroke.encodeDatum(d, DefaultChannelOutputs.stroke),\n            strokeWidth: strokeWidth.encodeDatum(d, DefaultChannelOutputs.strokeWidth),\n            datum: d,\n        })), d => d.key);\n        this.setState({ mapData });\n    }\n    loadMap() {\n        const { map } = this.props;\n        this.setState({ mapShape: undefined });\n        Object(loadMap["a" /* default */])(map).then(mapShape => {\n            this.setState({ mapShape });\n        });\n    }\n    renderMap() {\n        const { height, width, hideTooltip } = this.props;\n        const { mapShape, mapData } = this.state;\n        if (typeof mapShape !== \'undefined\') {\n            const { metadata, object } = mapShape;\n            const { keyAccessor } = metadata;\n            const projection = metadata.createProjection().fitExtent([\n                [PADDING, PADDING],\n                [width - PADDING * 2, height - PADDING * 2],\n            ], object);\n            const path = Object(src_path["a" /* default */])().projection(projection);\n            return object.features.map(f => {\n                const key = keyAccessor(f);\n                const encodedDatum = mapData[key] || missingItem;\n                const { stroke, fill, strokeWidth, opacity } = encodedDatum;\n                return (\n                // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events\n                react_default.a.createElement("path", { key: key, vectorEffect: "non-scaling-stroke", stroke: stroke, strokeWidth: strokeWidth, fill: fill, opacity: opacity, d: path(f) || \'\', onMouseOver: event => this.handleMouseOver(event, encodedDatum), onMouseMove: event => this.handleMouseOver(event, encodedDatum), onMouseOut: hideTooltip, onBlur: hideTooltip }));\n            });\n        }\n        return null;\n    }\n    render() {\n        const { height, width, encoding, tooltipOpen, tooltipLeft, tooltipTop, tooltipData, } = this.props;\n        const { showMiniMap } = this.state;\n        const encoder = this.createEncoder(encoding);\n        const renderedMap = this.renderMap();\n        const miniMapTransform = `translate(${(width * 3) / 4 - PADDING}, ${(height * 3) / 4 - PADDING}) scale(0.25)`;\n        return (react_default.a.createElement(react_default.a.Fragment, null,\n            react_default.a.createElement(Zoom["a" /* default */], { style: { width, height }, width: width, height: height, scaleXMin: 0.75, scaleXMax: 8, scaleYMin: 0.75, scaleYMax: 8, transformMatrix: INITIAL_TRANSFORM }, zoom => (react_default.a.createElement(RelativeDiv, null,\n                react_default.a.createElement("svg", { width: width, height: height, style: { cursor: zoom.isDragging ? \'grabbing\' : \'grab\' } },\n                    react_default.a.createElement(RectClipPath["a" /* default */], { id: "zoom-clip", width: width, height: height }),\n                    react_default.a.createElement("g", { onWheel: zoom.handleWheel, \n                        // eslint-disable-next-line react/jsx-handler-names\n                        onMouseDown: zoom.dragStart, \n                        // eslint-disable-next-line react/jsx-handler-names\n                        onMouseMove: zoom.dragMove, \n                        // eslint-disable-next-line react/jsx-handler-names\n                        onMouseUp: zoom.dragEnd, onMouseLeave: () => {\n                            if (!zoom.isDragging)\n                                return;\n                            zoom.dragEnd();\n                        }, onDoubleClick: event => {\n                            const point = Object(localPoint["a" /* default */])(event) || undefined;\n                            zoom.scale({ scaleX: 1.1, scaleY: 1.1, point });\n                        } },\n                        react_default.a.createElement("rect", { width: width, height: height, fill: "transparent" }),\n                        react_default.a.createElement("g", { transform: zoom.toString() }, renderedMap)),\n                    showMiniMap && (react_default.a.createElement("g", { clipPath: "url(#zoom-clip)", transform: miniMapTransform },\n                        react_default.a.createElement("rect", { width: width, height: height, fill: "#fff", stroke: "#999" }),\n                        renderedMap,\n                        react_default.a.createElement("rect", { width: width, height: height, fill: "white", fillOpacity: 0.2, stroke: "#999", strokeWidth: 4, transform: zoom.toStringInvert() })))),\n                react_default.a.createElement(ZoomControls, null,\n                    react_default.a.createElement(IconButton, { type: "button", onClick: () => zoom.scale({ scaleX: 1.2, scaleY: 1.2 }) }, "+"),\n                    react_default.a.createElement(IconButton, { type: "button", onClick: () => zoom.scale({ scaleX: 0.8, scaleY: 0.8 }) }, "-"),\n                    react_default.a.createElement(TextButton, { type: "button", \n                        // eslint-disable-next-line react/jsx-handler-names\n                        onClick: zoom.clear }, "Reset")),\n                react_default.a.createElement(MiniMapControl, null,\n                    react_default.a.createElement(TextButton, { type: "button", \n                        // eslint-disable-next-line react/jsx-handler-names\n                        onClick: this.toggleMiniMap }, showMiniMap ? Object(TranslatorSingleton["e" /* t */])(\'Hide Mini Map\') : Object(TranslatorSingleton["e" /* t */])(\'Show Mini Map\')))))),\n            tooltipOpen && (react_default.a.createElement(MapTooltip, { encoder: encoder, top: tooltipTop, left: tooltipLeft, tooltipData: tooltipData }))));\n    }\n}\nChoroplethMap_ChoroplethMap.defaultProps = defaultProps;\n/* harmony default export */ var chart_ChoroplethMap = __webpack_exports__["default"] = (Object(withTooltip["a" /* default */])(ChoroplethMap_ChoroplethMap));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ5OS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC1jaG9yb3BsZXRoLW1hcC9zcmMvY2hhcnQvY29tcG9uZW50cy50cz8zN2E2Iiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC1jaG9yb3BsZXRoLW1hcC9zcmMvY2hhcnQvRW5jb2Rlci50cz8zM2Y2Iiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC1jaG9yb3BsZXRoLW1hcC9zcmMvY2hhcnQvTWFwVG9vbHRpcC50c3g/Nzg4NyIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtY2hvcm9wbGV0aC1tYXAvc3JjL2NoYXJ0L0Nob3JvcGxldGhNYXAudHN4PzFlZGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkLCBzdXBlcnNldFRoZW1lIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuXG5leHBvcnQgY29uc3QgUEFERElORyA9IHN1cGVyc2V0VGhlbWUuZ3JpZFVuaXQgKiA0O1xuXG5leHBvcnQgY29uc3QgUmVsYXRpdmVEaXYgPSBzdHlsZWQuZGl2YFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XG5gO1xuXG5leHBvcnQgY29uc3QgWm9vbUNvbnRyb2xzID0gc3R5bGVkLmRpdmBcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6ICR7UEFERElOR31weDtcbiAgcmlnaHQ6ICR7UEFERElOR31weDtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xuYDtcblxuZXhwb3J0IGNvbnN0IE1pbmlNYXBDb250cm9sID0gc3R5bGVkLmRpdmBcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBib3R0b206ICR7UEFERElORyArIDZ9cHg7XG4gIHJpZ2h0OiAke1BBRERJTkcgKyAxfXB4O1xuYDtcblxuZXhwb3J0IGNvbnN0IEljb25CdXR0b24gPSBzdHlsZWQuYnV0dG9uYFxuICB3aWR0aDogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5ncmlkVW5pdCAqIDZ9cHg7XG4gIGZvbnQtc2l6ZTogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS50eXBvZ3JhcGh5LnNpemVzLnhsfXB4O1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIGNvbG9yOiAjMjIyO1xuICBtYXJnaW46IDBweDtcbiAgbWFyZ2luLWJvdHRvbTogMnB4O1xuICBiYWNrZ3JvdW5kOiAjZjVmOGZiO1xuICBwYWRkaW5nOiAwcHggJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5ncmlkVW5pdH1weDtcbiAgYm9yZGVyLXJhZGl1czogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5ib3JkZXJSYWRpdXN9cHg7XG4gIGJvcmRlcjogbm9uZTtcbmA7XG5cbmV4cG9ydCBjb25zdCBUZXh0QnV0dG9uID0gc3R5bGVkLmJ1dHRvbmBcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBmb250LXNpemU6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUudHlwb2dyYXBoeS5zaXplcy5zfXB4O1xuICBjb2xvcjogIzIyMjtcbiAgbWFyZ2luOiAwcHg7XG4gIGJhY2tncm91bmQ6ICNmNWY4ZmI7XG4gIHBhZGRpbmc6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuZ3JpZFVuaXQgLyAyfXB4ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuZ3JpZFVuaXQgKiAxLjV9cHg7XG4gIGJvcmRlci1yYWRpdXM6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuYm9yZGVyUmFkaXVzfXB4O1xuICBib3JkZXI6IG5vbmU7XG5gO1xuIiwiaW1wb3J0IHsgY3JlYXRlRW5jb2RlckZhY3RvcnksIERlcml2ZUVuY29kaW5nLCBFbmNvZGVyLCBEZXJpdmVDaGFubmVsT3V0cHV0cyB9IGZyb20gJ2VuY29kYWJsZSc7XG5cbnR5cGUgQ2hvcm9wbGV0aE1hcEVuY29kaW5nQ29uZmlnID0ge1xuICBrZXk6IFsnVGV4dCcsIHN0cmluZ107XG4gIGZpbGw6IFsnQ29sb3InLCBzdHJpbmddO1xuICBvcGFjaXR5OiBbJ051bWVyaWMnLCBudW1iZXJdO1xuICBzdHJva2U6IFsnQ29sb3InLCBzdHJpbmddO1xuICBzdHJva2VXaWR0aDogWydOdW1lcmljJywgbnVtYmVyXTtcbiAgdG9vbHRpcDogWydUZXh0Jywgc3RyaW5nLCAnbXVsdGlwbGUnXTtcbn07XG5cbmV4cG9ydCB0eXBlIENob3JvcGxldGhNYXBFbmNvZGluZyA9IERlcml2ZUVuY29kaW5nPENob3JvcGxldGhNYXBFbmNvZGluZ0NvbmZpZz47XG5cbmV4cG9ydCB0eXBlIENob3JvcGxldGhNYXBFbmNvZGVyID0gRW5jb2RlcjxDaG9yb3BsZXRoTWFwRW5jb2RpbmdDb25maWc+O1xuXG5leHBvcnQgdHlwZSBDaG9yb3BsZXRoTWFwQ2hhbm5lbE91dHB1dHMgPSBEZXJpdmVDaGFubmVsT3V0cHV0czxDaG9yb3BsZXRoTWFwRW5jb2RpbmdDb25maWc+O1xuXG5leHBvcnQgY29uc3QgRGVmYXVsdENoYW5uZWxPdXRwdXRzID0ge1xuICBrZXk6ICcnLFxuICBmaWxsOiAnI2YwZjBmMCcsXG4gIG9wYWNpdHk6IDEsXG4gIHN0cm9rZTogJyNjY2MnLFxuICBzdHJva2VXaWR0aDogMSxcbn07XG5cbmV4cG9ydCBjb25zdCBjaG9yb3BsZXRoTWFwRW5jb2RlckZhY3RvcnkgPSBjcmVhdGVFbmNvZGVyRmFjdG9yeTxDaG9yb3BsZXRoTWFwRW5jb2RpbmdDb25maWc+KHtcbiAgY2hhbm5lbFR5cGVzOiB7XG4gICAga2V5OiAnVGV4dCcsXG4gICAgZmlsbDogJ0NvbG9yJyxcbiAgICBvcGFjaXR5OiAnTnVtZXJpYycsXG4gICAgc3Ryb2tlOiAnQ29sb3InLFxuICAgIHN0cm9rZVdpZHRoOiAnTnVtZXJpYycsXG4gICAgdG9vbHRpcDogJ1RleHQnLFxuICB9LFxuICBkZWZhdWx0RW5jb2Rpbmc6IHtcbiAgICBrZXk6IHsgZmllbGQ6ICdrZXknLCB0aXRsZTogJ0xvY2F0aW9uJyB9LFxuICAgIGZpbGw6IHsgdmFsdWU6IERlZmF1bHRDaGFubmVsT3V0cHV0cy5maWxsIH0sXG4gICAgb3BhY2l0eTogeyB2YWx1ZTogRGVmYXVsdENoYW5uZWxPdXRwdXRzLm9wYWNpdHkgfSxcbiAgICBzdHJva2U6IHsgdmFsdWU6IERlZmF1bHRDaGFubmVsT3V0cHV0cy5zdHJva2UgfSxcbiAgICBzdHJva2VXaWR0aDogeyB2YWx1ZTogRGVmYXVsdENoYW5uZWxPdXRwdXRzLnN0cm9rZVdpZHRoIH0sXG4gICAgdG9vbHRpcDogW10sXG4gIH0sXG59KTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc0NvbXBsZXRlRmllbGREZWYgfSBmcm9tICdlbmNvZGFibGUnO1xuaW1wb3J0IHsgdW5pcUJ5IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRvb2x0aXAgfSBmcm9tICdAdngvdG9vbHRpcCc7XG5pbXBvcnQgeyBUb29sdGlwRnJhbWUsIFRvb2x0aXBUYWJsZSB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IENob3JvcGxldGhNYXBDaGFubmVsT3V0cHV0cywgQ2hvcm9wbGV0aE1hcEVuY29kZXIgfSBmcm9tICcuL0VuY29kZXInO1xuXG5leHBvcnQgdHlwZSBNYXBEYXRhUG9pbnQgPSBPbWl0PENob3JvcGxldGhNYXBDaGFubmVsT3V0cHV0cywgJ3Rvb2x0aXAnPiAmIHtcbiAgZGF0dW06IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xufTtcblxuZXhwb3J0IHR5cGUgTWFwVG9vbHRpcFByb3BzID0ge1xuICB0b3A/OiBudW1iZXI7XG4gIGxlZnQ/OiBudW1iZXI7XG4gIGVuY29kZXI6IENob3JvcGxldGhNYXBFbmNvZGVyO1xuICB0b29sdGlwRGF0YT86IE1hcERhdGFQb2ludDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1hcFRvb2x0aXAoeyBlbmNvZGVyLCBsZWZ0LCB0b3AsIHRvb2x0aXBEYXRhIH06IE1hcFRvb2x0aXBQcm9wcykge1xuICBpZiAoIXRvb2x0aXBEYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB7IGNoYW5uZWxzIH0gPSBlbmNvZGVyO1xuICBjb25zdCB7IGtleSwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgb3BhY2l0eSwgdG9vbHRpcCB9ID0gY2hhbm5lbHM7XG4gIGNvbnN0IHsgZGF0dW0gfSA9IHRvb2x0aXBEYXRhO1xuXG4gIGNvbnN0IHRvb2x0aXBSb3dzID0gW1xuICAgIHsga2V5OiAna2V5Jywga2V5Q29sdW1uOiBrZXkuZ2V0VGl0bGUoKSwgdmFsdWVDb2x1bW46IGtleS5mb3JtYXREYXR1bShkYXR1bSkgfSxcbiAgXTtcblxuICBbZmlsbCwgc3Ryb2tlLCBvcGFjaXR5LCBzdHJva2VXaWR0aF0uZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICBpZiAoaXNDb21wbGV0ZUZpZWxkRGVmPHN0cmluZyB8IG51bWJlcj4oY2hhbm5lbC5kZWZpbml0aW9uKSkge1xuICAgICAgdG9vbHRpcFJvd3MucHVzaCh7XG4gICAgICAgIGtleTogY2hhbm5lbC5uYW1lIGFzIHN0cmluZyxcbiAgICAgICAga2V5Q29sdW1uOiBjaGFubmVsLmdldFRpdGxlKCksXG4gICAgICAgIHZhbHVlQ29sdW1uOiBjaGFubmVsLmZvcm1hdERhdHVtKGRhdHVtKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdG9vbHRpcC5mb3JFYWNoKGcgPT4ge1xuICAgIHRvb2x0aXBSb3dzLnB1c2goe1xuICAgICAga2V5OiBgJHtnLm5hbWV9YCxcbiAgICAgIGtleUNvbHVtbjogZy5nZXRUaXRsZSgpLFxuICAgICAgdmFsdWVDb2x1bW46IGcuZm9ybWF0RGF0dW0oZGF0dW0pLFxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gKFxuICAgIDxUb29sdGlwIHRvcD17dG9wfSBsZWZ0PXtsZWZ0fT5cbiAgICAgIDxUb29sdGlwRnJhbWU+XG4gICAgICAgIDxUb29sdGlwVGFibGUgZGF0YT17dW5pcUJ5KHRvb2x0aXBSb3dzLCByb3cgPT4gcm93LmtleUNvbHVtbil9IC8+XG4gICAgICA8L1Rvb2x0aXBGcmFtZT5cbiAgICA8L1Rvb2x0aXA+XG4gICk7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdCB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IFpvb20gfSBmcm9tICdAdngvem9vbSc7XG5pbXBvcnQgeyBsb2NhbFBvaW50IH0gZnJvbSAnQHZ4L2V2ZW50JztcbmltcG9ydCB7IFJlY3RDbGlwUGF0aCB9IGZyb20gJ0B2eC9jbGlwLXBhdGgnO1xuaW1wb3J0IHsgd2l0aFRvb2x0aXAgfSBmcm9tICdAdngvdG9vbHRpcCc7XG5pbXBvcnQgeyBrZXlCeSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBnZW9QYXRoIH0gZnJvbSAnZDMtZ2VvJztcbmltcG9ydCB0eXBlIHsgRmVhdHVyZUNvbGxlY3Rpb24gfSBmcm9tICdnZW9qc29uJztcbmltcG9ydCB7IFdpdGhUb29sdGlwUHJvdmlkZWRQcm9wcyB9IGZyb20gJ0B2eC90b29sdGlwL2xpYi9lbmhhbmNlcnMvd2l0aFRvb2x0aXAnO1xuaW1wb3J0IGxvYWRNYXAgZnJvbSAnLi9sb2FkTWFwJztcbmltcG9ydCBNYXBNZXRhZGF0YSBmcm9tICcuL01hcE1ldGFkYXRhJztcbmltcG9ydCB7XG4gIFBBRERJTkcsXG4gIFJlbGF0aXZlRGl2LFxuICBJY29uQnV0dG9uLFxuICBUZXh0QnV0dG9uLFxuICBab29tQ29udHJvbHMsXG4gIE1pbmlNYXBDb250cm9sLFxufSBmcm9tICcuL2NvbXBvbmVudHMnO1xuaW1wb3J0IHtcbiAgQ2hvcm9wbGV0aE1hcEVuY29kaW5nLFxuICBjaG9yb3BsZXRoTWFwRW5jb2RlckZhY3RvcnksXG4gIERlZmF1bHRDaGFubmVsT3V0cHV0cyxcbn0gZnJvbSAnLi9FbmNvZGVyJztcbmltcG9ydCBNYXBUb29sdGlwLCB7IE1hcERhdGFQb2ludCB9IGZyb20gJy4vTWFwVG9vbHRpcCc7XG5cbmNvbnN0IElOSVRJQUxfVFJBTlNGT1JNID0ge1xuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMSxcbiAgdHJhbnNsYXRlWDogMCxcbiAgdHJhbnNsYXRlWTogMCxcbiAgc2tld1g6IDAsXG4gIHNrZXdZOiAwLFxufTtcblxuLyoqXG4gKiBUaGVzZSBwcm9wcyBzaG91bGQgYmUgc3RvcmVkIHdoZW4gc2F2aW5nIHRoZSBjaGFydC5cbiAqL1xuZXhwb3J0IHR5cGUgQ2hvcm9wbGV0aE1hcFZpc3VhbFByb3BzID0ge1xuICBlbmNvZGluZz86IFBhcnRpYWw8Q2hvcm9wbGV0aE1hcEVuY29kaW5nPjtcbiAgbWFwPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgQ2hvcm9wbGV0aE1hcFByb3BzID0gQ2hvcm9wbGV0aE1hcFZpc3VhbFByb3BzICZcbiAgV2l0aFRvb2x0aXBQcm92aWRlZFByb3BzPE1hcERhdGFQb2ludD4gJiB7XG4gICAgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXTtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICB3aWR0aDogbnVtYmVyO1xuICB9O1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGRhdGE6IFtdLFxuICBlbmNvZGluZzoge30sXG4gIG1hcDogJ3dvcmxkJyxcbn07XG5cbmNvbnN0IG1pc3NpbmdJdGVtID0gRGVmYXVsdENoYW5uZWxPdXRwdXRzO1xuXG5jbGFzcyBDaG9yb3BsZXRoTWFwIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxcbiAgQ2hvcm9wbGV0aE1hcFByb3BzICYgdHlwZW9mIGRlZmF1bHRQcm9wcyxcbiAge1xuICAgIG1hcFNoYXBlPzoge1xuICAgICAgbWV0YWRhdGE6IE1hcE1ldGFkYXRhO1xuICAgICAgb2JqZWN0OiBGZWF0dXJlQ29sbGVjdGlvbjtcbiAgICB9O1xuICAgIG1hcERhdGE6IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IE1hcERhdGFQb2ludDtcbiAgICB9O1xuICAgIHNob3dNaW5pTWFwOiBib29sZWFuO1xuICB9XG4+IHtcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuICBjcmVhdGVFbmNvZGVyID0gY2hvcm9wbGV0aE1hcEVuY29kZXJGYWN0b3J5LmNyZWF0ZVNlbGVjdG9yKCk7XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IENob3JvcGxldGhNYXBQcm9wcyAmIHR5cGVvZiBkZWZhdWx0UHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbWFwRGF0YToge30sXG4gICAgICBtYXBTaGFwZTogdW5kZWZpbmVkLFxuICAgICAgc2hvd01pbmlNYXA6IHRydWUsXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubG9hZE1hcCgpO1xuICAgIHRoaXMucHJvY2Vzc0RhdGEoKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IENob3JvcGxldGhNYXBQcm9wcykge1xuICAgIGlmIChwcmV2UHJvcHMubWFwICE9PSB0aGlzLnByb3BzLm1hcCkge1xuICAgICAgdGhpcy5sb2FkTWFwKCk7XG4gICAgfVxuICAgIGlmIChwcmV2UHJvcHMuZGF0YSAhPT0gdGhpcy5wcm9wcy5kYXRhIHx8IHByZXZQcm9wcy5lbmNvZGluZyAhPT0gdGhpcy5wcm9wcy5lbmNvZGluZykge1xuICAgICAgdGhpcy5wcm9jZXNzRGF0YSgpO1xuICAgIH1cbiAgfVxuXG4gIHByb2Nlc3NEYXRhKCkge1xuICAgIGNvbnN0IHsgZGF0YSwgZW5jb2RpbmcgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZW5jb2RlciA9IHRoaXMuY3JlYXRlRW5jb2RlcihlbmNvZGluZyk7XG4gICAgY29uc3QgeyBrZXksIGZpbGwsIG9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGggfSA9IGVuY29kZXIuY2hhbm5lbHM7XG5cbiAgICBlbmNvZGVyLnNldERvbWFpbkZyb21EYXRhc2V0KGRhdGEpO1xuXG4gICAgY29uc3QgbWFwRGF0YSA9IGtleUJ5KFxuICAgICAgZGF0YS5tYXAoZCA9PiAoe1xuICAgICAgICBrZXk6IGtleS5nZXRWYWx1ZUZyb21EYXR1bTxzdHJpbmc+KGQsIERlZmF1bHRDaGFubmVsT3V0cHV0cy5rZXkpLFxuICAgICAgICBmaWxsOiBmaWxsLmVuY29kZURhdHVtKGQsIERlZmF1bHRDaGFubmVsT3V0cHV0cy5maWxsKSxcbiAgICAgICAgb3BhY2l0eTogb3BhY2l0eS5lbmNvZGVEYXR1bShkLCBEZWZhdWx0Q2hhbm5lbE91dHB1dHMub3BhY2l0eSksXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlLmVuY29kZURhdHVtKGQsIERlZmF1bHRDaGFubmVsT3V0cHV0cy5zdHJva2UpLFxuICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGguZW5jb2RlRGF0dW0oZCwgRGVmYXVsdENoYW5uZWxPdXRwdXRzLnN0cm9rZVdpZHRoKSxcbiAgICAgICAgZGF0dW06IGQsXG4gICAgICB9KSksXG4gICAgICBkID0+IGQua2V5LFxuICAgICk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgbWFwRGF0YSB9KTtcbiAgfVxuXG4gIGxvYWRNYXAoKSB7XG4gICAgY29uc3QgeyBtYXAgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IG1hcFNoYXBlOiB1bmRlZmluZWQgfSk7XG4gICAgbG9hZE1hcChtYXApLnRoZW4obWFwU2hhcGUgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IG1hcFNoYXBlIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgdG9nZ2xlTWluaU1hcCA9ICgpID0+IHtcbiAgICBjb25zdCB7IHNob3dNaW5pTWFwIH0gPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2hvd01pbmlNYXA6ICFzaG93TWluaU1hcCxcbiAgICB9KTtcbiAgfTtcblxuICBoYW5kbGVNb3VzZU92ZXIgPSAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8U1ZHUGF0aEVsZW1lbnQ+LCBkYXR1bT86IE1hcERhdGFQb2ludCkgPT4ge1xuICAgIGNvbnN0IGNvb3JkcyA9IGxvY2FsUG9pbnQoZXZlbnQpO1xuICAgIHRoaXMucHJvcHMuc2hvd1Rvb2x0aXAoe1xuICAgICAgdG9vbHRpcExlZnQ6IGNvb3Jkcz8ueCxcbiAgICAgIHRvb2x0aXBUb3A6IGNvb3Jkcz8ueSxcbiAgICAgIHRvb2x0aXBEYXRhOiBkYXR1bSxcbiAgICB9KTtcbiAgfTtcblxuICByZW5kZXJNYXAoKSB7XG4gICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoLCBoaWRlVG9vbHRpcCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IG1hcFNoYXBlLCBtYXBEYXRhIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKHR5cGVvZiBtYXBTaGFwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHsgbWV0YWRhdGEsIG9iamVjdCB9ID0gbWFwU2hhcGU7XG4gICAgICBjb25zdCB7IGtleUFjY2Vzc29yIH0gPSBtZXRhZGF0YTtcbiAgICAgIGNvbnN0IHByb2plY3Rpb24gPSBtZXRhZGF0YS5jcmVhdGVQcm9qZWN0aW9uKCkuZml0RXh0ZW50KFxuICAgICAgICBbXG4gICAgICAgICAgW1BBRERJTkcsIFBBRERJTkddLFxuICAgICAgICAgIFt3aWR0aCAtIFBBRERJTkcgKiAyLCBoZWlnaHQgLSBQQURESU5HICogMl0sXG4gICAgICAgIF0sXG4gICAgICAgIG9iamVjdCxcbiAgICAgICk7XG4gICAgICBjb25zdCBwYXRoID0gZ2VvUGF0aCgpLnByb2plY3Rpb24ocHJvamVjdGlvbik7XG5cbiAgICAgIHJldHVybiBvYmplY3QuZmVhdHVyZXMubWFwKGYgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlBY2Nlc3NvcihmKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZERhdHVtID0gbWFwRGF0YVtrZXldIHx8IG1pc3NpbmdJdGVtO1xuICAgICAgICBjb25zdCB7IHN0cm9rZSwgZmlsbCwgc3Ryb2tlV2lkdGgsIG9wYWNpdHkgfSA9IGVuY29kZWREYXR1bTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9tb3VzZS1ldmVudHMtaGF2ZS1rZXktZXZlbnRzXG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGtleT17a2V5fVxuICAgICAgICAgICAgdmVjdG9yRWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCJcbiAgICAgICAgICAgIHN0cm9rZT17c3Ryb2tlfVxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg9e3N0cm9rZVdpZHRofVxuICAgICAgICAgICAgZmlsbD17ZmlsbH1cbiAgICAgICAgICAgIG9wYWNpdHk9e29wYWNpdHl9XG4gICAgICAgICAgICBkPXtwYXRoKGYpIHx8ICcnfVxuICAgICAgICAgICAgb25Nb3VzZU92ZXI9e2V2ZW50ID0+IHRoaXMuaGFuZGxlTW91c2VPdmVyKGV2ZW50LCBlbmNvZGVkRGF0dW0pfVxuICAgICAgICAgICAgb25Nb3VzZU1vdmU9e2V2ZW50ID0+IHRoaXMuaGFuZGxlTW91c2VPdmVyKGV2ZW50LCBlbmNvZGVkRGF0dW0pfVxuICAgICAgICAgICAgb25Nb3VzZU91dD17aGlkZVRvb2x0aXB9XG4gICAgICAgICAgICBvbkJsdXI9e2hpZGVUb29sdGlwfVxuICAgICAgICAgIC8+XG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICAgIGVuY29kaW5nLFxuICAgICAgdG9vbHRpcE9wZW4sXG4gICAgICB0b29sdGlwTGVmdCxcbiAgICAgIHRvb2x0aXBUb3AsXG4gICAgICB0b29sdGlwRGF0YSxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHNob3dNaW5pTWFwIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGVuY29kZXIgPSB0aGlzLmNyZWF0ZUVuY29kZXIoZW5jb2RpbmcpO1xuXG4gICAgY29uc3QgcmVuZGVyZWRNYXAgPSB0aGlzLnJlbmRlck1hcCgpO1xuICAgIGNvbnN0IG1pbmlNYXBUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7KHdpZHRoICogMykgLyA0IC0gUEFERElOR30sICR7XG4gICAgICAoaGVpZ2h0ICogMykgLyA0IC0gUEFERElOR1xuICAgIH0pIHNjYWxlKDAuMjUpYDtcblxuICAgIHJldHVybiAoXG4gICAgICA8PlxuICAgICAgICA8Wm9vbVxuICAgICAgICAgIHN0eWxlPXt7IHdpZHRoLCBoZWlnaHQgfX1cbiAgICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgICAgc2NhbGVYTWluPXswLjc1fVxuICAgICAgICAgIHNjYWxlWE1heD17OH1cbiAgICAgICAgICBzY2FsZVlNaW49ezAuNzV9XG4gICAgICAgICAgc2NhbGVZTWF4PXs4fVxuICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeD17SU5JVElBTF9UUkFOU0ZPUk19XG4gICAgICAgID5cbiAgICAgICAgICB7em9vbSA9PiAoXG4gICAgICAgICAgICA8UmVsYXRpdmVEaXY+XG4gICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgICAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgY3Vyc29yOiB6b29tLmlzRHJhZ2dpbmcgPyAnZ3JhYmJpbmcnIDogJ2dyYWInIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8UmVjdENsaXBQYXRoIGlkPVwiem9vbS1jbGlwXCIgd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gLz5cbiAgICAgICAgICAgICAgICA8Z1xuICAgICAgICAgICAgICAgICAgb25XaGVlbD17em9vbS5oYW5kbGVXaGVlbH1cbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtaGFuZGxlci1uYW1lc1xuICAgICAgICAgICAgICAgICAgb25Nb3VzZURvd249e3pvb20uZHJhZ1N0YXJ0fVxuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2pzeC1oYW5kbGVyLW5hbWVzXG4gICAgICAgICAgICAgICAgICBvbk1vdXNlTW92ZT17em9vbS5kcmFnTW92ZX1cbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtaGFuZGxlci1uYW1lc1xuICAgICAgICAgICAgICAgICAgb25Nb3VzZVVwPXt6b29tLmRyYWdFbmR9XG4gICAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF6b29tLmlzRHJhZ2dpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgem9vbS5kcmFnRW5kKCk7XG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgb25Eb3VibGVDbGljaz17ZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IGxvY2FsUG9pbnQoZXZlbnQpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgem9vbS5zY2FsZSh7IHNjYWxlWDogMS4xLCBzY2FsZVk6IDEuMSwgcG9pbnQgfSk7XG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxyZWN0IHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9IGZpbGw9XCJ0cmFuc3BhcmVudFwiIC8+XG4gICAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09e3pvb20udG9TdHJpbmcoKX0+e3JlbmRlcmVkTWFwfTwvZz5cbiAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICAge3Nob3dNaW5pTWFwICYmIChcbiAgICAgICAgICAgICAgICAgIDxnIGNsaXBQYXRoPVwidXJsKCN6b29tLWNsaXApXCIgdHJhbnNmb3JtPXttaW5pTWFwVHJhbnNmb3JtfT5cbiAgICAgICAgICAgICAgICAgICAgPHJlY3Qgd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gZmlsbD1cIiNmZmZcIiBzdHJva2U9XCIjOTk5XCIgLz5cbiAgICAgICAgICAgICAgICAgICAge3JlbmRlcmVkTWFwfVxuICAgICAgICAgICAgICAgICAgICA8cmVjdFxuICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwid2hpdGVcIlxuICAgICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5PXswLjJ9XG4gICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiIzk5OVwiXG4gICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezR9XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtPXt6b29tLnRvU3RyaW5nSW52ZXJ0KCl9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgIDxab29tQ29udHJvbHM+XG4gICAgICAgICAgICAgICAgPEljb25CdXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9eygpID0+IHpvb20uc2NhbGUoeyBzY2FsZVg6IDEuMiwgc2NhbGVZOiAxLjIgfSl9PlxuICAgICAgICAgICAgICAgICAgK1xuICAgICAgICAgICAgICAgIDwvSWNvbkJ1dHRvbj5cbiAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17KCkgPT4gem9vbS5zY2FsZSh7IHNjYWxlWDogMC44LCBzY2FsZVk6IDAuOCB9KX0+XG4gICAgICAgICAgICAgICAgICAtXG4gICAgICAgICAgICAgICAgPC9JY29uQnV0dG9uPlxuICAgICAgICAgICAgICAgIDxUZXh0QnV0dG9uXG4gICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtaGFuZGxlci1uYW1lc1xuICAgICAgICAgICAgICAgICAgb25DbGljaz17em9vbS5jbGVhcn1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBSZXNldFxuICAgICAgICAgICAgICAgIDwvVGV4dEJ1dHRvbj5cbiAgICAgICAgICAgICAgPC9ab29tQ29udHJvbHM+XG4gICAgICAgICAgICAgIDxNaW5pTWFwQ29udHJvbD5cbiAgICAgICAgICAgICAgICA8VGV4dEJ1dHRvblxuICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvanN4LWhhbmRsZXItbmFtZXNcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMudG9nZ2xlTWluaU1hcH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7c2hvd01pbmlNYXAgPyB0KCdIaWRlIE1pbmkgTWFwJykgOiB0KCdTaG93IE1pbmkgTWFwJyl9XG4gICAgICAgICAgICAgICAgPC9UZXh0QnV0dG9uPlxuICAgICAgICAgICAgICA8L01pbmlNYXBDb250cm9sPlxuICAgICAgICAgICAgPC9SZWxhdGl2ZURpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8L1pvb20+XG4gICAgICAgIHt0b29sdGlwT3BlbiAmJiAoXG4gICAgICAgICAgPE1hcFRvb2x0aXBcbiAgICAgICAgICAgIGVuY29kZXI9e2VuY29kZXJ9XG4gICAgICAgICAgICB0b3A9e3Rvb2x0aXBUb3B9XG4gICAgICAgICAgICBsZWZ0PXt0b29sdGlwTGVmdH1cbiAgICAgICAgICAgIHRvb2x0aXBEYXRhPXt0b29sdGlwRGF0YX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgPC8+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoVG9vbHRpcChDaG9yb3BsZXRoTWFwKTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVBO0FBRUE7O0FBRUE7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7O0FBRUE7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7Ozs7OztBQzdDQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBSUE7OztBQ3hEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQVFBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBaUJBO0FBQ0E7QUFIQTtBQXdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQWNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQVlBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBWUE7QUFDQTtBQUdBO0FBR0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFRQTtBQVVBOztBQXBPQTtBQXVPQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2499\n')}}]);