(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{1826:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return stringNumberDateObjectPropType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return scaleShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return boxPlotSeriesDataShape; });\n/* unused harmony export violinPlotSeriesDataShape */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return lineSeriesDataShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return areaSeriesDataShape; });\n/* unused harmony export barSeriesDataShape */\n/* unused harmony export groupedBarSeriesDataShape */\n/* unused harmony export stackedBarSeriesDataShape */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return pointSeriesDataShape; });\n/* unused harmony export intervalSeriesDataShape */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return axisStylesShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return tickStylesShape; });\n/* unused harmony export gridStylesShape */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return themeShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return interpolationShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return pointComponentPropTypes; });\n/* unused harmony export generalStyleShape */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return marginShape; });\n/* unused harmony export brushShape */\n/* unused harmony export dragShape */\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _interpolatorLookup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2077);\n\n\nvar stringNumberDateObjectPropType = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.instanceOf(Date), prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object]);\nvar scaleShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  type: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOf([\'time\', \'timeUtc\', \'linear\', \'band\']).isRequired,\n  includeZero: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,\n  // these would override any computation done by xyplot\n  // and would allow specifying colors for scales, etc.\n  range: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string])),\n  rangeRound: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string])),\n  domain: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string]))\n});\nvar boxPlotSeriesDataShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  x: stringNumberDateObjectPropType,\n  median: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  min: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  max: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  firstQuartile: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  thirdQuartile: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  outliers: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array.isRequired\n}));\nvar violinPlotSeriesDataShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  x: stringNumberDateObjectPropType,\n  binData: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.array.isRequired\n}));\nvar lineSeriesDataShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  x: stringNumberDateObjectPropType,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number // null data are not rendered\n\n}));\nvar areaSeriesDataShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  x: stringNumberDateObjectPropType,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  // null data are not rendered\n  y0: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  y1: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number\n}));\nvar barSeriesDataShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  x: stringNumberDateObjectPropType,\n  y: stringNumberDateObjectPropType,\n  fill: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  label: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string\n}));\nvar groupedBarSeriesDataShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  x: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object]).isRequired,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired\n}));\nvar stackedBarSeriesDataShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  x: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object]).isRequired,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired\n}));\nvar pointSeriesDataShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  x: stringNumberDateObjectPropType,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  size: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  fill: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  strokeDasharray: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  label: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string\n}));\nvar intervalSeriesDataShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  x0: stringNumberDateObjectPropType,\n  x1: stringNumberDateObjectPropType,\n  fill: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number\n}));\nvar axisStylesShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  label: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n    left: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,\n    right: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,\n    bottom: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,\n    top: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object\n  })\n});\nvar tickStylesShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  tickLength: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  label: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n    left: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,\n    right: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,\n    bottom: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,\n    top: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object\n  })\n});\nvar gridStylesShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number\n});\nvar themeShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  gridStyles: gridStylesShape,\n  xAxisStyles: axisStylesShape,\n  xTickStyles: tickStylesShape,\n  yAxisStyles: axisStylesShape,\n  yTickStyles: tickStylesShape\n});\nvar interpolationShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOf(Object.keys(_interpolatorLookup__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]));\nvar pointComponentPropTypes = {\n  x: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  size: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  fill: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,\n  fillOpacity: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  strokeDasharray: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  onClick: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,\n  onMouseMove: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,\n  onMouseLeave: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,\n  data: pointSeriesDataShape.isRequired,\n  datum: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object.isRequired\n};\nvar generalStyleShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  strokeOpacity: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  fill: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  fillOpacity: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number\n});\nvar marginShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  top: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  right: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  bottom: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number\n});\nvar brushShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  start: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n    x: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n    y: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired\n  }),\n  end: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n    x: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n    y: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired\n  }),\n  extent: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n    x0: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n    y0: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n    x1: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n    y1: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired\n  }),\n  bounds: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n    x0: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n    y0: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n    x1: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n    y1: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired\n  })\n});\nvar dragShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  x: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  dx: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  dy: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  isDragging: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,\n  dragEnd: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,\n  dragMove: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,\n  dragStart: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgyNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvZXNtL3V0aWxzL3Byb3BTaGFwZXMuanM/MGU5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGludGVycG9sYXRvckxvb2t1cCBmcm9tICcuL2ludGVycG9sYXRvckxvb2t1cCc7XG5leHBvcnQgdmFyIHN0cmluZ051bWJlckRhdGVPYmplY3RQcm9wVHlwZSA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpLCBQcm9wVHlwZXMub2JqZWN0XSk7XG5leHBvcnQgdmFyIHNjYWxlU2hhcGUgPSBQcm9wVHlwZXMuc2hhcGUoe1xuICB0eXBlOiBQcm9wVHlwZXMub25lT2YoWyd0aW1lJywgJ3RpbWVVdGMnLCAnbGluZWFyJywgJ2JhbmQnXSkuaXNSZXF1aXJlZCxcbiAgaW5jbHVkZVplcm86IFByb3BUeXBlcy5ib29sLFxuICAvLyB0aGVzZSB3b3VsZCBvdmVycmlkZSBhbnkgY29tcHV0YXRpb24gZG9uZSBieSB4eXBsb3RcbiAgLy8gYW5kIHdvdWxkIGFsbG93IHNwZWNpZnlpbmcgY29sb3JzIGZvciBzY2FsZXMsIGV0Yy5cbiAgcmFuZ2U6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSksXG4gIHJhbmdlUm91bmQ6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSksXG4gIGRvbWFpbjogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pKVxufSk7XG5leHBvcnQgdmFyIGJveFBsb3RTZXJpZXNEYXRhU2hhcGUgPSBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICB4OiBzdHJpbmdOdW1iZXJEYXRlT2JqZWN0UHJvcFR5cGUsXG4gIG1lZGlhbjogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBtaW46IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgbWF4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGZpcnN0UXVhcnRpbGU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgdGhpcmRRdWFydGlsZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBvdXRsaWVyczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbn0pKTtcbmV4cG9ydCB2YXIgdmlvbGluUGxvdFNlcmllc0RhdGFTaGFwZSA9IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zaGFwZSh7XG4gIHg6IHN0cmluZ051bWJlckRhdGVPYmplY3RQcm9wVHlwZSxcbiAgYmluRGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbn0pKTtcbmV4cG9ydCB2YXIgbGluZVNlcmllc0RhdGFTaGFwZSA9IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zaGFwZSh7XG4gIHg6IHN0cmluZ051bWJlckRhdGVPYmplY3RQcm9wVHlwZSxcbiAgeTogUHJvcFR5cGVzLm51bWJlciAvLyBudWxsIGRhdGEgYXJlIG5vdCByZW5kZXJlZFxuXG59KSk7XG5leHBvcnQgdmFyIGFyZWFTZXJpZXNEYXRhU2hhcGUgPSBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICB4OiBzdHJpbmdOdW1iZXJEYXRlT2JqZWN0UHJvcFR5cGUsXG4gIHk6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIG51bGwgZGF0YSBhcmUgbm90IHJlbmRlcmVkXG4gIHkwOiBQcm9wVHlwZXMubnVtYmVyLFxuICB5MTogUHJvcFR5cGVzLm51bWJlclxufSkpO1xuZXhwb3J0IHZhciBiYXJTZXJpZXNEYXRhU2hhcGUgPSBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICB4OiBzdHJpbmdOdW1iZXJEYXRlT2JqZWN0UHJvcFR5cGUsXG4gIHk6IHN0cmluZ051bWJlckRhdGVPYmplY3RQcm9wVHlwZSxcbiAgZmlsbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmdcbn0pKTtcbmV4cG9ydCB2YXIgZ3JvdXBlZEJhclNlcmllc0RhdGFTaGFwZSA9IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zaGFwZSh7XG4gIHg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKS5pc1JlcXVpcmVkLFxuICB5OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbn0pKTtcbmV4cG9ydCB2YXIgc3RhY2tlZEJhclNlcmllc0RhdGFTaGFwZSA9IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zaGFwZSh7XG4gIHg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKS5pc1JlcXVpcmVkLFxuICB5OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbn0pKTtcbmV4cG9ydCB2YXIgcG9pbnRTZXJpZXNEYXRhU2hhcGUgPSBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICB4OiBzdHJpbmdOdW1iZXJEYXRlT2JqZWN0UHJvcFR5cGUsXG4gIHk6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNpemU6IFByb3BUeXBlcy5udW1iZXIsXG4gIGZpbGw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmdcbn0pKTtcbmV4cG9ydCB2YXIgaW50ZXJ2YWxTZXJpZXNEYXRhU2hhcGUgPSBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICB4MDogc3RyaW5nTnVtYmVyRGF0ZU9iamVjdFByb3BUeXBlLFxuICB4MTogc3RyaW5nTnVtYmVyRGF0ZU9iamVjdFByb3BUeXBlLFxuICBmaWxsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMubnVtYmVyXG59KSk7XG5leHBvcnQgdmFyIGF4aXNTdHlsZXNTaGFwZSA9IFByb3BUeXBlcy5zaGFwZSh7XG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGxlZnQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgcmlnaHQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgYm90dG9tOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHRvcDogUHJvcFR5cGVzLm9iamVjdFxuICB9KVxufSk7XG5leHBvcnQgdmFyIHRpY2tTdHlsZXNTaGFwZSA9IFByb3BUeXBlcy5zaGFwZSh7XG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0xlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGFiZWw6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgbGVmdDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICByaWdodDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBib3R0b206IFByb3BUeXBlcy5vYmplY3QsXG4gICAgdG9wOiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pXG59KTtcbmV4cG9ydCB2YXIgZ3JpZFN0eWxlc1NoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Ryb2tlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzLm51bWJlclxufSk7XG5leHBvcnQgdmFyIHRoZW1lU2hhcGUgPSBQcm9wVHlwZXMuc2hhcGUoe1xuICBncmlkU3R5bGVzOiBncmlkU3R5bGVzU2hhcGUsXG4gIHhBeGlzU3R5bGVzOiBheGlzU3R5bGVzU2hhcGUsXG4gIHhUaWNrU3R5bGVzOiB0aWNrU3R5bGVzU2hhcGUsXG4gIHlBeGlzU3R5bGVzOiBheGlzU3R5bGVzU2hhcGUsXG4gIHlUaWNrU3R5bGVzOiB0aWNrU3R5bGVzU2hhcGVcbn0pO1xuZXhwb3J0IHZhciBpbnRlcnBvbGF0aW9uU2hhcGUgPSBQcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXMoaW50ZXJwb2xhdG9yTG9va3VwKSk7XG5leHBvcnQgdmFyIHBvaW50Q29tcG9uZW50UHJvcFR5cGVzID0ge1xuICB4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHk6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgc2l6ZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBmaWxsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGZpbGxPcGFjaXR5OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBzdHJva2VEYXNoYXJyYXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlTW92ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTW91c2VMZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGRhdGE6IHBvaW50U2VyaWVzRGF0YVNoYXBlLmlzUmVxdWlyZWQsXG4gIGRhdHVtOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5leHBvcnQgdmFyIGdlbmVyYWxTdHlsZVNoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Ryb2tlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgc3Ryb2tlT3BhY2l0eTogUHJvcFR5cGVzLm51bWJlcixcbiAgZmlsbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgZmlsbE9wYWNpdHk6IFByb3BUeXBlcy5udW1iZXJcbn0pO1xuZXhwb3J0IHZhciBtYXJnaW5TaGFwZSA9IFByb3BUeXBlcy5zaGFwZSh7XG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgcmlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGJvdHRvbTogUHJvcFR5cGVzLm51bWJlclxufSk7XG5leHBvcnQgdmFyIGJydXNoU2hhcGUgPSBQcm9wVHlwZXMuc2hhcGUoe1xuICBzdGFydDogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICB4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgeTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gIH0pLFxuICBlbmQ6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgeDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHk6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICB9KSxcbiAgZXh0ZW50OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHgwOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgeTA6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICB4MTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHkxOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgfSksXG4gIGJvdW5kczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICB4MDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHkwOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgeDE6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICB5MTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gIH0pXG59KTtcbmV4cG9ydCB2YXIgZHJhZ1NoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgeDogUHJvcFR5cGVzLm51bWJlcixcbiAgeTogUHJvcFR5cGVzLm51bWJlcixcbiAgZHg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGR5OiBQcm9wVHlwZXMubnVtYmVyLFxuICBpc0RyYWdnaW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgZHJhZ0VuZDogUHJvcFR5cGVzLmZ1bmMsXG4gIGRyYWdNb3ZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgZHJhZ1N0YXJ0OiBQcm9wVHlwZXMuZnVuY1xufSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1826\n')},1835:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return callOrValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return componentName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getChildWithName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return isDefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isAxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return isBarSeries; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return isBrush; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return isCirclePackSeries; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return isCrossHair; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return isReferenceLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return isSeries; });\n/* unused harmony export isStackedSeries */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return numTicksForHeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return numTicksForWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return propOrFallback; });\n/* unused harmony export scaleInvert */\n/* unused harmony export getDomainFromExtent */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DEFAULT_CHART_MARGIN; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* eslint no-magic-numbers: \'off\' */\n\nfunction callOrValue(maybeFn) {\n  if (typeof maybeFn === \'function\') {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return maybeFn.apply(void 0, args);\n  }\n\n  return maybeFn;\n}\nfunction componentName(component) {\n  if (component && component.type) {\n    return component.type.displayName || component.type.name || \'Component\';\n  }\n\n  return \'\';\n}\nfunction getChildWithName(name, children) {\n  var ChildOfInterest = react__WEBPACK_IMPORTED_MODULE_0__["Children"].toArray(children).filter(function (c) {\n    return componentName(c) === name;\n  });\n  return ChildOfInterest.length ? ChildOfInterest[0] : null;\n}\nfunction isDefined(val) {\n  return typeof val !== \'undefined\' && val !== null;\n}\nfunction isAxis(name) {\n  return /axis/gi.test(name);\n}\nfunction isBarSeries(name) {\n  return /bar/gi.test(name);\n}\nfunction isBrush(name) {\n  return name === \'Brush\';\n}\nfunction isCirclePackSeries(name) {\n  return name === \'CirclePackSeries\';\n}\nfunction isCrossHair(name) {\n  return /crosshair/gi.test(name);\n}\nfunction isReferenceLine(name) {\n  return /reference/gi.test(name);\n}\nfunction isSeries(name) {\n  return /series/gi.test(name);\n}\nfunction isStackedSeries(name) {\n  return /stacked/gi.test(name);\n}\nfunction numTicksForHeight(height) {\n  if (height <= 300) return 3;\n  if (height <= 600) return 5;\n  return 8;\n}\nfunction numTicksForWidth(width) {\n  if (width <= 300) return 3;\n  if (width <= 400) return 5;\n  return 10;\n}\nfunction propOrFallback(props, propName, fallback) {\n  return props && isDefined(props[propName]) ? props[propName] : fallback;\n}\nfunction scaleInvert(scale, value) {\n  // Test if the scale is an ordinalScale or not,\n  // Since an ordinalScale doesn\'t support invert function.\n  if (!scale.invert) {\n    var _scale$range = scale.range(),\n        start = _scale$range[0],\n        end = _scale$range[1];\n\n    var i = 0;\n    var width = scale.step() * (end - start) / Math.abs(end - start);\n\n    if (width > 0) {\n      while (value > start + width * (i + 1)) {\n        i += 1;\n      }\n    } else {\n      while (value < start + width * (i + 1)) {\n        i += 1;\n      }\n    }\n\n    return i;\n  }\n\n  return scale.invert(value);\n}\nfunction getDomainFromExtent(scale, start, end, tolerentDelta) {\n  var domain;\n  var invertedStart = scaleInvert(scale, start + (start < end ? -tolerentDelta : tolerentDelta));\n  var invertedEnd = scaleInvert(scale, end + (end < start ? -tolerentDelta : tolerentDelta));\n  var minValue = Math.min(invertedStart, invertedEnd);\n  var maxValue = Math.max(invertedStart, invertedEnd);\n\n  if (scale.invert) {\n    domain = {\n      start: minValue,\n      end: maxValue\n    };\n  } else {\n    var values = [];\n    var scaleDomain = scale.domain();\n\n    for (var i = minValue; i <= maxValue; i += 1) {\n      values.push(scaleDomain[i]);\n    }\n\n    domain = {\n      values: values\n    };\n  }\n\n  return domain;\n}\nvar DEFAULT_CHART_MARGIN = {\n  top: 64,\n  right: 64,\n  bottom: 64,\n  left: 64\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgzNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvZXNtL3V0aWxzL2NoYXJ0VXRpbHMuanM/ODQxYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tbWFnaWMtbnVtYmVyczogJ29mZicgKi9cbmltcG9ydCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGxPclZhbHVlKG1heWJlRm4pIHtcbiAgaWYgKHR5cGVvZiBtYXliZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlRm4uYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiBtYXliZUZuO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudE5hbWUoY29tcG9uZW50KSB7XG4gIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnR5cGUpIHtcbiAgICByZXR1cm4gY29tcG9uZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50LnR5cGUubmFtZSB8fCAnQ29tcG9uZW50JztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGlsZFdpdGhOYW1lKG5hbWUsIGNoaWxkcmVuKSB7XG4gIHZhciBDaGlsZE9mSW50ZXJlc3QgPSBDaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gY29tcG9uZW50TmFtZShjKSA9PT0gbmFtZTtcbiAgfSk7XG4gIHJldHVybiBDaGlsZE9mSW50ZXJlc3QubGVuZ3RoID8gQ2hpbGRPZkludGVyZXN0WzBdIDogbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgIT09IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBeGlzKG5hbWUpIHtcbiAgcmV0dXJuIC9heGlzL2dpLnRlc3QobmFtZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCYXJTZXJpZXMobmFtZSkge1xuICByZXR1cm4gL2Jhci9naS50ZXN0KG5hbWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQnJ1c2gobmFtZSkge1xuICByZXR1cm4gbmFtZSA9PT0gJ0JydXNoJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NpcmNsZVBhY2tTZXJpZXMobmFtZSkge1xuICByZXR1cm4gbmFtZSA9PT0gJ0NpcmNsZVBhY2tTZXJpZXMnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ3Jvc3NIYWlyKG5hbWUpIHtcbiAgcmV0dXJuIC9jcm9zc2hhaXIvZ2kudGVzdChuYW1lKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZmVyZW5jZUxpbmUobmFtZSkge1xuICByZXR1cm4gL3JlZmVyZW5jZS9naS50ZXN0KG5hbWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU2VyaWVzKG5hbWUpIHtcbiAgcmV0dXJuIC9zZXJpZXMvZ2kudGVzdChuYW1lKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1N0YWNrZWRTZXJpZXMobmFtZSkge1xuICByZXR1cm4gL3N0YWNrZWQvZ2kudGVzdChuYW1lKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1UaWNrc0ZvckhlaWdodChoZWlnaHQpIHtcbiAgaWYgKGhlaWdodCA8PSAzMDApIHJldHVybiAzO1xuICBpZiAoaGVpZ2h0IDw9IDYwMCkgcmV0dXJuIDU7XG4gIHJldHVybiA4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bVRpY2tzRm9yV2lkdGgod2lkdGgpIHtcbiAgaWYgKHdpZHRoIDw9IDMwMCkgcmV0dXJuIDM7XG4gIGlmICh3aWR0aCA8PSA0MDApIHJldHVybiA1O1xuICByZXR1cm4gMTA7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJvcE9yRmFsbGJhY2socHJvcHMsIHByb3BOYW1lLCBmYWxsYmFjaykge1xuICByZXR1cm4gcHJvcHMgJiYgaXNEZWZpbmVkKHByb3BzW3Byb3BOYW1lXSkgPyBwcm9wc1twcm9wTmFtZV0gOiBmYWxsYmFjaztcbn1cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUludmVydChzY2FsZSwgdmFsdWUpIHtcbiAgLy8gVGVzdCBpZiB0aGUgc2NhbGUgaXMgYW4gb3JkaW5hbFNjYWxlIG9yIG5vdCxcbiAgLy8gU2luY2UgYW4gb3JkaW5hbFNjYWxlIGRvZXNuJ3Qgc3VwcG9ydCBpbnZlcnQgZnVuY3Rpb24uXG4gIGlmICghc2NhbGUuaW52ZXJ0KSB7XG4gICAgdmFyIF9zY2FsZSRyYW5nZSA9IHNjYWxlLnJhbmdlKCksXG4gICAgICAgIHN0YXJ0ID0gX3NjYWxlJHJhbmdlWzBdLFxuICAgICAgICBlbmQgPSBfc2NhbGUkcmFuZ2VbMV07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHdpZHRoID0gc2NhbGUuc3RlcCgpICogKGVuZCAtIHN0YXJ0KSAvIE1hdGguYWJzKGVuZCAtIHN0YXJ0KTtcblxuICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgIHdoaWxlICh2YWx1ZSA+IHN0YXJ0ICsgd2lkdGggKiAoaSArIDEpKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHZhbHVlIDwgc3RhcnQgKyB3aWR0aCAqIChpICsgMSkpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgcmV0dXJuIHNjYWxlLmludmVydCh2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9tYWluRnJvbUV4dGVudChzY2FsZSwgc3RhcnQsIGVuZCwgdG9sZXJlbnREZWx0YSkge1xuICB2YXIgZG9tYWluO1xuICB2YXIgaW52ZXJ0ZWRTdGFydCA9IHNjYWxlSW52ZXJ0KHNjYWxlLCBzdGFydCArIChzdGFydCA8IGVuZCA/IC10b2xlcmVudERlbHRhIDogdG9sZXJlbnREZWx0YSkpO1xuICB2YXIgaW52ZXJ0ZWRFbmQgPSBzY2FsZUludmVydChzY2FsZSwgZW5kICsgKGVuZCA8IHN0YXJ0ID8gLXRvbGVyZW50RGVsdGEgOiB0b2xlcmVudERlbHRhKSk7XG4gIHZhciBtaW5WYWx1ZSA9IE1hdGgubWluKGludmVydGVkU3RhcnQsIGludmVydGVkRW5kKTtcbiAgdmFyIG1heFZhbHVlID0gTWF0aC5tYXgoaW52ZXJ0ZWRTdGFydCwgaW52ZXJ0ZWRFbmQpO1xuXG4gIGlmIChzY2FsZS5pbnZlcnQpIHtcbiAgICBkb21haW4gPSB7XG4gICAgICBzdGFydDogbWluVmFsdWUsXG4gICAgICBlbmQ6IG1heFZhbHVlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIHNjYWxlRG9tYWluID0gc2NhbGUuZG9tYWluKCk7XG5cbiAgICBmb3IgKHZhciBpID0gbWluVmFsdWU7IGkgPD0gbWF4VmFsdWU7IGkgKz0gMSkge1xuICAgICAgdmFsdWVzLnB1c2goc2NhbGVEb21haW5baV0pO1xuICAgIH1cblxuICAgIGRvbWFpbiA9IHtcbiAgICAgIHZhbHVlczogdmFsdWVzXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBkb21haW47XG59XG5leHBvcnQgdmFyIERFRkFVTFRfQ0hBUlRfTUFSR0lOID0ge1xuICB0b3A6IDY0LFxuICByaWdodDogNjQsXG4gIGJvdHRvbTogNjQsXG4gIGxlZnQ6IDY0XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1835\n')},1842:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Group; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(183);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction Group(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      transform = _ref.transform,\n      className = _ref.className,\n      children = _ref.children,\n      restProps = objectWithoutProperties(_ref, ['top', 'left', 'transform', 'className', 'children']);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    'g',\n    _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('cx-group', className),\n      transform: transform || 'translate(' + left + ', ' + top + ')'\n    }, restProps),\n    children\n  );\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg0Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvbm9kZV9tb2R1bGVzL0B2eC9ncm91cC9kaXN0L3Z4LWdyb3VwLmVzLmpzP2YwZWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZnVuY3Rpb24gR3JvdXAoX3JlZikge1xuICB2YXIgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3AsXG4gICAgICBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gX3JlZi50cmFuc2Zvcm0sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsndG9wJywgJ2xlZnQnLCAndHJhbnNmb3JtJywgJ2NsYXNzTmFtZScsICdjaGlsZHJlbiddKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjeCgnY3gtZ3JvdXAnLCBjbGFzc05hbWUpLFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfHwgJ3RyYW5zbGF0ZSgnICsgbGVmdCArICcsICcgKyB0b3AgKyAnKSdcbiAgICB9LCByZXN0UHJvcHMpLFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbmV4cG9ydCB7IEdyb3VwIH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1842\n")},1857:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return point; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Cardinal; });\nfunction point(that, x, y) {\n  that._context.bezierCurveTo(\n    that._x1 + that._k * (that._x2 - that._x0),\n    that._y1 + that._k * (that._y2 - that._y0),\n    that._x2 + that._k * (that._x1 - x),\n    that._y2 + that._k * (that._y1 - y),\n    that._x2,\n    that._y2\n  );\n}\n\nfunction Cardinal(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinal.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: point(this, this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;\n      case 2: this._point = 3; // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\n/* harmony default export */ __webpack_exports__["b"] = ((function custom(tension) {\n\n  function cardinal(context) {\n    return new Cardinal(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg1Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhcmRpbmFsLmpzPzQ5OTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHBvaW50KHRoYXQsIHgsIHkpIHtcbiAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKFxuICAgIHRoYXQuX3gxICsgdGhhdC5fayAqICh0aGF0Ll94MiAtIHRoYXQuX3gwKSxcbiAgICB0aGF0Ll95MSArIHRoYXQuX2sgKiAodGhhdC5feTIgLSB0aGF0Ll95MCksXG4gICAgdGhhdC5feDIgKyB0aGF0Ll9rICogKHRoYXQuX3gxIC0geCksXG4gICAgdGhhdC5feTIgKyB0aGF0Ll9rICogKHRoYXQuX3kxIC0geSksXG4gICAgdGhhdC5feDIsXG4gICAgdGhhdC5feTJcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl94MSA9IHgsIHRoaXMuX3kxID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbChjb250ZXh0LCB0ZW5zaW9uKTtcbiAgfVxuXG4gIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gIH07XG5cbiAgcmV0dXJuIGNhcmRpbmFsO1xufSkoMCk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1857\n')},1877:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return monotoneX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return monotoneY; });\nfunction sign(x) {\n  return x < 0 ? -1 : 1;\n}\n\n// Calculate the slopes of the tangents (Hermite-type interpolation) based on\n// the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n// NOV(II), P. 443, 1990.\nfunction slope3(that, x2, y2) {\n  var h0 = that._x1 - that._x0,\n      h1 = x2 - that._x1,\n      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),\n      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),\n      p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\n\n// Calculate a one-sided slope.\nfunction slope2(that, t) {\n  var h = that._x1 - that._x0;\n  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n}\n\n// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n// "you can express cubic Hermite interpolation in terms of cubic BÃ©zier curves\n// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".\nfunction point(that, t0, t1) {\n  var x0 = that._x0,\n      y0 = that._y0,\n      x1 = that._x1,\n      y1 = that._y1,\n      dx = (x1 - x0) / 3;\n  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);\n}\n\nfunction MonotoneX(context) {\n  this._context = context;\n}\n\nMonotoneX.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 =\n    this._t0 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n      case 3: point(this, this._t0, slope2(this, this._t0)); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    var t1 = NaN;\n\n    x = +x, y = +y;\n    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;\n      default: point(this, this._t0, t1 = slope3(this, x, y)); break;\n    }\n\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n    this._t0 = t1;\n  }\n}\n\nfunction MonotoneY(context) {\n  this._context = new ReflectContext(context);\n}\n\n(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {\n  MonotoneX.prototype.point.call(this, y, x);\n};\n\nfunction ReflectContext(context) {\n  this._context = context;\n}\n\nReflectContext.prototype = {\n  moveTo: function(x, y) { this._context.moveTo(y, x); },\n  closePath: function() { this._context.closePath(); },\n  lineTo: function(x, y) { this._context.lineTo(y, x); },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }\n};\n\nfunction monotoneX(context) {\n  return new MonotoneX(context);\n}\n\nfunction monotoneY(context) {\n  return new MonotoneY(context);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg3Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL21vbm90b25lLmpzPzkyMDgiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gc2lnbih4KSB7XG4gIHJldHVybiB4IDwgMCA/IC0xIDogMTtcbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBzbG9wZXMgb2YgdGhlIHRhbmdlbnRzIChIZXJtaXRlLXR5cGUgaW50ZXJwb2xhdGlvbikgYmFzZWQgb25cbi8vIHRoZSBmb2xsb3dpbmcgcGFwZXI6IFN0ZWZmZW4sIE0uIDE5OTAuIEEgU2ltcGxlIE1ldGhvZCBmb3IgTW9ub3RvbmljXG4vLyBJbnRlcnBvbGF0aW9uIGluIE9uZSBEaW1lbnNpb24uIEFzdHJvbm9teSBhbmQgQXN0cm9waHlzaWNzLCBWb2wuIDIzOSwgTk8uXG4vLyBOT1YoSUkpLCBQLiA0NDMsIDE5OTAuXG5mdW5jdGlvbiBzbG9wZTModGhhdCwgeDIsIHkyKSB7XG4gIHZhciBoMCA9IHRoYXQuX3gxIC0gdGhhdC5feDAsXG4gICAgICBoMSA9IHgyIC0gdGhhdC5feDEsXG4gICAgICBzMCA9ICh0aGF0Ll95MSAtIHRoYXQuX3kwKSAvIChoMCB8fCBoMSA8IDAgJiYgLTApLFxuICAgICAgczEgPSAoeTIgLSB0aGF0Ll95MSkgLyAoaDEgfHwgaDAgPCAwICYmIC0wKSxcbiAgICAgIHAgPSAoczAgKiBoMSArIHMxICogaDApIC8gKGgwICsgaDEpO1xuICByZXR1cm4gKHNpZ24oczApICsgc2lnbihzMSkpICogTWF0aC5taW4oTWF0aC5hYnMoczApLCBNYXRoLmFicyhzMSksIDAuNSAqIE1hdGguYWJzKHApKSB8fCAwO1xufVxuXG4vLyBDYWxjdWxhdGUgYSBvbmUtc2lkZWQgc2xvcGUuXG5mdW5jdGlvbiBzbG9wZTIodGhhdCwgdCkge1xuICB2YXIgaCA9IHRoYXQuX3gxIC0gdGhhdC5feDA7XG4gIHJldHVybiBoID8gKDMgKiAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyBoIC0gdCkgLyAyIDogdDtcbn1cblxuLy8gQWNjb3JkaW5nIHRvIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX0hlcm1pdGVfc3BsaW5lI1JlcHJlc2VudGF0aW9uc1xuLy8gXCJ5b3UgY2FuIGV4cHJlc3MgY3ViaWMgSGVybWl0ZSBpbnRlcnBvbGF0aW9uIGluIHRlcm1zIG9mIGN1YmljIELDqXppZXIgY3VydmVzXG4vLyB3aXRoIHJlc3BlY3QgdG8gdGhlIGZvdXIgdmFsdWVzIHAwLCBwMCArIG0wIC8gMywgcDEgLSBtMSAvIDMsIHAxXCIuXG5mdW5jdGlvbiBwb2ludCh0aGF0LCB0MCwgdDEpIHtcbiAgdmFyIHgwID0gdGhhdC5feDAsXG4gICAgICB5MCA9IHRoYXQuX3kwLFxuICAgICAgeDEgPSB0aGF0Ll94MSxcbiAgICAgIHkxID0gdGhhdC5feTEsXG4gICAgICBkeCA9ICh4MSAtIHgwKSAvIDM7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCArIGR4LCB5MCArIGR4ICogdDAsIHgxIC0gZHgsIHkxIC0gZHggKiB0MSwgeDEsIHkxKTtcbn1cblxuZnVuY3Rpb24gTW9ub3RvbmVYKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbk1vbm90b25lWC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9XG4gICAgdGhpcy5fdDAgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgICAgY2FzZSAzOiBwb2ludCh0aGlzLCB0aGlzLl90MCwgc2xvcGUyKHRoaXMsIHRoaXMuX3QwKSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciB0MSA9IE5hTjtcblxuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh4ID09PSB0aGlzLl94MSAmJiB5ID09PSB0aGlzLl95MSkgcmV0dXJuOyAvLyBJZ25vcmUgY29pbmNpZGVudCBwb2ludHMuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyBwb2ludCh0aGlzLCBzbG9wZTIodGhpcywgdDEgPSBzbG9wZTModGhpcywgeCwgeSkpLCB0MSk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgdGhpcy5fdDAsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgICB0aGlzLl90MCA9IHQxO1xuICB9XG59XG5cbmZ1bmN0aW9uIE1vbm90b25lWShjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBuZXcgUmVmbGVjdENvbnRleHQoY29udGV4dCk7XG59XG5cbihNb25vdG9uZVkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb25vdG9uZVgucHJvdG90eXBlKSkucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIE1vbm90b25lWC5wcm90b3R5cGUucG9pbnQuY2FsbCh0aGlzLCB5LCB4KTtcbn07XG5cbmZ1bmN0aW9uIFJlZmxlY3RDb250ZXh0KGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblJlZmxlY3RDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuX2NvbnRleHQubW92ZVRvKHksIHgpOyB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkgeyB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpOyB9LFxuICBsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5fY29udGV4dC5saW5lVG8oeSwgeCk7IH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7IHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh5MSwgeDEsIHkyLCB4MiwgeSwgeCk7IH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb25vdG9uZVgoY29udGV4dCkge1xuICByZXR1cm4gbmV3IE1vbm90b25lWChjb250ZXh0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vbm90b25lWShjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTW9ub3RvbmVZKGNvbnRleHQpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1877\n')},1900:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _propShapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1826);\n\n\n/* harmony default export */ __webpack_exports__["a"] = ({\n  disableMouseEvents: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,\n  seriesKey: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  onClick: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,\n  onMouseMove: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,\n  onMouseLeave: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,\n  xScale: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,\n  yScale: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,\n  margin: _propShapes__WEBPACK_IMPORTED_MODULE_1__[/* marginShape */ "f"]\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkwMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvZXNtL3V0aWxzL3NoYXJlZFNlcmllc1Byb3BzLmpzPzM5NTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IG1hcmdpblNoYXBlIH0gZnJvbSAnLi9wcm9wU2hhcGVzJztcbmV4cG9ydCBkZWZhdWx0IHtcbiAgZGlzYWJsZU1vdXNlRXZlbnRzOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2VyaWVzS2V5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZU1vdmU6IFByb3BUeXBlcy5mdW5jLFxuICBvbk1vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLFxuICB5U2NhbGU6IFByb3BUeXBlcy5mdW5jLFxuICBtYXJnaW46IG1hcmdpblNoYXBlXG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1900\n')},1929:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export allColors */\n/* unused harmony export grayColors */\n/* unused harmony export getPaletteForBrightness */\n/* unused harmony export colorHues */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return textColor; });\n// source https://yeun.github.io/open-color/\nvar allColors={red:["#fff5f5","#ffe3e3","#ffc9c9","#ffa8a8","#ff8787","#ff6b6b","#fa5252","#f03e3e","#e03131","#c92a2a"],pink:["#fff0f6","#ffdeeb","#fcc2d7","#faa2c1","#f783ac","#f06595","#e64980","#d6336c","#c2255c","#a61e4d"],grape:["#f8f0fc","#f3d9fa","#eebefa","#e599f7","#da77f2","#cc5de8","#be4bdb","#ae3ec9","#9c36b5","#862e9c"],violet:["#f3f0ff","#e5dbff","#d0bfff","#b197fc","#9775fa","#845ef7","#7950f2","#7048e8","#6741d9","#5f3dc4"],indigo:["#edf2ff","#dbe4ff","#bac8ff","#91a7ff","#748ffc","#5c7cfa","#4c6ef5","#4263eb","#3b5bdb","#364fc7"],blue:["#e8f7ff","#ccedff","#a3daff","#72c3fc","#4dadf7","#329af0","#228ae6","#1c7cd6","#1b6ec2","#1862ab"],cyan:["#e3fafc","#c5f6fa","#99e9f2","#66d9e8","#3bc9db","#22b8cf","#15aabf","#1098ad","#0c8599","#0b7285"],teal:["#e6fcf5","#c3fae8","#96f2d7","#63e6be","#38d9a9","#20c997","#12b886","#0ca678","#099268","#087f5b"],green:["#ebfbee","#d3f9d8","#b2f2bb","#8ce99a","#69db7c","#51cf66","#40c057","#37b24d","#2f9e44","#2b8a3e"],lime:["#f4fce3","#e9fac8","#d8f5a2","#c0eb75","#a9e34b","#94d82d","#82c91e","#74b816","#66a80f","#5c940d"],yellow:["#fff9db","#fff3bf","#ffec99","#ffe066","#ffd43b","#fcc419","#fab005","#f59f00","#f08c00","#e67700"],orange:["#fff4e6","#ffe8cc","#ffd8a8","#ffc078","#ffa94d","#ff922b","#fd7e14","#f76707","#e8590c","#d9480f"],gray:["#f8f9fa","#f1f3f5","#e9ecef","#dee2e6","#ced4da","#adb5bd","#868e96","#495057","#343a40","#212529"]};var grayColors=allColors.gray;var DEFAULT_BRIGHTNESS=6,DEFAULT_BRIGHTNESS_DARK=2;var getPaletteForBrightness=function(a,b){void 0===a&&(a=DEFAULT_BRIGHTNESS),void 0===b&&(b=["cyan","yellow","pink","grape","blue","lime","teal","red","violet","orange","indigo","green"]);// sanity check indices\nvar c=Math.max(0,Math.min(a,allColors.red.length-1));// filter non-sensical hues\nreturn b.map(function(a){return allColors[a]&&allColors[a][c]}).filter(function(a){return a})};var primaryHue="cyan";var colorHues=Object.keys(allColors).sort();var textColor=grayColors[7];/* harmony default export */ __webpack_exports__["a"] = ({default:allColors[primaryHue][5],dark:allColors[primaryHue][7],light:allColors[primaryHue][3],disabled:textColor,lightDisabled:grayColors[3],text:textColor,black:grayColors[9],darkGray:grayColors[8],lightGray:grayColors[3],grid:grayColors[4],gridDark:grayColors[8],label:textColor,tickLabel:textColor,grays:grayColors,categories:[].concat(getPaletteForBrightness(DEFAULT_BRIGHTNESS),getPaletteForBrightness(DEFAULT_BRIGHTNESS_DARK))});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvdGhlbWUvZXNtL2NvbG9yLmpzPzZhYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc291cmNlIGh0dHBzOi8veWV1bi5naXRodWIuaW8vb3Blbi1jb2xvci9cbmV4cG9ydCB2YXIgYWxsQ29sb3JzPXtyZWQ6W1wiI2ZmZjVmNVwiLFwiI2ZmZTNlM1wiLFwiI2ZmYzljOVwiLFwiI2ZmYThhOFwiLFwiI2ZmODc4N1wiLFwiI2ZmNmI2YlwiLFwiI2ZhNTI1MlwiLFwiI2YwM2UzZVwiLFwiI2UwMzEzMVwiLFwiI2M5MmEyYVwiXSxwaW5rOltcIiNmZmYwZjZcIixcIiNmZmRlZWJcIixcIiNmY2MyZDdcIixcIiNmYWEyYzFcIixcIiNmNzgzYWNcIixcIiNmMDY1OTVcIixcIiNlNjQ5ODBcIixcIiNkNjMzNmNcIixcIiNjMjI1NWNcIixcIiNhNjFlNGRcIl0sZ3JhcGU6W1wiI2Y4ZjBmY1wiLFwiI2YzZDlmYVwiLFwiI2VlYmVmYVwiLFwiI2U1OTlmN1wiLFwiI2RhNzdmMlwiLFwiI2NjNWRlOFwiLFwiI2JlNGJkYlwiLFwiI2FlM2VjOVwiLFwiIzljMzZiNVwiLFwiIzg2MmU5Y1wiXSx2aW9sZXQ6W1wiI2YzZjBmZlwiLFwiI2U1ZGJmZlwiLFwiI2QwYmZmZlwiLFwiI2IxOTdmY1wiLFwiIzk3NzVmYVwiLFwiIzg0NWVmN1wiLFwiIzc5NTBmMlwiLFwiIzcwNDhlOFwiLFwiIzY3NDFkOVwiLFwiIzVmM2RjNFwiXSxpbmRpZ286W1wiI2VkZjJmZlwiLFwiI2RiZTRmZlwiLFwiI2JhYzhmZlwiLFwiIzkxYTdmZlwiLFwiIzc0OGZmY1wiLFwiIzVjN2NmYVwiLFwiIzRjNmVmNVwiLFwiIzQyNjNlYlwiLFwiIzNiNWJkYlwiLFwiIzM2NGZjN1wiXSxibHVlOltcIiNlOGY3ZmZcIixcIiNjY2VkZmZcIixcIiNhM2RhZmZcIixcIiM3MmMzZmNcIixcIiM0ZGFkZjdcIixcIiMzMjlhZjBcIixcIiMyMjhhZTZcIixcIiMxYzdjZDZcIixcIiMxYjZlYzJcIixcIiMxODYyYWJcIl0sY3lhbjpbXCIjZTNmYWZjXCIsXCIjYzVmNmZhXCIsXCIjOTllOWYyXCIsXCIjNjZkOWU4XCIsXCIjM2JjOWRiXCIsXCIjMjJiOGNmXCIsXCIjMTVhYWJmXCIsXCIjMTA5OGFkXCIsXCIjMGM4NTk5XCIsXCIjMGI3Mjg1XCJdLHRlYWw6W1wiI2U2ZmNmNVwiLFwiI2MzZmFlOFwiLFwiIzk2ZjJkN1wiLFwiIzYzZTZiZVwiLFwiIzM4ZDlhOVwiLFwiIzIwYzk5N1wiLFwiIzEyYjg4NlwiLFwiIzBjYTY3OFwiLFwiIzA5OTI2OFwiLFwiIzA4N2Y1YlwiXSxncmVlbjpbXCIjZWJmYmVlXCIsXCIjZDNmOWQ4XCIsXCIjYjJmMmJiXCIsXCIjOGNlOTlhXCIsXCIjNjlkYjdjXCIsXCIjNTFjZjY2XCIsXCIjNDBjMDU3XCIsXCIjMzdiMjRkXCIsXCIjMmY5ZTQ0XCIsXCIjMmI4YTNlXCJdLGxpbWU6W1wiI2Y0ZmNlM1wiLFwiI2U5ZmFjOFwiLFwiI2Q4ZjVhMlwiLFwiI2MwZWI3NVwiLFwiI2E5ZTM0YlwiLFwiIzk0ZDgyZFwiLFwiIzgyYzkxZVwiLFwiIzc0YjgxNlwiLFwiIzY2YTgwZlwiLFwiIzVjOTQwZFwiXSx5ZWxsb3c6W1wiI2ZmZjlkYlwiLFwiI2ZmZjNiZlwiLFwiI2ZmZWM5OVwiLFwiI2ZmZTA2NlwiLFwiI2ZmZDQzYlwiLFwiI2ZjYzQxOVwiLFwiI2ZhYjAwNVwiLFwiI2Y1OWYwMFwiLFwiI2YwOGMwMFwiLFwiI2U2NzcwMFwiXSxvcmFuZ2U6W1wiI2ZmZjRlNlwiLFwiI2ZmZThjY1wiLFwiI2ZmZDhhOFwiLFwiI2ZmYzA3OFwiLFwiI2ZmYTk0ZFwiLFwiI2ZmOTIyYlwiLFwiI2ZkN2UxNFwiLFwiI2Y3NjcwN1wiLFwiI2U4NTkwY1wiLFwiI2Q5NDgwZlwiXSxncmF5OltcIiNmOGY5ZmFcIixcIiNmMWYzZjVcIixcIiNlOWVjZWZcIixcIiNkZWUyZTZcIixcIiNjZWQ0ZGFcIixcIiNhZGI1YmRcIixcIiM4NjhlOTZcIixcIiM0OTUwNTdcIixcIiMzNDNhNDBcIixcIiMyMTI1MjlcIl19O2V4cG9ydCB2YXIgZ3JheUNvbG9ycz1hbGxDb2xvcnMuZ3JheTt2YXIgREVGQVVMVF9CUklHSFRORVNTPTYsREVGQVVMVF9CUklHSFRORVNTX0RBUks9MjtleHBvcnQgdmFyIGdldFBhbGV0dGVGb3JCcmlnaHRuZXNzPWZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YSYmKGE9REVGQVVMVF9CUklHSFRORVNTKSx2b2lkIDA9PT1iJiYoYj1bXCJjeWFuXCIsXCJ5ZWxsb3dcIixcInBpbmtcIixcImdyYXBlXCIsXCJibHVlXCIsXCJsaW1lXCIsXCJ0ZWFsXCIsXCJyZWRcIixcInZpb2xldFwiLFwib3JhbmdlXCIsXCJpbmRpZ29cIixcImdyZWVuXCJdKTsvLyBzYW5pdHkgY2hlY2sgaW5kaWNlc1xudmFyIGM9TWF0aC5tYXgoMCxNYXRoLm1pbihhLGFsbENvbG9ycy5yZWQubGVuZ3RoLTEpKTsvLyBmaWx0ZXIgbm9uLXNlbnNpY2FsIGh1ZXNcbnJldHVybiBiLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYWxsQ29sb3JzW2FdJiZhbGxDb2xvcnNbYV1bY119KS5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGF9KX07dmFyIHByaW1hcnlIdWU9XCJjeWFuXCI7ZXhwb3J0IHZhciBjb2xvckh1ZXM9T2JqZWN0LmtleXMoYWxsQ29sb3JzKS5zb3J0KCk7ZXhwb3J0IHZhciB0ZXh0Q29sb3I9Z3JheUNvbG9yc1s3XTtleHBvcnQgZGVmYXVsdHtkZWZhdWx0OmFsbENvbG9yc1twcmltYXJ5SHVlXVs1XSxkYXJrOmFsbENvbG9yc1twcmltYXJ5SHVlXVs3XSxsaWdodDphbGxDb2xvcnNbcHJpbWFyeUh1ZV1bM10sZGlzYWJsZWQ6dGV4dENvbG9yLGxpZ2h0RGlzYWJsZWQ6Z3JheUNvbG9yc1szXSx0ZXh0OnRleHRDb2xvcixibGFjazpncmF5Q29sb3JzWzldLGRhcmtHcmF5OmdyYXlDb2xvcnNbOF0sbGlnaHRHcmF5OmdyYXlDb2xvcnNbM10sZ3JpZDpncmF5Q29sb3JzWzRdLGdyaWREYXJrOmdyYXlDb2xvcnNbOF0sbGFiZWw6dGV4dENvbG9yLHRpY2tMYWJlbDp0ZXh0Q29sb3IsZ3JheXM6Z3JheUNvbG9ycyxjYXRlZ29yaWVzOltdLmNvbmNhdChnZXRQYWxldHRlRm9yQnJpZ2h0bmVzcyhERUZBVUxUX0JSSUdIVE5FU1MpLGdldFBhbGV0dGVGb3JCcmlnaHRuZXNzKERFRkFVTFRfQlJJR0hUTkVTU19EQVJLKSl9OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1929\n')},2075:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('function Natural(context) {\n  this._context = context;\n}\n\nNatural.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        n = x.length;\n\n    if (n) {\n      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);\n      if (n === 2) {\n        this._context.lineTo(x[1], y[1]);\n      } else {\n        var px = controlPoints(x),\n            py = controlPoints(y);\n        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);\n        }\n      }\n    }\n\n    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n    this._x = this._y = null;\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\n// See https://www.particleincell.com/2012/bezier-splines/ for derivation.\nfunction controlPoints(x) {\n  var i,\n      n = x.length - 1,\n      m,\n      a = new Array(n),\n      b = new Array(n),\n      r = new Array(n);\n  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];\n  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];\n  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];\n  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];\n  a[n - 1] = r[n - 1] / b[n - 1];\n  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];\n  b[n - 1] = (x[n] + a[n - 1]) / 2;\n  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];\n  return [a, b];\n}\n\n/* harmony default export */ __webpack_exports__["a"] = (function(context) {\n  return new Natural(context);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA3NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL25hdHVyYWwuanM/YjA1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBOYXR1cmFsKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbk5hdHVyYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3ggPSBbXTtcbiAgICB0aGlzLl95ID0gW107XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gdGhpcy5feCxcbiAgICAgICAgeSA9IHRoaXMuX3ksXG4gICAgICAgIG4gPSB4Lmxlbmd0aDtcblxuICAgIGlmIChuKSB7XG4gICAgICB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeFswXSwgeVswXSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4WzBdLCB5WzBdKTtcbiAgICAgIGlmIChuID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHhbMV0sIHlbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHB4ID0gY29udHJvbFBvaW50cyh4KSxcbiAgICAgICAgICAgIHB5ID0gY29udHJvbFBvaW50cyh5KTtcbiAgICAgICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDE7IGkxIDwgbjsgKytpMCwgKytpMSkge1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhweFswXVtpMF0sIHB5WzBdW2kwXSwgcHhbMV1baTBdLCBweVsxXVtpMF0sIHhbaTFdLCB5W2kxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiBuID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBudWxsO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuX3gucHVzaCgreCk7XG4gICAgdGhpcy5feS5wdXNoKCt5KTtcbiAgfVxufTtcblxuLy8gU2VlIGh0dHBzOi8vd3d3LnBhcnRpY2xlaW5jZWxsLmNvbS8yMDEyL2Jlemllci1zcGxpbmVzLyBmb3IgZGVyaXZhdGlvbi5cbmZ1bmN0aW9uIGNvbnRyb2xQb2ludHMoeCkge1xuICB2YXIgaSxcbiAgICAgIG4gPSB4Lmxlbmd0aCAtIDEsXG4gICAgICBtLFxuICAgICAgYSA9IG5ldyBBcnJheShuKSxcbiAgICAgIGIgPSBuZXcgQXJyYXkobiksXG4gICAgICByID0gbmV3IEFycmF5KG4pO1xuICBhWzBdID0gMCwgYlswXSA9IDIsIHJbMF0gPSB4WzBdICsgMiAqIHhbMV07XG4gIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgKytpKSBhW2ldID0gMSwgYltpXSA9IDQsIHJbaV0gPSA0ICogeFtpXSArIDIgKiB4W2kgKyAxXTtcbiAgYVtuIC0gMV0gPSAyLCBiW24gLSAxXSA9IDcsIHJbbiAtIDFdID0gOCAqIHhbbiAtIDFdICsgeFtuXTtcbiAgZm9yIChpID0gMTsgaSA8IG47ICsraSkgbSA9IGFbaV0gLyBiW2kgLSAxXSwgYltpXSAtPSBtLCByW2ldIC09IG0gKiByW2kgLSAxXTtcbiAgYVtuIC0gMV0gPSByW24gLSAxXSAvIGJbbiAtIDFdO1xuICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyAtLWkpIGFbaV0gPSAocltpXSAtIGFbaSArIDFdKSAvIGJbaV07XG4gIGJbbiAtIDFdID0gKHhbbl0gKyBhW24gLSAxXSkgLyAyO1xuICBmb3IgKGkgPSAwOyBpIDwgbiAtIDE7ICsraSkgYltpXSA9IDIgKiB4W2kgKyAxXSAtIGFbaSArIDFdO1xuICByZXR1cm4gW2EsIGJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTmF0dXJhbChjb250ZXh0KTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2075\n')},2077:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _vx_curve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1871);\n/* harmony import */ var _vx_curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1857);\n/* harmony import */ var _vx_curve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1877);\n/* harmony import */ var _vx_curve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2075);\n\n/* harmony default export */ __webpack_exports__["a"] = ({\n  linear: _vx_curve__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"],\n  cardinal: _vx_curve__WEBPACK_IMPORTED_MODULE_1__[/* default */ "b"],\n  monotoneX: _vx_curve__WEBPACK_IMPORTED_MODULE_2__[/* monotoneX */ "a"],\n  monotoneY: _vx_curve__WEBPACK_IMPORTED_MODULE_2__[/* monotoneY */ "b"],\n  natural: _vx_curve__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA3Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvZXNtL3V0aWxzL2ludGVycG9sYXRvckxvb2t1cC5qcz83YzMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGN1cnZlQ2FyZGluYWwsIGN1cnZlTGluZWFyLCBjdXJ2ZU1vbm90b25lWCwgY3VydmVNb25vdG9uZVksIGN1cnZlTmF0dXJhbCB9IGZyb20gJ0B2eC9jdXJ2ZSc7XG5leHBvcnQgZGVmYXVsdCB7XG4gIGxpbmVhcjogY3VydmVMaW5lYXIsXG4gIGNhcmRpbmFsOiBjdXJ2ZUNhcmRpbmFsLFxuICBtb25vdG9uZVg6IGN1cnZlTW9ub3RvbmVYLFxuICBtb25vdG9uZVk6IGN1cnZlTW9ub3RvbmVZLFxuICBuYXR1cmFsOiBjdXJ2ZU5hdHVyYWxcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2077\n')},2120:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return findClosestDatum; });\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(324);\n/* harmony import */ var _vx_event_build_localPoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2105);\n/* harmony import */ var _vx_event_build_localPoint__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_vx_event_build_localPoint__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction findClosestDatum(_ref) {\n  var data = _ref.data,\n      getX = _ref.getX,\n      xScale = _ref.xScale,\n      event = _ref.event,\n      _ref$marginLeft = _ref.marginLeft,\n      marginLeft = _ref$marginLeft === void 0 ? 0 : _ref$marginLeft;\n  if (!event || !event.target || !event.target.ownerSVGElement) return null;\n  var bisect = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisector"])(getX).left; // if the g element has a transform we need to be in g coords not svg coords\n\n  var svgCoords = _vx_event_build_localPoint__WEBPACK_IMPORTED_MODULE_1___default()(event.target.ownerSVGElement, event);\n  var mouseX = svgCoords.x - marginLeft;\n  var isOrdinalScale = typeof xScale.invert !== \'function\';\n  var d;\n\n  if (isOrdinalScale) {\n    // Ordinal scales don\'t have an invert function so we do it maually\n    var xDomain = xScale.domain();\n    var scaledXValues = xDomain.map(function (val) {\n      return xScale(val);\n    });\n    var index = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["bisectLeft"])(scaledXValues, mouseX);\n    var d0 = data[index - 1];\n    var d1 = data[index];\n    d = d0 || d1;\n  } else {\n    var dataX = xScale.invert(mouseX);\n\n    var _index = bisect(data, dataX, 0);\n\n    var _d = data[_index - 1];\n\n    var _d2 = data[_index] || {};\n\n    d = !_d || Math.abs(dataX - getX(_d)) > Math.abs(dataX - getX(_d2)) ? _d2 : _d;\n  }\n\n  return d;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEyMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvZXNtL3V0aWxzL2ZpbmRDbG9zZXN0RGF0dW0uanM/ZWE4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBiaXNlY3RvciwgYmlzZWN0TGVmdCBhcyBkM0Jpc2VjdExlZnQgfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgbG9jYWxQb2ludCBmcm9tICdAdngvZXZlbnQvYnVpbGQvbG9jYWxQb2ludCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaW5kQ2xvc2VzdERhdHVtKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBnZXRYID0gX3JlZi5nZXRYLFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICBldmVudCA9IF9yZWYuZXZlbnQsXG4gICAgICBfcmVmJG1hcmdpbkxlZnQgPSBfcmVmLm1hcmdpbkxlZnQsXG4gICAgICBtYXJnaW5MZWZ0ID0gX3JlZiRtYXJnaW5MZWZ0ID09PSB2b2lkIDAgPyAwIDogX3JlZiRtYXJnaW5MZWZ0O1xuICBpZiAoIWV2ZW50IHx8ICFldmVudC50YXJnZXQgfHwgIWV2ZW50LnRhcmdldC5vd25lclNWR0VsZW1lbnQpIHJldHVybiBudWxsO1xuICB2YXIgYmlzZWN0ID0gYmlzZWN0b3IoZ2V0WCkubGVmdDsgLy8gaWYgdGhlIGcgZWxlbWVudCBoYXMgYSB0cmFuc2Zvcm0gd2UgbmVlZCB0byBiZSBpbiBnIGNvb3JkcyBub3Qgc3ZnIGNvb3Jkc1xuXG4gIHZhciBzdmdDb29yZHMgPSBsb2NhbFBvaW50KGV2ZW50LnRhcmdldC5vd25lclNWR0VsZW1lbnQsIGV2ZW50KTtcbiAgdmFyIG1vdXNlWCA9IHN2Z0Nvb3Jkcy54IC0gbWFyZ2luTGVmdDtcbiAgdmFyIGlzT3JkaW5hbFNjYWxlID0gdHlwZW9mIHhTY2FsZS5pbnZlcnQgIT09ICdmdW5jdGlvbic7XG4gIHZhciBkO1xuXG4gIGlmIChpc09yZGluYWxTY2FsZSkge1xuICAgIC8vIE9yZGluYWwgc2NhbGVzIGRvbid0IGhhdmUgYW4gaW52ZXJ0IGZ1bmN0aW9uIHNvIHdlIGRvIGl0IG1hdWFsbHlcbiAgICB2YXIgeERvbWFpbiA9IHhTY2FsZS5kb21haW4oKTtcbiAgICB2YXIgc2NhbGVkWFZhbHVlcyA9IHhEb21haW4ubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiB4U2NhbGUodmFsKTtcbiAgICB9KTtcbiAgICB2YXIgaW5kZXggPSBkM0Jpc2VjdExlZnQoc2NhbGVkWFZhbHVlcywgbW91c2VYKTtcbiAgICB2YXIgZDAgPSBkYXRhW2luZGV4IC0gMV07XG4gICAgdmFyIGQxID0gZGF0YVtpbmRleF07XG4gICAgZCA9IGQwIHx8IGQxO1xuICB9IGVsc2Uge1xuICAgIHZhciBkYXRhWCA9IHhTY2FsZS5pbnZlcnQobW91c2VYKTtcblxuICAgIHZhciBfaW5kZXggPSBiaXNlY3QoZGF0YSwgZGF0YVgsIDApO1xuXG4gICAgdmFyIF9kID0gZGF0YVtfaW5kZXggLSAxXTtcblxuICAgIHZhciBfZDIgPSBkYXRhW19pbmRleF0gfHwge307XG5cbiAgICBkID0gIV9kIHx8IE1hdGguYWJzKGRhdGFYIC0gZ2V0WChfZCkpID4gTWF0aC5hYnMoZGF0YVggLSBnZXRYKF9kMikpID8gX2QyIDogX2Q7XG4gIH1cblxuICByZXR1cm4gZDtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2120\n')},2470:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FocusBlurHandler; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\nfunction _inheritsLoose(a,b){a.prototype=Object.create(b.prototype),a.prototype.constructor=a,a.__proto__=b}function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return a}var propTypes={children:prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node,onFocus:prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,onBlur:prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func},defaultProps={children:null,onFocus:null,onBlur:null},FocusBlurHandler=/*#__PURE__*/function(a){function b(b){var c;return c=a.call(this,b)||this,c.handleOnClick=c.handleOnClick.bind(_assertThisInitialized(_assertThisInitialized(c))),c}_inheritsLoose(b,a);var c=b.prototype;return c.handleOnClick=function b(a){a.preventDefault()},c.render=function e(){var a=this.props,b=a.children,c=a.onFocus,d=a.onBlur;return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a",{// eslint-disable-line jsx-a11y/no-static-element-interactions, jsx-a11y/anchor-is-valid\nxlinkHref:(d||c)&&"#",role:"presentation",onBlur:d,onFocus:c,onClick:this.handleOnClick},b)},b}(react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent);FocusBlurHandler.propTypes=propTypes,FocusBlurHandler.defaultProps=defaultProps,FocusBlurHandler.displayName="FocusBlurHandler";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ3MC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvc2hhcmVkL2VzbS9jb21wb25lbnRzL0ZvY3VzQmx1ckhhbmRsZXIuanM/MWQ5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShhLGIpe2EucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoYi5wcm90b3R5cGUpLGEucHJvdG90eXBlLmNvbnN0cnVjdG9yPWEsYS5fX3Byb3RvX189Yn1mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGEpe2lmKHZvaWQgMD09PWEpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiBhfWltcG9ydCBSZWFjdCBmcm9tXCJyZWFjdFwiO2ltcG9ydCBQcm9wVHlwZXMgZnJvbVwicHJvcC10eXBlc1wiO3ZhciBwcm9wVHlwZXM9e2NoaWxkcmVuOlByb3BUeXBlcy5ub2RlLG9uRm9jdXM6UHJvcFR5cGVzLmZ1bmMsb25CbHVyOlByb3BUeXBlcy5mdW5jfSxkZWZhdWx0UHJvcHM9e2NoaWxkcmVuOm51bGwsb25Gb2N1czpudWxsLG9uQmx1cjpudWxsfSxGb2N1c0JsdXJIYW5kbGVyPS8qI19fUFVSRV9fKi9mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIpe3ZhciBjO3JldHVybiBjPWEuY2FsbCh0aGlzLGIpfHx0aGlzLGMuaGFuZGxlT25DbGljaz1jLmhhbmRsZU9uQ2xpY2suYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoYykpKSxjfV9pbmhlcml0c0xvb3NlKGIsYSk7dmFyIGM9Yi5wcm90b3R5cGU7cmV0dXJuIGMuaGFuZGxlT25DbGljaz1mdW5jdGlvbiBiKGEpe2EucHJldmVudERlZmF1bHQoKX0sYy5yZW5kZXI9ZnVuY3Rpb24gZSgpe3ZhciBhPXRoaXMucHJvcHMsYj1hLmNoaWxkcmVuLGM9YS5vbkZvY3VzLGQ9YS5vbkJsdXI7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsey8vIGVzbGludC1kaXNhYmxlLWxpbmUganN4LWExMXkvbm8tc3RhdGljLWVsZW1lbnQtaW50ZXJhY3Rpb25zLCBqc3gtYTExeS9hbmNob3ItaXMtdmFsaWRcbnhsaW5rSHJlZjooZHx8YykmJlwiI1wiLHJvbGU6XCJwcmVzZW50YXRpb25cIixvbkJsdXI6ZCxvbkZvY3VzOmMsb25DbGljazp0aGlzLmhhbmRsZU9uQ2xpY2t9LGIpfSxifShSZWFjdC5QdXJlQ29tcG9uZW50KTtleHBvcnR7Rm9jdXNCbHVySGFuZGxlciBhcyBkZWZhdWx0fTtGb2N1c0JsdXJIYW5kbGVyLnByb3BUeXBlcz1wcm9wVHlwZXMsRm9jdXNCbHVySGFuZGxlci5kZWZhdWx0UHJvcHM9ZGVmYXVsdFByb3BzLEZvY3VzQmx1ckhhbmRsZXIuZGlzcGxheU5hbWU9XCJGb2N1c0JsdXJIYW5kbGVyXCI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2470\n')},2481:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// UNUSED EXPORTS: CONTAINER_TRIGGER, SERIES_TRIGGER, VORONOI_TRIGGER, propTypes, defaultProps\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(2);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(17);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/classnames/index.js\nvar classnames = __webpack_require__(183);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/arc.js\nvar src_arc = __webpack_require__(2149);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/pie.js + 2 modules\nvar pie = __webpack_require__(2228);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/line.js\nvar line = __webpack_require__(1924);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/lineRadial.js\nvar lineRadial = __webpack_require__(1925);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/area.js\nvar src_area = __webpack_require__(2102);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/stack.js\nvar stack = __webpack_require__(2151);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/order/ascending.js\nvar ascending = __webpack_require__(1926);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/order/descending.js\nvar descending = __webpack_require__(2153);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/order/insideOut.js\nvar insideOut = __webpack_require__(2154);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/order/none.js\nvar none = __webpack_require__(1872);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/order/reverse.js\nvar order_reverse = __webpack_require__(2155);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/offset/expand.js\nvar expand = __webpack_require__(2156);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/offset/diverging.js\nvar diverging = __webpack_require__(2157);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/offset/none.js\nvar offset_none = __webpack_require__(1873);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/offset/silhouette.js\nvar silhouette = __webpack_require__(2158);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/offset/wiggle.js\nvar wiggle = __webpack_require__(2159);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/link/index.js\nvar src_link = __webpack_require__(1927);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/grid/node_modules/@vx/group/dist/vx-group.es.js\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction Group(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      transform = _ref.transform,\n      className = _ref.className,\n      children = _ref.children,\n      restProps = objectWithoutProperties(_ref, ['top', 'left', 'transform', 'className', 'children']);\n\n  return react_default.a.createElement(\n    'g',\n    _extends({\n      className: classnames_default()('vx-group', className),\n      transform: transform || 'translate(' + left + ', ' + top + ')'\n    }, restProps),\n    children\n  );\n}\n\n\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@vx/point/dist/vx-point.es.js\nvar vx_point_es = __webpack_require__(1820);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-shape/src/curve/linear.js\nvar linear = __webpack_require__(1871);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-path/src/path.js\nvar src_path = __webpack_require__(2459);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/grid/node_modules/@vx/shape/dist/vx-shape.es.js\n\n\n\n\n\n\n\n\n\nfunction callOrValue(maybeFn, data) {\n  if (typeof maybeFn === 'function') {\n    return maybeFn(data);\n  }\n  return maybeFn;\n}\n\nfunction additionalProps(restProps, data) {\n  return Object.keys(restProps).reduce(function (ret, cur) {\n    ret[cur] = callOrValue(restProps[cur], data);\n    return ret;\n  }, {});\n}\n\nvar vx_shape_es_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar vx_shape_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nArc.propTypes = {\n  className: prop_types_default.a.string,\n  data: prop_types_default.a.any,\n  centroid: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  innerRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  outerRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  cornerRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  startAngle: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  endAngle: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  padAngle: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  padRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number])\n};\n\nfunction Arc(_ref) {\n  var className = _ref.className,\n      data = _ref.data,\n      centroid = _ref.centroid,\n      innerRadius = _ref.innerRadius,\n      outerRadius = _ref.outerRadius,\n      cornerRadius = _ref.cornerRadius,\n      startAngle = _ref.startAngle,\n      endAngle = _ref.endAngle,\n      padAngle = _ref.padAngle,\n      padRadius = _ref.padRadius,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'data', 'centroid', 'innerRadius', 'outerRadius', 'cornerRadius', 'startAngle', 'endAngle', 'padAngle', 'padRadius']);\n\n  var arc$$1 = Object(src_arc[\"a\" /* default */])();\n  if (centroid) arc$$1.centroid(centroid);\n  if (innerRadius) arc$$1.innerRadius(innerRadius);\n  if (outerRadius) arc$$1.outerRadius(outerRadius);\n  if (cornerRadius) arc$$1.cornerRadius(cornerRadius);\n  if (startAngle) arc$$1.startAngle(startAngle);\n  if (endAngle) arc$$1.endAngle(endAngle);\n  if (padAngle) arc$$1.padAngle(padAngle);\n  if (padRadius) arc$$1.padRadius(padRadius);\n  return react_default.a.createElement('path', vx_shape_es_extends({ className: classnames_default()('vx-arc', className), d: arc$$1(data) }, additionalProps(restProps, data)));\n}\n\nPie.propTypes = {\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  data: prop_types_default.a.array,\n  centroid: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  innerRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  outerRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  cornerRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  startAngle: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  endAngle: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  padAngle: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  padRadius: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  pieSort: prop_types_default.a.func,\n  pieSortValues: prop_types_default.a.func,\n  pieValue: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  children: prop_types_default.a.func\n};\n\nfunction Pie(_ref) {\n  var _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      data = _ref.data,\n      centroid = _ref.centroid,\n      _ref$innerRadius = _ref.innerRadius,\n      innerRadius = _ref$innerRadius === undefined ? 0 : _ref$innerRadius,\n      outerRadius = _ref.outerRadius,\n      cornerRadius = _ref.cornerRadius,\n      _ref$startAngle = _ref.startAngle,\n      startAngle = _ref$startAngle === undefined ? 0 : _ref$startAngle,\n      endAngle = _ref.endAngle,\n      padAngle = _ref.padAngle,\n      padRadius = _ref.padRadius,\n      pieSort = _ref.pieSort,\n      pieSortValues = _ref.pieSortValues,\n      pieValue = _ref.pieValue,\n      children = _ref.children,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'top', 'left', 'data', 'centroid', 'innerRadius', 'outerRadius', 'cornerRadius', 'startAngle', 'endAngle', 'padAngle', 'padRadius', 'pieSort', 'pieSortValues', 'pieValue', 'children']);\n\n  var path$$1 = Object(src_arc[\"a\" /* default */])();\n  path$$1.innerRadius(innerRadius);\n  if (outerRadius) path$$1.outerRadius(outerRadius);\n  if (cornerRadius) path$$1.cornerRadius(cornerRadius);\n  if (padRadius) path$$1.padRadius(padRadius);\n  var pie$$1 = Object(pie[\"a\" /* default */])();\n  if (pieSort !== undefined) pie$$1.sort(pieSort);\n  if (pieSortValues !== undefined) pie$$1.sortValues(pieSortValues);\n  if (pieValue) pie$$1.value(pieValue);\n  if (padAngle != null) pie$$1.padAngle(padAngle);\n  if (startAngle != null) pie$$1.startAngle(startAngle);\n  if (endAngle != null) pie$$1.endAngle(endAngle);\n  var arcs = pie$$1(data);\n  var renderFunctionArg = {\n    arcs: arcs,\n    generatePathProps: function generatePathProps(arc$$1, index) {\n      return vx_shape_es_extends({\n        className: classnames_default()('vx-pie-arc', className),\n        d: path$$1(arc$$1)\n      }, additionalProps(restProps, vx_shape_es_extends({}, arc$$1, {\n        index: index,\n        centroid: centroid ? path$$1.centroid(arc$$1) : undefined\n      })));\n    },\n    generateCentroid: function generateCentroid(arc$$1) {\n      return centroid && centroid(path$$1.centroid(arc$$1), arc$$1);\n    }\n  };\n  return react_default.a.createElement(\n    Group,\n    { className: 'vx-pie-arcs-group', top: top, left: left },\n    children ? children(renderFunctionArg) : arcs.map(function (arc$$1, i) {\n      var pathProps = renderFunctionArg.generatePathProps(arc$$1, i);\n      return react_default.a.createElement(\n        'g',\n        { key: 'pie-arc-' + i },\n        react_default.a.createElement('path', pathProps),\n        renderFunctionArg.generateCentroid(arc$$1)\n      );\n    })\n  );\n}\n\nLine.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction Line(_ref) {\n  var _ref$from = _ref.from,\n      from = _ref$from === undefined ? new vx_point_es[\"Point\"]({ x: 0, y: 0 }) : _ref$from,\n      _ref$to = _ref.to,\n      to = _ref$to === undefined ? new vx_point_es[\"Point\"]({ x: 1, y: 1 }) : _ref$to,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 1 : _ref$strokeWidth,\n      _ref$strokeDasharray = _ref.strokeDasharray,\n      strokeDasharray = _ref$strokeDasharray === undefined ? '' : _ref$strokeDasharray,\n      _ref$transform = _ref.transform,\n      transform = _ref$transform === undefined ? '' : _ref$transform,\n      _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      data = _ref.data,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['from', 'to', 'stroke', 'strokeWidth', 'strokeDasharray', 'transform', 'className', 'data', 'innerRef']);\n\n  return react_default.a.createElement('line', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-line', className),\n    x1: from.x,\n    y1: from.y,\n    x2: to.x,\n    y2: to.y,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    transform: transform\n  }, additionalProps(restProps, data)));\n}\n\nLinePath.propTypes = {\n  innerRef: prop_types_default.a.func,\n  xScale: prop_types_default.a.func,\n  yScale: prop_types_default.a.func,\n  data: prop_types_default.a.array,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  defined: prop_types_default.a.func,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  glyph: prop_types_default.a.func,\n  curve: prop_types_default.a.func\n};\n\nfunction LinePath(_ref) {\n  var children = _ref.children,\n      data = _ref.data,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      x = _ref.x,\n      y = _ref.y,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'steelblue' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$strokeDasharray = _ref.strokeDasharray,\n      strokeDasharray = _ref$strokeDasharray === undefined ? '' : _ref$strokeDasharray,\n      _ref$strokeDashoffset = _ref.strokeDashoffset,\n      strokeDashoffset = _ref$strokeDashoffset === undefined ? 0 : _ref$strokeDashoffset,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'none' : _ref$fill,\n      _ref$curve = _ref.curve,\n      curve = _ref$curve === undefined ? linear[\"a\" /* default */] : _ref$curve,\n      glyph = _ref.glyph,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['children', 'data', 'xScale', 'yScale', 'x', 'y', 'defined', 'className', 'stroke', 'strokeWidth', 'strokeDasharray', 'strokeDashoffset', 'fill', 'curve', 'glyph', 'innerRef']);\n\n  var path$$1 = Object(line[\"a\" /* default */])().x(function () {\n    return xScale(x.apply(undefined, arguments));\n  }).y(function () {\n    return yScale(y.apply(undefined, arguments));\n  }).defined(defined).curve(curve);\n  if (children) return children({ path: path$$1 });\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-linepath', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset,\n      fill: fill\n    }, additionalProps(restProps, data))),\n    glyph && react_default.a.createElement(\n      'g',\n      { className: 'vx-linepath-glyphs' },\n      data.map(glyph)\n    )\n  );\n}\n\nLineRadial.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction LineRadial(_ref) {\n  var _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      angle = _ref.angle,\n      radius = _ref.radius,\n      defined = _ref.defined,\n      curve = _ref.curve,\n      data = _ref.data,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'angle', 'radius', 'defined', 'curve', 'data', 'innerRef']);\n\n  var path$$1 = Object(lineRadial[\"a\" /* default */])();\n  if (angle) path$$1.angle(angle);\n  if (radius) path$$1.radius(radius);\n  if (defined) path$$1.defined(defined);\n  if (curve) path$$1.curve(curve);\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-line-radial', className),\n      d: path$$1(data)\n    }, additionalProps(restProps, data)))\n  );\n}\n\nArea.propTypes = {\n  x: prop_types_default.a.func,\n  x0: prop_types_default.a.func,\n  x1: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  y0: prop_types_default.a.func,\n  y1: prop_types_default.a.func,\n  xScale: prop_types_default.a.func,\n  yScale: prop_types_default.a.func,\n  data: prop_types_default.a.array,\n  defined: prop_types_default.a.func,\n  className: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.bool, prop_types_default.a.object, prop_types_default.a.array]),\n  innerRef: prop_types_default.a.func,\n  strokeDasharray: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  stroke: prop_types_default.a.string,\n  fill: prop_types_default.a.string,\n  curve: prop_types_default.a.func\n};\n\nfunction Area(_ref) {\n  var children = _ref.children,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y = _ref.y,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      _ref$data = _ref.data,\n      data = _ref$data === undefined ? [] : _ref$data,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      strokeDasharray = _ref.strokeDasharray,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,\n      curve = _ref.curve,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['children', 'x', 'x0', 'x1', 'y', 'y0', 'y1', 'xScale', 'yScale', 'data', 'defined', 'className', 'strokeDasharray', 'strokeWidth', 'stroke', 'fill', 'curve', 'innerRef']);\n\n  var path$$1 = Object(src_area[\"a\" /* default */])();\n  if (x) path$$1.x(function () {\n    return xScale(x.apply(undefined, arguments));\n  });\n  if (x0) path$$1.x0(function () {\n    return xScale(x0.apply(undefined, arguments));\n  });\n  if (x1) path$$1.x1(function () {\n    return xScale(x1.apply(undefined, arguments));\n  });\n  if (y) path$$1.y(function () {\n    return yScale(y.apply(undefined, arguments));\n  });\n  if (y0) path$$1.y0(function () {\n    return yScale(y0.apply(undefined, arguments));\n  });\n  if (y1) path$$1.y1(function () {\n    return yScale(y1.apply(undefined, arguments));\n  });\n  if (defined) path$$1.defined(defined);\n  if (curve) path$$1.curve(curve);\n  if (children) return children({ path: path$$1 });\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-area', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill\n    }, additionalProps(restProps, data)))\n  );\n}\n\nAreaClosed.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction AreaClosed(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      y0 = _ref.y0,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      data = _ref.data,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      strokeDasharray = _ref.strokeDasharray,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,\n      curve = _ref.curve,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['x', 'y', 'y0', 'xScale', 'yScale', 'data', 'defined', 'className', 'strokeDasharray', 'strokeWidth', 'stroke', 'fill', 'curve', 'innerRef']);\n\n  var path$$1 = Object(src_area[\"a\" /* default */])().x(function () {\n    return xScale(x.apply(undefined, arguments));\n  }).y0(y0 || yScale.range()[0]).y1(function () {\n    return yScale(y.apply(undefined, arguments));\n  }).defined(defined);\n  if (curve) path$$1.curve(curve);\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-area-closed', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill\n    }, additionalProps(restProps, data)))\n  );\n}\n\nAreaStack.propTypes = {\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  keys: prop_types_default.a.array,\n  data: prop_types_default.a.array,\n  curve: prop_types_default.a.func,\n  defined: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.bool]),\n  x: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  x0: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  x1: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  y: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  y0: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  y1: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  glyph: prop_types_default.a.bool,\n  reverse: prop_types_default.a.bool\n};\n\nfunction AreaStack(_ref) {\n  var className = _ref.className,\n      keys = _ref.keys,\n      data = _ref.data,\n      curve = _ref.curve,\n      defined = _ref.defined,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      glyph = _ref.glyph,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === undefined ? false : _ref$reverse,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'keys', 'data', 'curve', 'defined', 'x', 'x0', 'x1', 'y0', 'y1', 'glyph', 'reverse']);\n\n  var stack$$1 = Object(stack[\"a\" /* default */])();\n  if (keys) stack$$1.keys(keys);\n\n  var path$$1 = Object(src_area[\"a\" /* default */])();\n  if (x) path$$1.x(x);\n  if (x0) path$$1.x0(x0);\n  if (x1) path$$1.x1(x1);\n  if (y0) path$$1.y0(y0);\n  if (y1) path$$1.y1(y1);\n  if (curve) path$$1.curve(curve);\n  if (defined) path$$1.defined(defined);\n\n  var seriesData = stack$$1(data);\n  if (reverse) seriesData.reverse();\n\n  return react_default.a.createElement(\n    'g',\n    null,\n    seriesData.map(function (series, i) {\n      return react_default.a.createElement('path', vx_shape_es_extends({\n        className: classnames_default()('vx-area-stack', className),\n        key: 'area-stack-' + i + '-' + (series.key || ''),\n        d: path$$1(series)\n      }, additionalProps(restProps, {\n        datum: series[i],\n        index: i,\n        series: series\n      })));\n    }),\n    !!glyph && react_default.a.createElement(\n      'g',\n      { className: 'vx-area-stack-glyphs' },\n      data.map(glyph)\n    )\n  );\n}\n\nBar.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction Bar(_ref) {\n  var className = _ref.className,\n      innerRef = _ref.innerRef,\n      data = _ref.data,\n      _ref$x = _ref.x,\n      x = _ref$x === undefined ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === undefined ? 0 : _ref$y,\n      width = _ref.width,\n      height = _ref.height,\n      rx = _ref.rx,\n      ry = _ref.ry,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'steelblue' : _ref$fill,\n      fillOpacity = _ref.fillOpacity,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      strokeLinecap = _ref.strokeLinecap,\n      strokeLinejoin = _ref.strokeLinejoin,\n      strokeMiterlimit = _ref.strokeMiterlimit,\n      strokeOpacity = _ref.strokeOpacity,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'innerRef', 'data', 'x', 'y', 'width', 'height', 'rx', 'ry', 'fill', 'fillOpacity', 'stroke', 'strokeWidth', 'strokeDasharray', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'strokeOpacity']);\n\n  return react_default.a.createElement('rect', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-bar', className),\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    rx: rx,\n    ry: ry,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    strokeLinecap: strokeLinecap,\n    strokeLinejoin: strokeLinejoin,\n    strokeMiterlimit: strokeMiterlimit,\n    strokeOpacity: strokeOpacity\n  }, additionalProps(restProps, data)));\n}\n\nBarGroup.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  x0: prop_types_default.a.func.isRequired,\n  x0Scale: prop_types_default.a.func.isRequired,\n  x1Scale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  height: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nfunction BarGroup(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      x0 = _ref.x0,\n      x0Scale = _ref.x0Scale,\n      x1Scale = _ref.x1Scale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      height = _ref.height,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'x0', 'x0Scale', 'x1Scale', 'yScale', 'zScale', 'keys', 'height']);\n\n  var format = x0Scale.tickFormat ? x0Scale.tickFormat() : function (d) {\n    return d;\n  };\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-bar-group', className), top: top, left: left },\n    data && data.map(function (d, i) {\n      return react_default.a.createElement(\n        Group,\n        { key: 'bar-group-' + i + '-' + x0(d), left: x0Scale(x0(d)) },\n        keys && keys.map(function (key, j) {\n          var value = d[key];\n          return react_default.a.createElement(Bar, vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + j + '-' + value + '-' + key,\n            x: x1Scale(key),\n            y: yScale(value),\n            width: x1Scale.bandwidth(),\n            height: height - yScale(value),\n            fill: zScale(key),\n            data: {\n              key: key,\n              value: value,\n              x: format(x0(d)),\n              data: d\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarGroupHorizontal.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  y0: prop_types_default.a.func.isRequired,\n  y0Scale: prop_types_default.a.func.isRequired,\n  y1Scale: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  width: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nfunction BarGroupHorizontal(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      y0 = _ref.y0,\n      y0Scale = _ref.y0Scale,\n      y1Scale = _ref.y1Scale,\n      xScale = _ref.xScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      width = _ref.width,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'y0', 'y0Scale', 'y1Scale', 'xScale', 'zScale', 'keys', 'width']);\n\n  var format = y0Scale.tickFormat ? y0Scale.tickFormat() : function (d) {\n    return d;\n  };\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-bar-group-horizontal', className), top: top, left: left },\n    data && data.map(function (d, i) {\n      return react_default.a.createElement(\n        Group,\n        { key: 'bar-group-' + i + '-' + y0(d), top: y0Scale(y0(d)) },\n        keys && keys.map(function (key, j) {\n          var value = d[key];\n          return react_default.a.createElement(Bar, vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + j + '-' + value + '-' + key,\n            x: 0,\n            y: y1Scale(key),\n            width: width - xScale(value),\n            height: y1Scale.bandwidth(),\n            fill: zScale(key),\n            data: {\n              key: key,\n              value: value,\n              y: format(y0(d)),\n              data: d\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nfunction objHasMethod(obj, funcName) {\n  return !!obj[funcName] && typeof obj[funcName] === 'function';\n}\n\nBarStack.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  x: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  width: prop_types_default.a.number,\n  height: prop_types_default.a.number\n};\n\nfunction BarStack(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      x = _ref.x,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      width = _ref.width,\n      height = _ref.height,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'x', 'xScale', 'yScale', 'zScale', 'keys', 'width', 'height']);\n\n  var series = Object(stack[\"a\" /* default */])().keys(keys)(data);\n  var format = xScale.tickFormat ? xScale.tickFormat() : function (d) {\n    return d;\n  };\n  var xRange = xScale.range();\n  var xDomain = xScale.domain();\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-bar-stack', className), top: top, left: left },\n    series && series.map(function (s, i) {\n      return react_default.a.createElement(\n        Group,\n        { key: 'vx-bar-stack-' + i },\n        s.map(function (d, ii) {\n          var barHeight = yScale(d[0]) - yScale(d[1]);\n          var barWidth = width || (objHasMethod(xScale, 'bandwidth') ? xScale.bandwidth() : Math.abs(xRange[xRange.length - 1] - xRange[0]) / xDomain.length);\n\n          var barX = objHasMethod(xScale, 'bandwidth') ? xScale(x(d.data)) : xScale(x(d.data)) - barWidth / 2;\n          return react_default.a.createElement(Bar, vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + ii + '-' + s.key,\n            x: barX,\n            y: yScale(d[1]),\n            width: barWidth,\n            height: barHeight,\n            fill: zScale(s.key),\n            data: {\n              paddingInner: objHasMethod(xScale, 'paddingInner') && xScale.paddingInner(),\n              paddingOuter: objHasMethod(xScale, 'paddingOuter') && xScale.paddingOuter(),\n              step: objHasMethod(xScale, 'step') && xScale.step(),\n              key: s.key,\n              value: d[1],\n              height: barHeight,\n              width: barWidth,\n              x: x(d.data),\n              xFormatted: format(x(d.data)),\n              data: d.data\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarStackHorizontal.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  y: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  width: prop_types_default.a.number,\n  height: prop_types_default.a.number\n};\n\nfunction BarStackHorizontal(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      y = _ref.y,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      width = _ref.width,\n      height = _ref.height,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'y', 'xScale', 'yScale', 'zScale', 'keys', 'width', 'height']);\n\n  var series = Object(stack[\"a\" /* default */])().keys(keys)(data);\n  var format = yScale.tickFormat ? yScale.tickFormat() : function (d) {\n    return d;\n  };\n  var yRange = yScale.range();\n  var yDomain = yScale.domain();\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-bar-stack-horizontal', className), top: top, left: left },\n    series && series.map(function (s, i) {\n      return react_default.a.createElement(\n        Group,\n        { key: 'vx-bar-stack-horizontal-' + i },\n        s.map(function (d, ii) {\n          var barWidth = xScale(d[1]) - xScale(d[0]);\n          var barHeight = width || (objHasMethod(yScale, 'bandwidth') ? yScale.bandwidth() : Math.abs(yRange[yRange.length - 1] - yRange[0]) / yDomain.length);\n\n          var barY = objHasMethod(yScale, 'bandwidth') ? yScale(y(d.data)) : yScale(y(d.data)) - barHeight / 2;\n          return react_default.a.createElement(Bar, vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + ii + '-' + s.key,\n            x: xScale(d[0]),\n            y: barY,\n            width: barWidth,\n            height: barHeight,\n            fill: zScale(s.key),\n            data: {\n              paddingInner: objHasMethod(yScale, 'paddingInner') && yScale.paddingInner(),\n              paddingOuter: objHasMethod(yScale, 'paddingOuter') && yScale.paddingOuter(),\n              step: objHasMethod(yScale, 'step') && yScale.step(),\n              key: s.key,\n              value: d[0],\n              height: barHeight,\n              width: barWidth,\n              y: y(d.data),\n              yFormatted: format(y(d.data)),\n              data: d.data\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nvar STACK_ORDERS = {\n  ascending: ascending[\"a\" /* default */],\n  descending: descending[\"a\" /* default */],\n  insideout: insideOut[\"a\" /* default */],\n  none: none[\"a\" /* default */],\n  reverse: order_reverse[\"a\" /* default */]\n};\n\nvar STACK_ORDER_NAMES = Object.keys(STACK_ORDERS);\n\nfunction stackOrder(order) {\n  return STACK_ORDERS[order] || STACK_ORDERS.none;\n}\n\nvar STACK_OFFSETS = {\n  expand: expand[\"a\" /* default */],\n  diverging: diverging[\"a\" /* default */],\n  none: offset_none[\"a\" /* default */],\n  silhouette: silhouette[\"a\" /* default */],\n  wiggle: wiggle[\"a\" /* default */]\n};\n\nvar STACK_OFFSET_NAMES = Object.keys(STACK_OFFSETS);\n\nfunction stackOffset(offset) {\n  return STACK_OFFSETS[offset] || STACK_OFFSETS.none;\n}\n\nStack.propTypes = {\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  keys: prop_types_default.a.array,\n  data: prop_types_default.a.array,\n  curve: prop_types_default.a.func,\n  defined: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.bool]),\n  x: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  x0: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  x1: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  y: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  y0: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  y1: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  value: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  order: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.array, prop_types_default.a.string]),\n  offset: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.array, prop_types_default.a.string]),\n  render: prop_types_default.a.func,\n  reverse: prop_types_default.a.bool\n};\n\nfunction Stack(_ref) {\n  var className = _ref.className,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      keys = _ref.keys,\n      data = _ref.data,\n      curve = _ref.curve,\n      defined = _ref.defined,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      value = _ref.value,\n      order = _ref.order,\n      offset = _ref.offset,\n      render = _ref.render,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === undefined ? false : _ref$reverse,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'top', 'left', 'keys', 'data', 'curve', 'defined', 'x', 'x0', 'x1', 'y0', 'y1', 'value', 'order', 'offset', 'render', 'reverse']);\n\n  var stack$$1 = Object(stack[\"a\" /* default */])();\n  if (keys) stack$$1.keys(keys);\n  if (value) stack$$1.value(value);\n  if (order) stack$$1.order(stackOrder(order));\n  if (offset) stack$$1.offset(stackOffset(offset));\n\n  var path$$1 = Object(src_area[\"a\" /* default */])();\n  if (x) path$$1.x(x);\n  if (x0) path$$1.x0(x0);\n  if (x1) path$$1.x1(x1);\n  if (y0) path$$1.y0(y0);\n  if (y1) path$$1.y1(y1);\n  if (curve) path$$1.curve(curve);\n  if (defined) path$$1.defined(defined);\n\n  var seriesData = stack$$1(data);\n  if (reverse) seriesData.reverse();\n\n  if (render) {\n    return react_default.a.createElement(\n      Group,\n      { top: top, left: left },\n      render({ seriesData: seriesData, path: path$$1 })\n    );\n  }\n\n  return react_default.a.createElement(\n    Group,\n    { top: top, left: left },\n    seriesData.map(function (series, i) {\n      return react_default.a.createElement('path', vx_shape_es_extends({\n        className: classnames_default()('vx-stack', className),\n        key: 'stack-' + i + '-' + (series.key || ''),\n        d: path$$1(series)\n      }, additionalProps(restProps, {\n        datum: series[i],\n        index: i,\n        series: series\n      })));\n    })\n  );\n}\n\nvar degreesToRadians = function degreesToRadians(degrees) {\n  return Math.PI / 180 * degrees;\n};\n\nfunction pathHorizontalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var link = Object(src_link[\"a\" /* linkHorizontal */])();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkHorizontal.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkHorizontal(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalDiagonal({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-horizontal', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var link = Object(src_link[\"c\" /* linkVertical */])();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkVertical.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkVertical(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalDiagonal({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-vertical', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      angle = _ref.angle,\n      radius = _ref.radius;\n\n  return function (data) {\n    var link = Object(src_link[\"b\" /* linkRadial */])();\n    link.angle(angle);\n    link.radius(radius);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkRadial.propTypes = {\n  innerRef: prop_types_default.a.func,\n  angle: prop_types_default.a.func,\n  radius: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkRadial(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$angle = _ref2.angle,\n      angle = _ref2$angle === undefined ? function (d) {\n    return d.x;\n  } : _ref2$angle,\n      _ref2$radius = _ref2.radius,\n      radius = _ref2$radius === undefined ? function (d) {\n    return d.y;\n  } : _ref2$radius,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'angle', 'radius', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialDiagonal({ source: source, target: target, angle: angle, radius: radius });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-radius', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkHorizontalCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathHorizontalCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkVerticalCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathVerticalCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sa = x(sourceData) - Math.PI / 2;\n    var sr = y(sourceData);\n    var ta = x(targetData) - Math.PI / 2;\n    var tr = y(targetData);\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n\n    var sx = sr * sc;\n    var sy = sr * ss;\n    var tx = tr * tc;\n    var ty = tr * ts;\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkRadialCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkRadialCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathRadialCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalLine.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction LinkHorizontalLine(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalLine.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction LinkVerticalLine(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sa = x(sourceData) - Math.PI / 2;\n    var sr = y(sourceData);\n    var ta = x(targetData) - Math.PI / 2;\n    var tr = y(targetData);\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sr * sc, sr * ss);\n    path$$1.lineTo(tr * tc, tr * ts);\n\n    return path$$1.toString();\n  };\n}\n\nLinkRadialStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction LinkRadialStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(sx + (tx - sx) * percent, sy);\n    path$$1.lineTo(sx + (tx - sx) * percent, ty);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkHorizontalStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.5 : _ref2$percent,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'percent', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalStep({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(sx, sy + (ty - sy) * percent);\n    path$$1.lineTo(tx, sy + (ty - sy) * percent);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkVerticalStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.5 : _ref2$percent,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'percent', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalStep({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var sa = sx - Math.PI / 2;\n    var sr = sy;\n    var ta = tx - Math.PI / 2;\n    var tr = ty;\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n    var sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n\n    return '\\n      M' + sr * sc + ',' + sr * ss + '\\n      A' + sr + ',' + sr + ',0,0,' + (sf ? 1 : 0) + ',' + sr * tc + ',' + sr * ts + '\\n      L' + tr * tc + ',' + tr * ts + '\\n    ';\n  };\n}\n\nLinkRadialStep$1.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkRadialStep$1(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialStep({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nPolygon.propTypes = {\n  sides: prop_types_default.a.number.isRequired,\n  size: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  rotate: prop_types_default.a.number\n};\n\nvar vx_shape_es_getPoint = function getPoint(_ref) {\n  var sides = _ref.sides,\n      size = _ref.size,\n      center = _ref.center,\n      rotate = _ref.rotate,\n      side = _ref.side;\n\n  var degrees = 360 / sides * side - rotate;\n  var radians = degreesToRadians(degrees);\n\n  return new vx_point_es[\"Point\"]({\n    x: center.x + size * Math.cos(radians),\n    y: center.y + size * Math.sin(radians)\n  });\n};\n\nvar getPoints = function getPoints(_ref2) {\n  var sides = _ref2.sides,\n      size = _ref2.size,\n      center = _ref2.center,\n      rotate = _ref2.rotate;\n\n  return [].concat(toConsumableArray(Array(sides).keys())).map(function (side) {\n    return vx_shape_es_getPoint({\n      sides: sides,\n      size: size,\n      center: center,\n      rotate: rotate,\n      side: side\n    });\n  });\n};\n\nfunction Polygon(_ref3) {\n  var sides = _ref3.sides,\n      _ref3$size = _ref3.size,\n      size = _ref3$size === undefined ? 25 : _ref3$size,\n      _ref3$center = _ref3.center,\n      center = _ref3$center === undefined ? new vx_point_es[\"Point\"]({ x: 0, y: 0 }) : _ref3$center,\n      _ref3$rotate = _ref3.rotate,\n      rotate = _ref3$rotate === undefined ? 0 : _ref3$rotate,\n      className = _ref3.className,\n      restProps = vx_shape_es_objectWithoutProperties(_ref3, ['sides', 'size', 'center', 'rotate', 'className']);\n\n  var points = getPoints({\n    sides: sides,\n    size: size,\n    center: center,\n    rotate: rotate\n  }).map(function (p) {\n    return p.toArray();\n  }).join(' ');\n\n  return react_default.a.createElement('polygon', vx_shape_es_extends({ points: points, className: classnames_default()('vx-polygon', className) }, restProps));\n}\n\n\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/grid/dist/vx-grid.es.js\n\n\n\n\n\n\n\nvar vx_grid_es_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar vx_grid_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nRows.propTypes = {\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  className: prop_types_default.a.string,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]),\n  strokeDasharray: prop_types_default.a.string,\n  numTicks: prop_types_default.a.number,\n  lineStyle: prop_types_default.a.object,\n  offset: prop_types_default.a.number,\n  scale: prop_types_default.a.func.isRequired,\n  width: prop_types_default.a.number.isRequired,\n  tickValues: prop_types_default.a.array\n};\n\nfunction Rows(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      scale = _ref.scale,\n      width = _ref.width,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? '#eaf0f6' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 1 : _ref$strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      className = _ref.className,\n      _ref$numTicks = _ref.numTicks,\n      numTicks = _ref$numTicks === undefined ? 10 : _ref$numTicks,\n      lineStyle = _ref.lineStyle,\n      offset = _ref.offset,\n      tickValues = _ref.tickValues,\n      restProps = vx_grid_es_objectWithoutProperties(_ref, ['top', 'left', 'scale', 'width', 'stroke', 'strokeWidth', 'strokeDasharray', 'className', 'numTicks', 'lineStyle', 'offset', 'tickValues']);\n\n  var ticks = scale.ticks ? scale.ticks(numTicks) : scale.domain();\n  if (tickValues) ticks = tickValues;\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-rows', className), top: top, left: left },\n    ticks.map(function (d, i) {\n      var y = offset ? scale(d) + offset : scale(d);\n      var fromPoint = new vx_point_es[\"Point\"]({\n        x: 0,\n        y: y\n      });\n      var toPoint = new vx_point_es[\"Point\"]({\n        x: width,\n        y: y\n      });\n      return react_default.a.createElement(Line, vx_grid_es_extends({\n        key: 'row-line-' + d + '-' + i,\n        from: fromPoint,\n        to: toPoint,\n        stroke: stroke,\n        strokeWidth: strokeWidth,\n        strokeDasharray: strokeDasharray,\n        style: lineStyle\n      }, restProps));\n    })\n  );\n}\n\nColumns.propTypes = {\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  className: prop_types_default.a.string,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]),\n  strokeDasharray: prop_types_default.a.string,\n  numTicks: prop_types_default.a.number,\n  lineStyle: prop_types_default.a.object,\n  offset: prop_types_default.a.number,\n  scale: prop_types_default.a.func.isRequired,\n  height: prop_types_default.a.number.isRequired,\n  tickValues: prop_types_default.a.array\n};\n\nfunction Columns(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      scale = _ref.scale,\n      height = _ref.height,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? '#eaf0f6' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 1 : _ref$strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      className = _ref.className,\n      _ref$numTicks = _ref.numTicks,\n      numTicks = _ref$numTicks === undefined ? 10 : _ref$numTicks,\n      lineStyle = _ref.lineStyle,\n      offset = _ref.offset,\n      tickValues = _ref.tickValues,\n      restProps = vx_grid_es_objectWithoutProperties(_ref, ['top', 'left', 'scale', 'height', 'stroke', 'strokeWidth', 'strokeDasharray', 'className', 'numTicks', 'lineStyle', 'offset', 'tickValues']);\n\n  var ticks = scale.ticks ? scale.ticks(numTicks) : scale.domain();\n  if (tickValues) ticks = tickValues;\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-columns', className), top: top, left: left },\n    ticks.map(function (d, i) {\n      var x = offset ? scale(d) + offset : scale(d);\n      var fromPoint = new vx_point_es[\"Point\"]({\n        x: x,\n        y: 0\n      });\n      var toPoint = new vx_point_es[\"Point\"]({\n        x: x,\n        y: height\n      });\n      return react_default.a.createElement(Line, vx_grid_es_extends({\n        key: 'column-line-' + d + '-' + i,\n        from: fromPoint,\n        to: toPoint,\n        stroke: stroke,\n        strokeWidth: strokeWidth,\n        strokeDasharray: strokeDasharray,\n        style: lineStyle\n      }, restProps));\n    })\n  );\n}\n\nGrid.propTypes = {\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  className: prop_types_default.a.string,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]),\n  strokeDasharray: prop_types_default.a.string,\n  numTicksRows: prop_types_default.a.number,\n  numTicksColumns: prop_types_default.a.number,\n  rowLineStyle: prop_types_default.a.object,\n  columnLineStyle: prop_types_default.a.object,\n  xOffset: prop_types_default.a.number,\n  yOffset: prop_types_default.a.number,\n  xScale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  height: prop_types_default.a.number.isRequired,\n  width: prop_types_default.a.number.isRequired,\n  rowTickValues: prop_types_default.a.array,\n  columnTickValues: prop_types_default.a.array\n};\n\nfunction Grid(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      width = _ref.width,\n      height = _ref.height,\n      className = _ref.className,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      numTicksRows = _ref.numTicksRows,\n      numTicksColumns = _ref.numTicksColumns,\n      rowLineStyle = _ref.rowLineStyle,\n      columnLineStyle = _ref.columnLineStyle,\n      xOffset = _ref.xOffset,\n      yOffset = _ref.yOffset,\n      rowTickValues = _ref.rowTickValues,\n      columnTickValues = _ref.columnTickValues,\n      restProps = vx_grid_es_objectWithoutProperties(_ref, ['top', 'left', 'xScale', 'yScale', 'width', 'height', 'className', 'stroke', 'strokeWidth', 'strokeDasharray', 'numTicksRows', 'numTicksColumns', 'rowLineStyle', 'columnLineStyle', 'xOffset', 'yOffset', 'rowTickValues', 'columnTickValues']);\n\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-grid', className), top: top, left: left },\n    react_default.a.createElement(Rows, vx_grid_es_extends({\n      className: className,\n      scale: yScale,\n      width: width,\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      numTicks: numTicksRows,\n      style: rowLineStyle,\n      offset: yOffset,\n      tickValues: rowTickValues\n    }, restProps)),\n    react_default.a.createElement(Columns, vx_grid_es_extends({\n      className: className,\n      scale: xScale,\n      height: height,\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      numTicks: numTicksColumns,\n      style: columnLineStyle,\n      offset: xOffset,\n      tickValues: columnTickValues\n    }, restProps))\n  );\n}\n\n\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/group/dist/vx-group.es.js\nvar vx_group_es = __webpack_require__(1842);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/shared/esm/enhancer/WithTooltip.js\nvar WithTooltip = __webpack_require__(2462);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/theme/esm/color.js\nvar color = __webpack_require__(1929);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@vx/group/dist/vx-group.es.js\nvar dist_vx_group_es = __webpack_require__(1850);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@vx/threshold/node_modules/@vx/shape/dist/vx-shape.es.js\n\n\n\n\n\n\n\n\n\nfunction vx_shape_es_callOrValue(maybeFn, data) {\n  if (typeof maybeFn === 'function') {\n    return maybeFn(data);\n  }\n  return maybeFn;\n}\n\nfunction vx_shape_es_additionalProps(restProps, data) {\n  return Object.keys(restProps).reduce(function (ret, cur) {\n    ret[cur] = vx_shape_es_callOrValue(restProps[cur], data);\n    return ret;\n  }, {});\n}\n\nvar dist_vx_shape_es_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar dist_vx_shape_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction vx_shape_es_Arc(_ref) {\n  var className = _ref.className,\n      data = _ref.data,\n      centroid = _ref.centroid,\n      innerRadius = _ref.innerRadius,\n      outerRadius = _ref.outerRadius,\n      cornerRadius = _ref.cornerRadius,\n      startAngle = _ref.startAngle,\n      endAngle = _ref.endAngle,\n      padAngle = _ref.padAngle,\n      padRadius = _ref.padRadius,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['className', 'data', 'centroid', 'innerRadius', 'outerRadius', 'cornerRadius', 'startAngle', 'endAngle', 'padAngle', 'padRadius']);\n\n  var arc$$1 = Object(src_arc[\"a\" /* default */])();\n  if (centroid) arc$$1.centroid(centroid);\n  if (innerRadius) arc$$1.innerRadius(innerRadius);\n  if (outerRadius) arc$$1.outerRadius(outerRadius);\n  if (cornerRadius) arc$$1.cornerRadius(cornerRadius);\n  if (startAngle) arc$$1.startAngle(startAngle);\n  if (endAngle) arc$$1.endAngle(endAngle);\n  if (padAngle) arc$$1.padAngle(padAngle);\n  if (padRadius) arc$$1.padRadius(padRadius);\n  return react_default.a.createElement('path', dist_vx_shape_es_extends({ className: classnames_default()('vx-arc', className), d: arc$$1(data) }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nfunction vx_shape_es_Pie(_ref) {\n  var _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      data = _ref.data,\n      centroid = _ref.centroid,\n      _ref$innerRadius = _ref.innerRadius,\n      innerRadius = _ref$innerRadius === undefined ? 0 : _ref$innerRadius,\n      outerRadius = _ref.outerRadius,\n      cornerRadius = _ref.cornerRadius,\n      _ref$startAngle = _ref.startAngle,\n      startAngle = _ref$startAngle === undefined ? 0 : _ref$startAngle,\n      endAngle = _ref.endAngle,\n      padAngle = _ref.padAngle,\n      padRadius = _ref.padRadius,\n      pieSort = _ref.pieSort,\n      pieSortValues = _ref.pieSortValues,\n      pieValue = _ref.pieValue,\n      children = _ref.children,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['className', 'top', 'left', 'data', 'centroid', 'innerRadius', 'outerRadius', 'cornerRadius', 'startAngle', 'endAngle', 'padAngle', 'padRadius', 'pieSort', 'pieSortValues', 'pieValue', 'children']);\n\n  var path$$1 = Object(src_arc[\"a\" /* default */])();\n  path$$1.innerRadius(innerRadius);\n  if (outerRadius) path$$1.outerRadius(outerRadius);\n  if (cornerRadius) path$$1.cornerRadius(cornerRadius);\n  if (padRadius) path$$1.padRadius(padRadius);\n  var pie$$1 = Object(pie[\"a\" /* default */])();\n  if (pieSort) pie$$1.sort(pieSort);\n  if (pieSortValues) pie$$1.sortValues(pieSortValues);\n  if (pieValue) pie$$1.value(pieValue);\n  if (padAngle != null) pie$$1.padAngle(padAngle);\n  if (startAngle != null) pie$$1.startAngle(startAngle);\n  if (endAngle != null) pie$$1.endAngle(endAngle);\n  var arcs = pie$$1(data);\n  var renderFunctionArg = {\n    arcs: arcs,\n    generatePathProps: function generatePathProps(arc$$1, index) {\n      return dist_vx_shape_es_extends({\n        className: classnames_default()('vx-pie-arc', className),\n        d: path$$1(arc$$1)\n      }, vx_shape_es_additionalProps(restProps, dist_vx_shape_es_extends({}, arc$$1, {\n        index: index,\n        centroid: centroid ? path$$1.centroid(arc$$1) : undefined\n      })));\n    },\n    generateCentroid: function generateCentroid(arc$$1) {\n      return centroid && centroid(path$$1.centroid(arc$$1), arc$$1);\n    }\n  };\n  return react_default.a.createElement(\n    dist_vx_group_es[\"Group\"],\n    { className: 'vx-pie-arcs-group', top: top, left: left },\n    children ? children(renderFunctionArg) : arcs.map(function (arc$$1, i) {\n      var pathProps = renderFunctionArg.generatePathProps(arc$$1, i);\n      return react_default.a.createElement(\n        'g',\n        { key: 'pie-arc-' + i },\n        react_default.a.createElement('path', pathProps),\n        renderFunctionArg.generateCentroid(arc$$1)\n      );\n    })\n  );\n}\n\nvx_shape_es_Line.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction vx_shape_es_Line(_ref) {\n  var _ref$from = _ref.from,\n      from = _ref$from === undefined ? new vx_point_es[\"Point\"]({ x: 0, y: 0 }) : _ref$from,\n      _ref$to = _ref.to,\n      to = _ref$to === undefined ? new vx_point_es[\"Point\"]({ x: 1, y: 1 }) : _ref$to,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 1 : _ref$strokeWidth,\n      _ref$strokeDasharray = _ref.strokeDasharray,\n      strokeDasharray = _ref$strokeDasharray === undefined ? '' : _ref$strokeDasharray,\n      _ref$transform = _ref.transform,\n      transform = _ref$transform === undefined ? '' : _ref$transform,\n      _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      data = _ref.data,\n      innerRef = _ref.innerRef,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['from', 'to', 'stroke', 'strokeWidth', 'strokeDasharray', 'transform', 'className', 'data', 'innerRef']);\n\n  return react_default.a.createElement('line', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-line', className),\n    x1: from.x,\n    y1: from.y,\n    x2: to.x,\n    y2: to.y,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    transform: transform\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nvx_shape_es_LinePath.propTypes = {\n  innerRef: prop_types_default.a.func,\n  xScale: prop_types_default.a.func,\n  yScale: prop_types_default.a.func,\n  data: prop_types_default.a.array,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  defined: prop_types_default.a.func,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  glyph: prop_types_default.a.func,\n  curve: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LinePath(_ref) {\n  var children = _ref.children,\n      data = _ref.data,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      x = _ref.x,\n      y = _ref.y,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'steelblue' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$strokeDasharray = _ref.strokeDasharray,\n      strokeDasharray = _ref$strokeDasharray === undefined ? '' : _ref$strokeDasharray,\n      _ref$strokeDashoffset = _ref.strokeDashoffset,\n      strokeDashoffset = _ref$strokeDashoffset === undefined ? 0 : _ref$strokeDashoffset,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'none' : _ref$fill,\n      _ref$curve = _ref.curve,\n      curve = _ref$curve === undefined ? linear[\"a\" /* default */] : _ref$curve,\n      glyph = _ref.glyph,\n      innerRef = _ref.innerRef,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['children', 'data', 'xScale', 'yScale', 'x', 'y', 'defined', 'className', 'stroke', 'strokeWidth', 'strokeDasharray', 'strokeDashoffset', 'fill', 'curve', 'glyph', 'innerRef']);\n\n  var path$$1 = Object(line[\"a\" /* default */])().x(function () {\n    return xScale(x.apply(undefined, arguments));\n  }).y(function () {\n    return yScale(y.apply(undefined, arguments));\n  }).defined(defined).curve(curve);\n  if (children) return children({ path: path$$1 });\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', dist_vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-linepath', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset,\n      fill: fill\n    }, vx_shape_es_additionalProps(restProps, data))),\n    glyph && react_default.a.createElement(\n      'g',\n      { className: 'vx-linepath-glyphs' },\n      data.map(glyph)\n    )\n  );\n}\n\nvx_shape_es_LineRadial.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LineRadial(_ref) {\n  var _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      angle = _ref.angle,\n      radius = _ref.radius,\n      defined = _ref.defined,\n      curve = _ref.curve,\n      data = _ref.data,\n      innerRef = _ref.innerRef,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['className', 'angle', 'radius', 'defined', 'curve', 'data', 'innerRef']);\n\n  var path$$1 = Object(lineRadial[\"a\" /* default */])();\n  if (angle) path$$1.angle(angle);\n  if (radius) path$$1.radius(radius);\n  if (defined) path$$1.defined(defined);\n  if (curve) path$$1.curve(curve);\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', dist_vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-line-radial', className),\n      d: path$$1(data)\n    }, vx_shape_es_additionalProps(restProps, data)))\n  );\n}\n\nvx_shape_es_Area.propTypes = {\n  x: prop_types_default.a.func,\n  x0: prop_types_default.a.func,\n  x1: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  y0: prop_types_default.a.func,\n  y1: prop_types_default.a.func,\n  xScale: prop_types_default.a.func,\n  yScale: prop_types_default.a.func,\n  data: prop_types_default.a.array,\n  defined: prop_types_default.a.func,\n  className: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.bool, prop_types_default.a.object, prop_types_default.a.array]),\n  innerRef: prop_types_default.a.func,\n  strokeDasharray: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  stroke: prop_types_default.a.string,\n  fill: prop_types_default.a.string,\n  curve: prop_types_default.a.func\n};\n\nfunction vx_shape_es_Area(_ref) {\n  var children = _ref.children,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y = _ref.y,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      _ref$data = _ref.data,\n      data = _ref$data === undefined ? [] : _ref$data,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      strokeDasharray = _ref.strokeDasharray,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,\n      curve = _ref.curve,\n      innerRef = _ref.innerRef,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['children', 'x', 'x0', 'x1', 'y', 'y0', 'y1', 'xScale', 'yScale', 'data', 'defined', 'className', 'strokeDasharray', 'strokeWidth', 'stroke', 'fill', 'curve', 'innerRef']);\n\n  var path$$1 = Object(src_area[\"a\" /* default */])();\n  if (x) path$$1.x(function () {\n    return xScale(x.apply(undefined, arguments));\n  });\n  if (x0) path$$1.x0(function () {\n    return xScale(x0.apply(undefined, arguments));\n  });\n  if (x1) path$$1.x1(function () {\n    return xScale(x1.apply(undefined, arguments));\n  });\n  if (y) path$$1.y(function () {\n    return yScale(y.apply(undefined, arguments));\n  });\n  if (y0) path$$1.y0(function () {\n    return yScale(y0.apply(undefined, arguments));\n  });\n  if (y1) path$$1.y1(function () {\n    return yScale(y1.apply(undefined, arguments));\n  });\n  if (defined) path$$1.defined(defined);\n  if (curve) path$$1.curve(curve);\n  if (children) return children({ path: path$$1 });\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', dist_vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-area', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill\n    }, vx_shape_es_additionalProps(restProps, data)))\n  );\n}\n\nvx_shape_es_AreaClosed.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction vx_shape_es_AreaClosed(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      y0 = _ref.y0,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      data = _ref.data,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      strokeDasharray = _ref.strokeDasharray,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,\n      curve = _ref.curve,\n      innerRef = _ref.innerRef,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['x', 'y', 'y0', 'xScale', 'yScale', 'data', 'defined', 'className', 'strokeDasharray', 'strokeWidth', 'stroke', 'fill', 'curve', 'innerRef']);\n\n  var path$$1 = Object(src_area[\"a\" /* default */])().x(function () {\n    return xScale(x.apply(undefined, arguments));\n  }).y0(y0 || yScale.range()[0]).y1(function () {\n    return yScale(y.apply(undefined, arguments));\n  }).defined(defined);\n  if (curve) path$$1.curve(curve);\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', dist_vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-area-closed', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill\n    }, vx_shape_es_additionalProps(restProps, data)))\n  );\n}\n\nfunction vx_shape_es_AreaStack(_ref) {\n  var className = _ref.className,\n      _ref$top = _ref.top,\n      _ref$left = _ref.left,\n      keys = _ref.keys,\n      data = _ref.data,\n      curve = _ref.curve,\n      defined = _ref.defined,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      glyph = _ref.glyph,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === undefined ? false : _ref$reverse,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['className', 'top', 'left', 'keys', 'data', 'curve', 'defined', 'x', 'x0', 'x1', 'y0', 'y1', 'glyph', 'reverse']);\n\n  var stack$$1 = Object(stack[\"a\" /* default */])();\n  if (keys) stack$$1.keys(keys);\n\n  var path$$1 = Object(src_area[\"a\" /* default */])();\n  if (x) path$$1.x(x);\n  if (x0) path$$1.x0(x0);\n  if (x1) path$$1.x1(x1);\n  if (y0) path$$1.y0(y0);\n  if (y1) path$$1.y1(y1);\n  if (curve) path$$1.curve(curve);\n  if (defined) path$$1.defined(defined);\n\n  var seriesData = stack$$1(data);\n  if (reverse) seriesData.reverse();\n\n  return react_default.a.createElement(\n    'g',\n    null,\n    seriesData.map(function (series, i) {\n      return react_default.a.createElement('path', dist_vx_shape_es_extends({\n        className: classnames_default()('vx-area-stack', className),\n        key: 'area-stack-' + i + '-' + (series.key || ''),\n        d: path$$1(series)\n      }, vx_shape_es_additionalProps(restProps, {\n        datum: series[i],\n        index: i,\n        series: series\n      })));\n    }),\n    !!glyph && react_default.a.createElement(\n      'g',\n      { className: 'vx-area-stack-glyphs' },\n      data.map(glyph)\n    )\n  );\n}\n\nvx_shape_es_Bar.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction vx_shape_es_Bar(_ref) {\n  var className = _ref.className,\n      innerRef = _ref.innerRef,\n      data = _ref.data,\n      _ref$x = _ref.x,\n      x = _ref$x === undefined ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === undefined ? 0 : _ref$y,\n      width = _ref.width,\n      height = _ref.height,\n      rx = _ref.rx,\n      ry = _ref.ry,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'steelblue' : _ref$fill,\n      fillOpacity = _ref.fillOpacity,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      strokeLinecap = _ref.strokeLinecap,\n      strokeLinejoin = _ref.strokeLinejoin,\n      strokeMiterlimit = _ref.strokeMiterlimit,\n      strokeOpacity = _ref.strokeOpacity,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['className', 'innerRef', 'data', 'x', 'y', 'width', 'height', 'rx', 'ry', 'fill', 'fillOpacity', 'stroke', 'strokeWidth', 'strokeDasharray', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'strokeOpacity']);\n\n  return react_default.a.createElement('rect', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-bar', className),\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    rx: rx,\n    ry: ry,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    strokeLinecap: strokeLinecap,\n    strokeLinejoin: strokeLinejoin,\n    strokeMiterlimit: strokeMiterlimit,\n    strokeOpacity: strokeOpacity\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nfunction vx_shape_es_BarGroup(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      x0 = _ref.x0,\n      x0Scale = _ref.x0Scale,\n      x1Scale = _ref.x1Scale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      height = _ref.height,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'x0', 'x0Scale', 'x1Scale', 'yScale', 'zScale', 'keys', 'height']);\n\n  var format = x0Scale.tickFormat ? x0Scale.tickFormat() : function (d) {\n    return d;\n  };\n  return react_default.a.createElement(\n    dist_vx_group_es[\"Group\"],\n    { className: classnames_default()('vx-bar-group', className), top: top, left: left },\n    data && data.map(function (d, i) {\n      return react_default.a.createElement(\n        dist_vx_group_es[\"Group\"],\n        { key: 'bar-group-' + i + '-' + x0(d), left: x0Scale(x0(d)) },\n        keys && keys.map(function (key, i) {\n          var value = d[key];\n          return react_default.a.createElement(vx_shape_es_Bar, dist_vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + value + '-' + key,\n            x: x1Scale(key),\n            y: yScale(value),\n            width: x1Scale.bandwidth(),\n            height: height - yScale(value),\n            fill: zScale(key),\n            data: {\n              key: key,\n              value: value,\n              x: format(x0(d)),\n              data: d\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nvx_shape_es_BarGroup.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  x0: prop_types_default.a.func.isRequired,\n  x0Scale: prop_types_default.a.func.isRequired,\n  x1Scale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  height: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nfunction vx_shape_es_BarGroupHorizontal(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      y0 = _ref.y0,\n      y0Scale = _ref.y0Scale,\n      y1Scale = _ref.y1Scale,\n      xScale = _ref.xScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      width = _ref.width,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'y0', 'y0Scale', 'y1Scale', 'xScale', 'zScale', 'keys', 'width']);\n\n  var format = y0Scale.tickFormat ? y0Scale.tickFormat() : function (d) {\n    return d;\n  };\n  return react_default.a.createElement(\n    dist_vx_group_es[\"Group\"],\n    { className: classnames_default()('vx-bar-group-horizontal', className), top: top, left: left },\n    data && data.map(function (d, i) {\n      return react_default.a.createElement(\n        dist_vx_group_es[\"Group\"],\n        { key: 'bar-group-' + i + '-' + y0(d), top: y0Scale(y0(d)) },\n        keys && keys.map(function (key, i) {\n          var value = d[key];\n          return react_default.a.createElement(vx_shape_es_Bar, dist_vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + value + '-' + key,\n            x: 0,\n            y: y1Scale(key),\n            width: width - xScale(value),\n            height: y1Scale.bandwidth(),\n            fill: zScale(key),\n            data: {\n              key: key,\n              value: value,\n              y: format(y0(d)),\n              data: d\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nvx_shape_es_BarGroupHorizontal.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  y0: prop_types_default.a.func.isRequired,\n  y0Scale: prop_types_default.a.func.isRequired,\n  y1Scale: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  width: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nfunction vx_shape_es_BarStack(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      x = _ref.x,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      height = _ref.height,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'x', 'xScale', 'yScale', 'zScale', 'keys', 'height']);\n\n  var series = Object(stack[\"a\" /* default */])().keys(keys)(data);\n  var format = xScale.tickFormat ? xScale.tickFormat() : function (d) {\n    return d;\n  };\n  var bandwidth = xScale.bandwidth();\n  var step = xScale.step();\n  var paddingInner = xScale.paddingInner();\n  var paddingOuter = xScale.paddingOuter();\n  return react_default.a.createElement(\n    dist_vx_group_es[\"Group\"],\n    { className: classnames_default()('vx-bar-stack', className), top: top, left: left },\n    series && series.map(function (s, i) {\n      return react_default.a.createElement(\n        dist_vx_group_es[\"Group\"],\n        { key: 'vx-bar-stack-' + i },\n        s.map(function (d, ii) {\n          var barHeight = yScale(d[0]) - yScale(d[1]);\n          return react_default.a.createElement(vx_shape_es_Bar, dist_vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + ii + '-' + s.key,\n            x: xScale(x(d.data)),\n            y: yScale(d[1]),\n            width: bandwidth,\n            height: barHeight,\n            fill: zScale(s.key),\n            data: {\n              bandwidth: bandwidth,\n              paddingInner: paddingInner,\n              paddingOuter: paddingOuter,\n              step: step,\n              key: s.key,\n              value: d[1],\n              height: barHeight,\n              width: bandwidth,\n              x: x(d.data),\n              xFormatted: format(x(d.data)),\n              data: d.data\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nvx_shape_es_BarStack.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  x: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nfunction vx_shape_es_BarStackHorizontal(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      y = _ref.y,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      height = _ref.height,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'y', 'xScale', 'yScale', 'zScale', 'keys', 'height']);\n\n  var series = Object(stack[\"a\" /* default */])().keys(keys)(data);\n  var format = yScale.tickFormat ? yScale.tickFormat() : function (d) {\n    return d;\n  };\n  var bandwidth = yScale.bandwidth();\n  var step = yScale.step();\n  var paddingInner = yScale.paddingInner();\n  var paddingOuter = yScale.paddingOuter();\n  return react_default.a.createElement(\n    dist_vx_group_es[\"Group\"],\n    { className: classnames_default()('vx-bar-stack-horizontal', className), top: top, left: left },\n    series && series.map(function (s, i) {\n      return react_default.a.createElement(\n        dist_vx_group_es[\"Group\"],\n        { key: 'vx-bar-stack-horizontal-' + i },\n        s.map(function (d, ii) {\n          var barWidth = xScale(d[1]) - xScale(d[0]);\n          return react_default.a.createElement(vx_shape_es_Bar, dist_vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + ii + '-' + s.key,\n            x: xScale(d[0]),\n            y: yScale(y(d.data)),\n            width: barWidth,\n            height: bandwidth,\n            fill: zScale(s.key),\n            data: {\n              bandwidth: bandwidth,\n              paddingInner: paddingInner,\n              paddingOuter: paddingOuter,\n              step: step,\n              key: s.key,\n              value: d[0],\n              height: bandwidth,\n              width: barWidth,\n              y: y(d.data),\n              yFormatted: format(y(d.data)),\n              data: d.data\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nvx_shape_es_BarStackHorizontal.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  y: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nvar vx_shape_es_STACK_ORDERS = {\n  ascending: ascending[\"a\" /* default */],\n  descending: descending[\"a\" /* default */],\n  insideout: insideOut[\"a\" /* default */],\n  none: none[\"a\" /* default */],\n  reverse: order_reverse[\"a\" /* default */]\n};\n\nvar vx_shape_es_STACK_ORDER_NAMES = Object.keys(vx_shape_es_STACK_ORDERS);\n\nfunction vx_shape_es_stackOrder(order) {\n  return vx_shape_es_STACK_ORDERS[order] || vx_shape_es_STACK_ORDERS.none;\n}\n\nvar vx_shape_es_STACK_OFFSETS = {\n  expand: expand[\"a\" /* default */],\n  diverging: diverging[\"a\" /* default */],\n  none: offset_none[\"a\" /* default */],\n  silhouette: silhouette[\"a\" /* default */],\n  wiggle: wiggle[\"a\" /* default */]\n};\n\nvar vx_shape_es_STACK_OFFSET_NAMES = Object.keys(vx_shape_es_STACK_OFFSETS);\n\nfunction vx_shape_es_stackOffset(offset) {\n  return vx_shape_es_STACK_OFFSETS[offset] || vx_shape_es_STACK_OFFSETS.none;\n}\n\nfunction vx_shape_es_Stack(_ref) {\n  var className = _ref.className,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      keys = _ref.keys,\n      data = _ref.data,\n      curve = _ref.curve,\n      defined = _ref.defined,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      value = _ref.value,\n      order = _ref.order,\n      offset = _ref.offset,\n      render = _ref.render,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === undefined ? false : _ref$reverse,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref, ['className', 'top', 'left', 'keys', 'data', 'curve', 'defined', 'x', 'x0', 'x1', 'y0', 'y1', 'value', 'order', 'offset', 'render', 'reverse']);\n\n  var stack$$1 = Object(stack[\"a\" /* default */])();\n  if (keys) stack$$1.keys(keys);\n  if (value) stack$$1.value(value);\n  if (order) stack$$1.order(vx_shape_es_stackOrder(order));\n  if (offset) stack$$1.offset(vx_shape_es_stackOffset(offset));\n\n  var path$$1 = Object(src_area[\"a\" /* default */])();\n  if (x) path$$1.x(x);\n  if (x0) path$$1.x0(x0);\n  if (x1) path$$1.x1(x1);\n  if (y0) path$$1.y0(y0);\n  if (y1) path$$1.y1(y1);\n  if (curve) path$$1.curve(curve);\n  if (defined) path$$1.defined(defined);\n\n  var seriesData = stack$$1(data);\n  if (reverse) seriesData.reverse();\n\n  if (render) return react_default.a.createElement(\n    dist_vx_group_es[\"Group\"],\n    { top: top, left: left },\n    render({ seriesData: seriesData, path: path$$1 })\n  );\n\n  return react_default.a.createElement(\n    dist_vx_group_es[\"Group\"],\n    { top: top, left: left },\n    seriesData.map(function (series, i) {\n      return react_default.a.createElement('path', dist_vx_shape_es_extends({\n        className: classnames_default()('vx-stack', className),\n        key: 'stack-' + i + '-' + (series.key || ''),\n        d: path$$1(series)\n      }, vx_shape_es_additionalProps(restProps, {\n        datum: series[i],\n        index: i,\n        series: series\n      })));\n    })\n  );\n}\n\nfunction vx_shape_es_pathHorizontalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var link = Object(src_link[\"a\" /* linkHorizontal */])();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nvx_shape_es_LinkHorizontal.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LinkHorizontal(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || vx_shape_es_pathHorizontalDiagonal({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-horizontal', className),\n    d: path$$1(data)\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nfunction vx_shape_es_pathVerticalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var link = Object(src_link[\"c\" /* linkVertical */])();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nvx_shape_es_LinkVertical.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LinkVertical(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || vx_shape_es_pathVerticalDiagonal({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-vertical', className),\n    d: path$$1(data)\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nfunction vx_shape_es_pathRadialDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      angle = _ref.angle,\n      radius = _ref.radius;\n\n  return function (data) {\n    var link = Object(src_link[\"b\" /* linkRadial */])();\n    link.angle(angle);\n    link.radius(radius);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nvx_shape_es_LinkRadial.propTypes = {\n  innerRef: prop_types_default.a.func,\n  angle: prop_types_default.a.func,\n  radius: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LinkRadial(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$angle = _ref2.angle,\n      angle = _ref2$angle === undefined ? function (d) {\n    return d.x;\n  } : _ref2$angle,\n      _ref2$radius = _ref2.radius,\n      radius = _ref2$radius === undefined ? function (d) {\n    return d.y;\n  } : _ref2$radius,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'angle', 'radius', 'source', 'target']);\n\n  path$$1 = path$$1 || vx_shape_es_pathRadialDiagonal({ source: source, target: target, angle: angle, radius: radius });\n  return react_default.a.createElement('path', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-radius', className),\n    d: path$$1(data)\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nfunction vx_shape_es_pathHorizontalCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nvx_shape_es_LinkHorizontalCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LinkHorizontalCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || vx_shape_es_pathHorizontalCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nfunction vx_shape_es_pathVerticalCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nvx_shape_es_LinkVerticalCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LinkVerticalCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || vx_shape_es_pathVerticalCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nfunction vx_shape_es_pathRadialCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sa = x(sourceData) - Math.PI / 2;\n    var sr = y(sourceData);\n    var ta = x(targetData) - Math.PI / 2;\n    var tr = y(targetData);\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n\n    var sx = sr * sc;\n    var sy = sr * ss;\n    var tx = tr * tc;\n    var ty = tr * ts;\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nvx_shape_es_LinkRadialCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LinkRadialCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || vx_shape_es_pathRadialCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nfunction vx_shape_es_pathHorizontalLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nvx_shape_es_LinkHorizontalLine.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LinkHorizontalLine(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || vx_shape_es_pathHorizontalLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nfunction vx_shape_es_pathVerticalLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nvx_shape_es_LinkVerticalLine.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LinkVerticalLine(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || vx_shape_es_pathVerticalLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nfunction vx_shape_es_pathRadialLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sa = x(sourceData) - Math.PI / 2;\n    var sr = y(sourceData);\n    var ta = x(targetData) - Math.PI / 2;\n    var tr = y(targetData);\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sr * sc, sr * ss);\n    path$$1.lineTo(tr * tc, tr * ts);\n\n    return path$$1.toString();\n  };\n}\n\nvx_shape_es_LinkRadialStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LinkRadialStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || vx_shape_es_pathRadialLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nfunction vx_shape_es_pathHorizontalStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(sx + (tx - sx) * percent, sy);\n    path$$1.lineTo(sx + (tx - sx) * percent, ty);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nvx_shape_es_LinkHorizontalStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LinkHorizontalStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.5 : _ref2$percent,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'percent', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || vx_shape_es_pathHorizontalStep({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nfunction vx_shape_es_pathVerticalStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(src_path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(sx, sy + (ty - sy) * percent);\n    path$$1.lineTo(tx, sy + (ty - sy) * percent);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nvx_shape_es_LinkVerticalStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LinkVerticalStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.5 : _ref2$percent,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'percent', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || vx_shape_es_pathVerticalStep({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\nfunction vx_shape_es_pathRadialStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var sa = sx - Math.PI / 2;\n    var sr = sy;\n    var ta = tx - Math.PI / 2;\n    var tr = ty;\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n    var sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n\n    return '\\n      M' + sr * sc + ',' + sr * ss + '\\n      A' + sr + ',' + sr + ',0,0,' + (sf ? 1 : 0) + ',' + sr * tc + ',' + sr * ts + '\\n      L' + tr * tc + ',' + tr * ts + '\\n    ';\n  };\n}\n\nvx_shape_es_LinkRadialStep$1.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction vx_shape_es_LinkRadialStep$1(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = dist_vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || vx_shape_es_pathRadialStep({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', dist_vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, vx_shape_es_additionalProps(restProps, data)));\n}\n\n\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@vx/threshold/node_modules/@vx/clip-path/dist/vx-clip-path.es.js\n\n\nvar vx_clip_path_es_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar vx_clip_path_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar ClipPath = (function (_ref) {\n  var id = _ref.id,\n      children = _ref.children,\n      restProps = vx_clip_path_es_objectWithoutProperties(_ref, ['id', 'children']);\n  return react_default.a.createElement(\n    'defs',\n    null,\n    react_default.a.createElement(\n      'clipPath',\n      vx_clip_path_es_extends({ id: id }, restProps),\n      children\n    )\n  );\n});\n\nvar CircleClipPath = (function (_ref) {\n  var id = _ref.id,\n      cx = _ref.cx,\n      cy = _ref.cy,\n      r = _ref.r,\n      restProps = vx_clip_path_es_objectWithoutProperties(_ref, ['id', 'cx', 'cy', 'r']);\n  return react_default.a.createElement(\n    ClipPath,\n    { id: id },\n    react_default.a.createElement('circle', vx_clip_path_es_extends({ cx: cx, cy: cy, r: r }, restProps))\n  );\n});\n\nvar RectClipPath = (function (_ref) {\n  var id = _ref.id,\n      _ref$x = _ref.x,\n      x = _ref$x === undefined ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === undefined ? 0 : _ref$y,\n      _ref$width = _ref.width,\n      width = _ref$width === undefined ? 1 : _ref$width,\n      _ref$height = _ref.height,\n      height = _ref$height === undefined ? 1 : _ref$height,\n      restProps = vx_clip_path_es_objectWithoutProperties(_ref, ['id', 'x', 'y', 'width', 'height']);\n  return react_default.a.createElement(\n    ClipPath,\n    { id: id },\n    react_default.a.createElement('rect', vx_clip_path_es_extends({ x: x, y: y, width: width, height: height }, restProps))\n  );\n});\n\n\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@vx/threshold/dist/vx-threshold.es.js\n\n\n\n\n\nvar vx_threshold_es_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction Threshold(_ref) {\n  var className = _ref.className,\n      curve = _ref.curve,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      clipAboveTo = _ref.clipAboveTo,\n      clipBelowTo = _ref.clipBelowTo,\n      data = _ref.data,\n      x = _ref.x,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      aboveAreaProps = _ref.aboveAreaProps,\n      belowAreaProps = _ref.belowAreaProps;\n\n  return react_default.a.createElement(\n    'g',\n    { className: classnames_default()('vx-threshold', className) },\n    react_default.a.createElement(\n      vx_shape_es_Area,\n      { curve: curve, data: data, x: x, y1: y1, xScale: xScale, yScale: yScale },\n      function (_ref2) {\n        var path = _ref2.path;\n\n        return react_default.a.createElement(\n          'g',\n          null,\n          react_default.a.createElement(\n            ClipPath,\n            { id: 'threshold-clip-below' },\n            react_default.a.createElement('path', { d: path.y0(clipBelowTo)(data) })\n          ),\n          react_default.a.createElement(\n            ClipPath,\n            { id: 'threshold-clip-above' },\n            react_default.a.createElement('path', { d: path.y0(clipAboveTo)(data) })\n          )\n        );\n      }\n    ),\n    react_default.a.createElement(vx_shape_es_Area, vx_threshold_es_extends({\n      curve: curve,\n      data: data,\n      x: x,\n      y0: y0,\n      y1: y1,\n      xScale: xScale,\n      yScale: yScale,\n      strokeWidth: 0,\n      clipPath: 'url(#threshold-clip-below)'\n    }, belowAreaProps)),\n    react_default.a.createElement(vx_shape_es_Area, vx_threshold_es_extends({\n      curve: curve,\n      data: data,\n      x: x,\n      y0: y0,\n      y1: y1,\n      xScale: xScale,\n      yScale: yScale,\n      strokeWidth: 0,\n      clipPath: 'url(#threshold-clip-above)'\n    }, aboveAreaProps))\n  );\n}\n\n\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/interpolatorLookup.js\nvar interpolatorLookup = __webpack_require__(2077);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/propShapes.js\nvar propShapes = __webpack_require__(1826);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/sharedSeriesProps.js\nvar sharedSeriesProps = __webpack_require__(1900);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/series/AreaDifferenceSeries.js\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction AreaDifferenceSeries_extends() { AreaDifferenceSeries_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return AreaDifferenceSeries_extends.apply(this, arguments); }\n\n\n\n\n\n\n\n\n\nvar propTypes = AreaDifferenceSeries_extends({}, sharedSeriesProps[\"a\" /* default */], {\n  children: prop_types_default.a.node.isRequired,\n  // AreaSeries type\n  interpolation: propShapes[\"d\" /* interpolationShape */]\n});\n\nvar defaultProps = {\n  interpolation: 'monotoneX'\n};\nvar DEFAULT_OPACITY = 0.4;\n\nvar AreaDifferenceSeries_getX = function getX(d) {\n  return d.x;\n};\n\nvar getY0 = function getY0(d) {\n  return d.y0;\n};\n\nvar getY1 = function getY1(d) {\n  return d.y1;\n};\n\nvar AreaDifferenceSeries_AreaDifferenceSeries =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(AreaDifferenceSeries, _React$PureComponent);\n\n  function AreaDifferenceSeries() {\n    return _React$PureComponent.apply(this, arguments) || this;\n  }\n\n  var _proto = AreaDifferenceSeries.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        disableMouseEvents = _this$props.disableMouseEvents,\n        interpolation = _this$props.interpolation,\n        xScale = _this$props.xScale,\n        yScale = _this$props.yScale,\n        onClick = _this$props.onClick,\n        onMouseMove = _this$props.onMouseMove,\n        onMouseLeave = _this$props.onMouseLeave,\n        children = _this$props.children,\n        margin = _this$props.margin;\n    if (!xScale || !yScale) return null;\n    var childArray = react[\"Children\"].toArray(children);\n    var child1 = childArray[0],\n        child2 = childArray[1];\n\n    if (childArray.length !== 2 || child1.type.displayName !== 'AreaSeries' || child2.type.displayName !== 'AreaSeries') {\n      console.warn('AreaDifferenceSeries expects exactly two AreaSeries children');\n      return null;\n    }\n\n    var _child1$props = child1.props,\n        data1 = _child1$props.data,\n        fill1 = _child1$props.fill,\n        opacity1 = _child1$props.fillOpacity;\n    var _child2$props = child2.props,\n        data2 = _child2$props.data,\n        fill2 = _child2$props.fill,\n        opacity2 = _child2$props.fillOpacity;\n\n    if (data1.length !== data2.length) {\n      console.warn('AreaDifferenceSeries children should have the same data length');\n      return null;\n    }\n\n    var curve = interpolatorLookup[\"a\" /* default */][interpolation] || interpolatorLookup[\"a\" /* default */].monotoneX;\n    var yExtent = yScale.range();\n    var mergedData = data1.map(function (d, i) {\n      return {\n        x: d.x,\n        y0: d.y,\n        y1: data2[i].y\n      };\n    });\n    return react_default.a.createElement(\"g\", null, react_default.a.createElement(Threshold, {\n      data: mergedData,\n      x: AreaDifferenceSeries_getX,\n      y0: getY0,\n      y1: getY1,\n      xScale: xScale,\n      yScale: yScale,\n      clipAboveTo: Math.min.apply(Math, yExtent),\n      clipBelowTo: Math.max.apply(Math, yExtent),\n      curve: curve,\n      aboveAreaProps: {\n        fill: fill1 || color[\"a\" /* default */].categories[0],\n        fillOpacity: opacity1 || DEFAULT_OPACITY\n      },\n      belowAreaProps: {\n        fill: fill2 || color[\"a\" /* default */].categories[0],\n        fillOpacity: opacity2 || DEFAULT_OPACITY\n      }\n    }), childArray.map(function (Child) {\n      return react_default.a.cloneElement(Child, {\n        xScale: xScale,\n        yScale: yScale,\n        onClick: onClick,\n        onMouseMove: onMouseMove,\n        onMouseLeave: onMouseLeave,\n        interpolation: interpolation,\n        disableMouseEvents: Child.props.disableMouseEvents || disableMouseEvents,\n        fill: 'transparent',\n        margin: margin\n      });\n    }));\n  };\n\n  return AreaDifferenceSeries;\n}(react_default.a.PureComponent);\n\n\nAreaDifferenceSeries_AreaDifferenceSeries.propTypes = propTypes;\nAreaDifferenceSeries_AreaDifferenceSeries.defaultProps = defaultProps;\nAreaDifferenceSeries_AreaDifferenceSeries.displayName = 'AreaDifferenceSeries';\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/chartUtils.js\nvar chartUtils = __webpack_require__(1835);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/collectVoronoiData.js\n\n\n // this function collects all data from child series to defines a voronoi overlay\n// because x,y coordinates are required to define a voronoi, it filters any points\n// with undefined x or y values\n\nfunction collectVoronoiData(_ref) {\n  var children = _ref.children,\n      getX = _ref.getX,\n      getY = _ref.getY;\n  return react[\"Children\"].toArray(children).reduce(function (result, Child) {\n    var name = Object(chartUtils[\"c\" /* componentName */])(Child);\n\n    if (Object(chartUtils[\"l\" /* isSeries */])(name) && !Child.props.disableMouseEvents) {\n      if (name === AreaDifferenceSeries_AreaDifferenceSeries.displayName) {\n        return result.concat(collectVoronoiData({\n          children: Child.props.children,\n          getX: getX,\n          getY: getY\n        }));\n      }\n\n      return result.concat(Child.props.data.filter(function (d) {\n        return Object(chartUtils[\"j\" /* isDefined */])(getX(d)) && Object(chartUtils[\"j\" /* isDefined */])(getY(d));\n      }));\n    }\n\n    return result;\n  }, []);\n}\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@vx/event/dist/vx-event.es.js\n\n\nfunction localPoint(node, event) {\n  // called with no args\n  if (!node) return;\n\n  // called with localPoint(event)\n  if (node.target) {\n    event = node;\n\n    // set node to targets owner svg\n    node = event.target.ownerSVGElement;\n\n    // find the outermost svg\n    while (node.ownerSVGElement) {\n      node = node.ownerSVGElement;\n    }\n  }\n\n  // default to mouse event\n  var _event = event,\n      clientX = _event.clientX,\n      clientY = _event.clientY;\n\n  // support touch event\n\n  if (event.changedTouches) {\n    clientX = event.changedTouches[0].clientX;\n    clientY = event.changedTouches[0].clientY;\n  }\n\n  // calculate coordinates from svg\n  if (node.createSVGPoint) {\n    var point = node.createSVGPoint();\n    point.x = clientX;\n    point.y = clientY;\n    point = point.matrixTransform(node.getScreenCTM().inverse());\n    return new vx_point_es[\"Point\"]({\n      x: point.x,\n      y: point.y\n    });\n  }\n\n  // fallback to calculating position from non-svg dom node\n  var rect = node.getBoundingClientRect();\n  return new vx_point_es[\"Point\"]({\n    x: clientX - rect.left - node.clientLeft,\n    y: clientY - rect.top - node.clientTop\n  });\n}\n\nfunction touchPoint(node, event) {\n  if (!node) return;\n  var svg = node.ownerSVGElement || node;\n  if (svg.createSVGPoint) {\n    var point = svg.createSVGPoint();\n    point.x = event.changedTouches[0].clientX;\n    point.y = event.changedTouches[0].clientY;\n    point = point.matrixTransform(node.getScreenCTM().inverse());\n    return new vx_point_es[\"Point\"]({\n      x: point.x,\n      y: point.y\n    });\n  }\n  var rect = node.getBoundingClientRect();\n  return new vx_point_es[\"Point\"]({\n    x: event.changedTouches[0].clientX - rect.left - node.clientLeft,\n    y: event.changedTouches[0].clientY - rect.top - node.clientTop\n  });\n}\n\n\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/findClosestDatum.js\nvar findClosestDatum = __webpack_require__(2120);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/findClosestDatums.js\n\n\n\n\nvar DEFAULT_MAX_DISTANCE_PX = 1000;\nfunction findClosestDatums(_ref) {\n  var children = _ref.children,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      _ref$margin = _ref.margin,\n      margin = _ref$margin === void 0 ? {} : _ref$margin,\n      getX = _ref.getX,\n      getY = _ref.getY,\n      event = _ref.event,\n      _ref$maxXDistancePx = _ref.maxXDistancePx,\n      maxXDistancePx = _ref$maxXDistancePx === void 0 ? DEFAULT_MAX_DISTANCE_PX : _ref$maxXDistancePx;\n  if (!event || !event.target || !event.target.ownerSVGElement) return null;\n  var series = {};\n  var gElement = event.target.ownerSVGElement;\n\n  var _localPoint = localPoint(gElement, event),\n      svgMouseX = _localPoint.x,\n      svgMouseY = _localPoint.y;\n\n  var mouseX = svgMouseX - (margin.left || 0);\n  var mouseY = svgMouseY - (margin.top || 0);\n  var closestDatum;\n  var minDeltaX = Infinity;\n  var minDeltaY = Infinity;\n  var flatSeriesChildren = [];\n  react[\"Children\"].forEach(children, function (Child) {\n    var name = Object(chartUtils[\"c\" /* componentName */])(Child);\n\n    if (name === 'AreaDifferenceSeries') {\n      react[\"Children\"].forEach(Child.props.children, function (NestedChild) {\n        flatSeriesChildren.push(NestedChild);\n      });\n    } else if (Object(chartUtils[\"l\" /* isSeries */])(name)) {\n      flatSeriesChildren.push(Child);\n    }\n  }); // collect data from all series that have an x value near this point\n\n  flatSeriesChildren.forEach(function (Child, childIndex) {\n    if (!Child.props.disableMouseEvents) {\n      var _Child$props = Child.props,\n          data = _Child$props.data,\n          seriesKey = _Child$props.seriesKey; // @TODO data should be sorted, come up with a way to enforce+cache instead of relying on user\n\n      var datum = Object(findClosestDatum[\"a\" /* default */])({\n        data: data,\n        getX: getX,\n        xScale: xScale,\n        event: event,\n        marginLeft: margin.left\n      });\n      var deltaX = Math.abs(xScale(getX(datum || {})) - mouseX);\n\n      if (datum && deltaX <= maxXDistancePx) {\n        var key = seriesKey || childIndex; // fall back to child index\n\n        series[key] = datum;\n        var deltaY = Math.abs(yScale(getY(datum)) - mouseY);\n        closestDatum = deltaY < minDeltaY && deltaX <= minDeltaX ? datum : closestDatum;\n        minDeltaX = closestDatum === datum ? deltaX : minDeltaX;\n        minDeltaY = closestDatum === datum ? deltaY : minDeltaY;\n      }\n    }\n  });\n  return {\n    series: series,\n    closestDatum: closestDatum\n  };\n}\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/shallowCompareObjectEntries.js\nfunction shallowCompareObjectEntries(a, b) {\n  var keysA = Object.keys(a);\n  var keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n  return keysA.every(function (k) {\n    return a[k] === b[k];\n  });\n}\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-voronoi/src/constant.js\n/* harmony default export */ var constant = (function(x) {\n  return function() {\n    return x;\n  };\n});\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-voronoi/src/point.js\nfunction point_x(d) {\n  return d[0];\n}\n\nfunction point_y(d) {\n  return d[1];\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-voronoi/src/RedBlackTree.js\nfunction RedBlackTree() {\n  this._ = null; // root node\n}\n\nfunction RedBlackNode(node) {\n  node.U = // parent node\n  node.C = // color - true for red, false for black\n  node.L = // left node\n  node.R = // right node\n  node.P = // previous node\n  node.N = null; // next node\n}\n\nRedBlackTree.prototype = {\n  constructor: RedBlackTree,\n\n  insert: function(after, node) {\n    var parent, grandpa, uncle;\n\n    if (after) {\n      node.P = after;\n      node.N = after.N;\n      if (after.N) after.N.P = node;\n      after.N = node;\n      if (after.R) {\n        after = after.R;\n        while (after.L) after = after.L;\n        after.L = node;\n      } else {\n        after.R = node;\n      }\n      parent = after;\n    } else if (this._) {\n      after = RedBlackFirst(this._);\n      node.P = null;\n      node.N = after;\n      after.P = after.L = node;\n      parent = after;\n    } else {\n      node.P = node.N = null;\n      this._ = node;\n      parent = null;\n    }\n    node.L = node.R = null;\n    node.U = parent;\n    node.C = true;\n\n    after = node;\n    while (parent && parent.C) {\n      grandpa = parent.U;\n      if (parent === grandpa.L) {\n        uncle = grandpa.R;\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.R) {\n            RedBlackRotateLeft(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateRight(this, grandpa);\n        }\n      } else {\n        uncle = grandpa.L;\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.L) {\n            RedBlackRotateRight(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateLeft(this, grandpa);\n        }\n      }\n      parent = after.U;\n    }\n    this._.C = false;\n  },\n\n  remove: function(node) {\n    if (node.N) node.N.P = node.P;\n    if (node.P) node.P.N = node.N;\n    node.N = node.P = null;\n\n    var parent = node.U,\n        sibling,\n        left = node.L,\n        right = node.R,\n        next,\n        red;\n\n    if (!left) next = right;\n    else if (!right) next = left;\n    else next = RedBlackFirst(right);\n\n    if (parent) {\n      if (parent.L === node) parent.L = next;\n      else parent.R = next;\n    } else {\n      this._ = next;\n    }\n\n    if (left && right) {\n      red = next.C;\n      next.C = node.C;\n      next.L = left;\n      left.U = next;\n      if (next !== right) {\n        parent = next.U;\n        next.U = node.U;\n        node = next.R;\n        parent.L = node;\n        next.R = right;\n        right.U = next;\n      } else {\n        next.U = parent;\n        parent = next;\n        node = next.R;\n      }\n    } else {\n      red = node.C;\n      node = next;\n    }\n\n    if (node) node.U = parent;\n    if (red) return;\n    if (node && node.C) { node.C = false; return; }\n\n    do {\n      if (node === this._) break;\n      if (node === parent.L) {\n        sibling = parent.R;\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateLeft(this, parent);\n          sibling = parent.R;\n        }\n        if ((sibling.L && sibling.L.C)\n            || (sibling.R && sibling.R.C)) {\n          if (!sibling.R || !sibling.R.C) {\n            sibling.L.C = false;\n            sibling.C = true;\n            RedBlackRotateRight(this, sibling);\n            sibling = parent.R;\n          }\n          sibling.C = parent.C;\n          parent.C = sibling.R.C = false;\n          RedBlackRotateLeft(this, parent);\n          node = this._;\n          break;\n        }\n      } else {\n        sibling = parent.L;\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateRight(this, parent);\n          sibling = parent.L;\n        }\n        if ((sibling.L && sibling.L.C)\n          || (sibling.R && sibling.R.C)) {\n          if (!sibling.L || !sibling.L.C) {\n            sibling.R.C = false;\n            sibling.C = true;\n            RedBlackRotateLeft(this, sibling);\n            sibling = parent.L;\n          }\n          sibling.C = parent.C;\n          parent.C = sibling.L.C = false;\n          RedBlackRotateRight(this, parent);\n          node = this._;\n          break;\n        }\n      }\n      sibling.C = true;\n      node = parent;\n      parent = parent.U;\n    } while (!node.C);\n\n    if (node) node.C = false;\n  }\n};\n\nfunction RedBlackRotateLeft(tree, node) {\n  var p = node,\n      q = node.R,\n      parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;\n    else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.R = q.L;\n  if (p.R) p.R.U = p;\n  q.L = p;\n}\n\nfunction RedBlackRotateRight(tree, node) {\n  var p = node,\n      q = node.L,\n      parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;\n    else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.L = q.R;\n  if (p.L) p.L.U = p;\n  q.R = p;\n}\n\nfunction RedBlackFirst(node) {\n  while (node.L) node = node.L;\n  return node;\n}\n\n/* harmony default export */ var src_RedBlackTree = (RedBlackTree);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-voronoi/src/Edge.js\n\n\nfunction createEdge(left, right, v0, v1) {\n  var edge = [null, null],\n      index = Diagram_edges.push(edge) - 1;\n  edge.left = left;\n  edge.right = right;\n  if (v0) setEdgeEnd(edge, left, right, v0);\n  if (v1) setEdgeEnd(edge, right, left, v1);\n  cells[left.index].halfedges.push(index);\n  cells[right.index].halfedges.push(index);\n  return edge;\n}\n\nfunction createBorderEdge(left, v0, v1) {\n  var edge = [v0, v1];\n  edge.left = left;\n  return edge;\n}\n\nfunction setEdgeEnd(edge, left, right, vertex) {\n  if (!edge[0] && !edge[1]) {\n    edge[0] = vertex;\n    edge.left = left;\n    edge.right = right;\n  } else if (edge.left === right) {\n    edge[1] = vertex;\n  } else {\n    edge[0] = vertex;\n  }\n}\n\n// LiangâBarsky line clipping.\nfunction clipEdge(edge, x0, y0, x1, y1) {\n  var a = edge[0],\n      b = edge[1],\n      ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?\n\n  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];\n  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];\n  return true;\n}\n\nfunction connectEdge(edge, x0, y0, x1, y1) {\n  var v1 = edge[1];\n  if (v1) return true;\n\n  var v0 = edge[0],\n      left = edge.left,\n      right = edge.right,\n      lx = left[0],\n      ly = left[1],\n      rx = right[0],\n      ry = right[1],\n      fx = (lx + rx) / 2,\n      fy = (ly + ry) / 2,\n      fm,\n      fb;\n\n  if (ry === ly) {\n    if (fx < x0 || fx >= x1) return;\n    if (lx > rx) {\n      if (!v0) v0 = [fx, y0];\n      else if (v0[1] >= y1) return;\n      v1 = [fx, y1];\n    } else {\n      if (!v0) v0 = [fx, y1];\n      else if (v0[1] < y0) return;\n      v1 = [fx, y0];\n    }\n  } else {\n    fm = (lx - rx) / (ry - ly);\n    fb = fy - fm * fx;\n    if (fm < -1 || fm > 1) {\n      if (lx > rx) {\n        if (!v0) v0 = [(y0 - fb) / fm, y0];\n        else if (v0[1] >= y1) return;\n        v1 = [(y1 - fb) / fm, y1];\n      } else {\n        if (!v0) v0 = [(y1 - fb) / fm, y1];\n        else if (v0[1] < y0) return;\n        v1 = [(y0 - fb) / fm, y0];\n      }\n    } else {\n      if (ly < ry) {\n        if (!v0) v0 = [x0, fm * x0 + fb];\n        else if (v0[0] >= x1) return;\n        v1 = [x1, fm * x1 + fb];\n      } else {\n        if (!v0) v0 = [x1, fm * x1 + fb];\n        else if (v0[0] < x0) return;\n        v1 = [x0, fm * x0 + fb];\n      }\n    }\n  }\n\n  edge[0] = v0;\n  edge[1] = v1;\n  return true;\n}\n\nfunction clipEdges(x0, y0, x1, y1) {\n  var i = Diagram_edges.length,\n      edge;\n\n  while (i--) {\n    if (!connectEdge(edge = Diagram_edges[i], x0, y0, x1, y1)\n        || !clipEdge(edge, x0, y0, x1, y1)\n        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon\n            || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {\n      delete Diagram_edges[i];\n    }\n  }\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-voronoi/src/Cell.js\n\n\n\nfunction createCell(site) {\n  return cells[site.index] = {\n    site: site,\n    halfedges: []\n  };\n}\n\nfunction cellHalfedgeAngle(cell, edge) {\n  var site = cell.site,\n      va = edge.left,\n      vb = edge.right;\n  if (site === vb) vb = va, va = site;\n  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n  if (site === va) va = edge[1], vb = edge[0];\n  else va = edge[0], vb = edge[1];\n  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n}\n\nfunction cellHalfedgeStart(cell, edge) {\n  return edge[+(edge.left !== cell.site)];\n}\n\nfunction cellHalfedgeEnd(cell, edge) {\n  return edge[+(edge.left === cell.site)];\n}\n\nfunction sortCellHalfedges() {\n  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n      var index = new Array(m),\n          array = new Array(m);\n      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, Diagram_edges[halfedges[j]]);\n      index.sort(function(i, j) { return array[j] - array[i]; });\n      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];\n      for (j = 0; j < m; ++j) halfedges[j] = array[j];\n    }\n  }\n}\n\nfunction clipCells(x0, y0, x1, y1) {\n  var nCells = cells.length,\n      iCell,\n      cell,\n      site,\n      iHalfedge,\n      halfedges,\n      nHalfedges,\n      start,\n      startX,\n      startY,\n      end,\n      endX,\n      endY,\n      cover = true;\n\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      site = cell.site;\n      halfedges = cell.halfedges;\n      iHalfedge = halfedges.length;\n\n      // Remove any dangling clipped edges.\n      while (iHalfedge--) {\n        if (!Diagram_edges[halfedges[iHalfedge]]) {\n          halfedges.splice(iHalfedge, 1);\n        }\n      }\n\n      // Insert any border edges as necessary.\n      iHalfedge = 0, nHalfedges = halfedges.length;\n      while (iHalfedge < nHalfedges) {\n        end = cellHalfedgeEnd(cell, Diagram_edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n        start = cellHalfedgeStart(cell, Diagram_edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {\n          halfedges.splice(iHalfedge, 0, Diagram_edges.push(createBorderEdge(site, end,\n              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]\n              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]\n              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]\n              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]\n              : null)) - 1);\n          ++nHalfedges;\n        }\n      }\n\n      if (nHalfedges) cover = false;\n    }\n  }\n\n  // If there werenât any edges, have the closest site cover the extent.\n  // It doesnât matter which corner of the extent we measure!\n  if (cover) {\n    var dx, dy, d2, dc = Infinity;\n\n    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n      if (cell = cells[iCell]) {\n        site = cell.site;\n        dx = site[0] - x0;\n        dy = site[1] - y0;\n        d2 = dx * dx + dy * dy;\n        if (d2 < dc) dc = d2, cover = cell;\n      }\n    }\n\n    if (cover) {\n      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\n      cover.halfedges.push(\n        Diagram_edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,\n        Diagram_edges.push(createBorderEdge(site, v01, v11)) - 1,\n        Diagram_edges.push(createBorderEdge(site, v11, v10)) - 1,\n        Diagram_edges.push(createBorderEdge(site, v10, v00)) - 1\n      );\n    }\n  }\n\n  // Lastly delete any cells with no edges; these were entirely clipped.\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      if (!cell.halfedges.length) {\n        delete cells[iCell];\n      }\n    }\n  }\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-voronoi/src/Circle.js\n\n\n\nvar circlePool = [];\n\nvar firstCircle;\n\nfunction Circle() {\n  RedBlackNode(this);\n  this.x =\n  this.y =\n  this.arc =\n  this.site =\n  this.cy = null;\n}\n\nfunction attachCircle(arc) {\n  var lArc = arc.P,\n      rArc = arc.N;\n\n  if (!lArc || !rArc) return;\n\n  var lSite = lArc.site,\n      cSite = arc.site,\n      rSite = rArc.site;\n\n  if (lSite === rSite) return;\n\n  var bx = cSite[0],\n      by = cSite[1],\n      ax = lSite[0] - bx,\n      ay = lSite[1] - by,\n      cx = rSite[0] - bx,\n      cy = rSite[1] - by;\n\n  var d = 2 * (ax * cy - ay * cx);\n  if (d >= -epsilon2) return;\n\n  var ha = ax * ax + ay * ay,\n      hc = cx * cx + cy * cy,\n      x = (cy * ha - ay * hc) / d,\n      y = (ax * hc - cx * ha) / d;\n\n  var circle = circlePool.pop() || new Circle;\n  circle.arc = arc;\n  circle.site = cSite;\n  circle.x = x + bx;\n  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom\n\n  arc.circle = circle;\n\n  var before = null,\n      node = circles._;\n\n  while (node) {\n    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {\n      if (node.L) node = node.L;\n      else { before = node.P; break; }\n    } else {\n      if (node.R) node = node.R;\n      else { before = node; break; }\n    }\n  }\n\n  circles.insert(before, circle);\n  if (!before) firstCircle = circle;\n}\n\nfunction detachCircle(arc) {\n  var circle = arc.circle;\n  if (circle) {\n    if (!circle.P) firstCircle = circle.N;\n    circles.remove(circle);\n    circlePool.push(circle);\n    RedBlackNode(circle);\n    arc.circle = null;\n  }\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-voronoi/src/Beach.js\n\n\n\n\n\n\nvar beachPool = [];\n\nfunction Beach() {\n  RedBlackNode(this);\n  this.edge =\n  this.site =\n  this.circle = null;\n}\n\nfunction createBeach(site) {\n  var beach = beachPool.pop() || new Beach;\n  beach.site = site;\n  return beach;\n}\n\nfunction detachBeach(beach) {\n  detachCircle(beach);\n  beaches.remove(beach);\n  beachPool.push(beach);\n  RedBlackNode(beach);\n}\n\nfunction removeBeach(beach) {\n  var circle = beach.circle,\n      x = circle.x,\n      y = circle.cy,\n      vertex = [x, y],\n      previous = beach.P,\n      next = beach.N,\n      disappearing = [beach];\n\n  detachBeach(beach);\n\n  var lArc = previous;\n  while (lArc.circle\n      && Math.abs(x - lArc.circle.x) < epsilon\n      && Math.abs(y - lArc.circle.cy) < epsilon) {\n    previous = lArc.P;\n    disappearing.unshift(lArc);\n    detachBeach(lArc);\n    lArc = previous;\n  }\n\n  disappearing.unshift(lArc);\n  detachCircle(lArc);\n\n  var rArc = next;\n  while (rArc.circle\n      && Math.abs(x - rArc.circle.x) < epsilon\n      && Math.abs(y - rArc.circle.cy) < epsilon) {\n    next = rArc.N;\n    disappearing.push(rArc);\n    detachBeach(rArc);\n    rArc = next;\n  }\n\n  disappearing.push(rArc);\n  detachCircle(rArc);\n\n  var nArcs = disappearing.length,\n      iArc;\n  for (iArc = 1; iArc < nArcs; ++iArc) {\n    rArc = disappearing[iArc];\n    lArc = disappearing[iArc - 1];\n    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n  }\n\n  lArc = disappearing[0];\n  rArc = disappearing[nArcs - 1];\n  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);\n\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nfunction addBeach(site) {\n  var x = site[0],\n      directrix = site[1],\n      lArc,\n      rArc,\n      dxl,\n      dxr,\n      node = beaches._;\n\n  while (node) {\n    dxl = leftBreakPoint(node, directrix) - x;\n    if (dxl > epsilon) node = node.L; else {\n      dxr = x - rightBreakPoint(node, directrix);\n      if (dxr > epsilon) {\n        if (!node.R) {\n          lArc = node;\n          break;\n        }\n        node = node.R;\n      } else {\n        if (dxl > -epsilon) {\n          lArc = node.P;\n          rArc = node;\n        } else if (dxr > -epsilon) {\n          lArc = node;\n          rArc = node.N;\n        } else {\n          lArc = rArc = node;\n        }\n        break;\n      }\n    }\n  }\n\n  createCell(site);\n  var newArc = createBeach(site);\n  beaches.insert(lArc, newArc);\n\n  if (!lArc && !rArc) return;\n\n  if (lArc === rArc) {\n    detachCircle(lArc);\n    rArc = createBeach(lArc.site);\n    beaches.insert(newArc, rArc);\n    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);\n    attachCircle(lArc);\n    attachCircle(rArc);\n    return;\n  }\n\n  if (!rArc) { // && lArc\n    newArc.edge = createEdge(lArc.site, newArc.site);\n    return;\n  }\n\n  // else lArc !== rArc\n  detachCircle(lArc);\n  detachCircle(rArc);\n\n  var lSite = lArc.site,\n      ax = lSite[0],\n      ay = lSite[1],\n      bx = site[0] - ax,\n      by = site[1] - ay,\n      rSite = rArc.site,\n      cx = rSite[0] - ax,\n      cy = rSite[1] - ay,\n      d = 2 * (bx * cy - by * cx),\n      hb = bx * bx + by * by,\n      hc = cx * cx + cy * cy,\n      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];\n\n  setEdgeEnd(rArc.edge, lSite, rSite, vertex);\n  newArc.edge = createEdge(lSite, site, null, vertex);\n  rArc.edge = createEdge(site, rSite, null, vertex);\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nfunction leftBreakPoint(arc, directrix) {\n  var site = arc.site,\n      rfocx = site[0],\n      rfocy = site[1],\n      pby2 = rfocy - directrix;\n\n  if (!pby2) return rfocx;\n\n  var lArc = arc.P;\n  if (!lArc) return -Infinity;\n\n  site = lArc.site;\n  var lfocx = site[0],\n      lfocy = site[1],\n      plby2 = lfocy - directrix;\n\n  if (!plby2) return lfocx;\n\n  var hl = lfocx - rfocx,\n      aby2 = 1 / pby2 - 1 / plby2,\n      b = hl / plby2;\n\n  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n\n  return (rfocx + lfocx) / 2;\n}\n\nfunction rightBreakPoint(arc, directrix) {\n  var rArc = arc.N;\n  if (rArc) return leftBreakPoint(rArc, directrix);\n  var site = arc.site;\n  return site[1] === directrix ? site[0] : Infinity;\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-voronoi/src/Diagram.js\n\n\n\n\n\n\nvar epsilon = 1e-6;\nvar epsilon2 = 1e-12;\nvar beaches;\nvar cells;\nvar circles;\nvar Diagram_edges;\n\nfunction triangleArea(a, b, c) {\n  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);\n}\n\nfunction lexicographic(a, b) {\n  return b[1] - a[1]\n      || b[0] - a[0];\n}\n\nfunction Diagram(sites, extent) {\n  var site = sites.sort(lexicographic).pop(),\n      x,\n      y,\n      circle;\n\n  Diagram_edges = [];\n  cells = new Array(sites.length);\n  beaches = new src_RedBlackTree;\n  circles = new src_RedBlackTree;\n\n  while (true) {\n    circle = firstCircle;\n    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {\n      if (site[0] !== x || site[1] !== y) {\n        addBeach(site);\n        x = site[0], y = site[1];\n      }\n      site = sites.pop();\n    } else if (circle) {\n      removeBeach(circle.arc);\n    } else {\n      break;\n    }\n  }\n\n  sortCellHalfedges();\n\n  if (extent) {\n    var x0 = +extent[0][0],\n        y0 = +extent[0][1],\n        x1 = +extent[1][0],\n        y1 = +extent[1][1];\n    clipEdges(x0, y0, x1, y1);\n    clipCells(x0, y0, x1, y1);\n  }\n\n  this.edges = Diagram_edges;\n  this.cells = cells;\n\n  beaches =\n  circles =\n  Diagram_edges =\n  cells = null;\n}\n\nDiagram.prototype = {\n  constructor: Diagram,\n\n  polygons: function() {\n    var edges = this.edges;\n\n    return this.cells.map(function(cell) {\n      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });\n      polygon.data = cell.site.data;\n      return polygon;\n    });\n  },\n\n  triangles: function() {\n    var triangles = [],\n        edges = this.edges;\n\n    this.cells.forEach(function(cell, i) {\n      if (!(m = (halfedges = cell.halfedges).length)) return;\n      var site = cell.site,\n          halfedges,\n          j = -1,\n          m,\n          s0,\n          e1 = edges[halfedges[m - 1]],\n          s1 = e1.left === site ? e1.right : e1.left;\n\n      while (++j < m) {\n        s0 = s1;\n        e1 = edges[halfedges[j]];\n        s1 = e1.left === site ? e1.right : e1.left;\n        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {\n          triangles.push([site.data, s0.data, s1.data]);\n        }\n      }\n    });\n\n    return triangles;\n  },\n\n  links: function() {\n    return this.edges.filter(function(edge) {\n      return edge.right;\n    }).map(function(edge) {\n      return {\n        source: edge.left.data,\n        target: edge.right.data\n      };\n    });\n  },\n\n  find: function(x, y, radius) {\n    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;\n\n    // Use the previously-found cell, or start with an arbitrary one.\n    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;\n    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;\n\n    // Traverse the half-edges to find a closer cell, if any.\n    do {\n      cell = that.cells[i0 = i1], i1 = null;\n      cell.halfedges.forEach(function(e) {\n        var edge = that.edges[e], v = edge.left;\n        if ((v === cell.site || !v) && !(v = edge.right)) return;\n        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;\n        if (v2 < d2) d2 = v2, i1 = v.index;\n      });\n    } while (i1 !== null);\n\n    that._found = i0;\n\n    return radius == null || d2 <= radius * radius ? cell.site : null;\n  }\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-voronoi/src/voronoi.js\n\n\n\n\n/* harmony default export */ var src_voronoi = (function() {\n  var x = point_x,\n      y = point_y,\n      extent = null;\n\n  function voronoi(data) {\n    return new Diagram(data.map(function(d, i) {\n      var s = [Math.round(x(d, i, data) / epsilon) * epsilon, Math.round(y(d, i, data) / epsilon) * epsilon];\n      s.index = i;\n      s.data = d;\n      return s;\n    }), extent);\n  }\n\n  voronoi.polygons = function(data) {\n    return voronoi(data).polygons();\n  };\n\n  voronoi.links = function(data) {\n    return voronoi(data).links();\n  };\n\n  voronoi.triangles = function(data) {\n    return voronoi(data).triangles();\n  };\n\n  voronoi.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), voronoi) : x;\n  };\n\n  voronoi.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), voronoi) : y;\n  };\n\n  voronoi.extent = function(_) {\n    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];\n  };\n\n  voronoi.size = function(_) {\n    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];\n  };\n\n  return voronoi;\n});\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-voronoi/src/index.js\n\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@vx/voronoi/dist/vx-voronoi.es.js\n\n\n\n\n\n// returns a d3 voronoi *layout*, for a voronoi *diagram* call `layout(data)`\n\nvar voronoi$1 = (function (_ref) {\n  var _ref$width = _ref.width,\n      width = _ref$width === undefined ? 0 : _ref$width,\n      _ref$height = _ref.height,\n      height = _ref$height === undefined ? 0 : _ref$height,\n      x = _ref.x,\n      y = _ref.y;\n\n  var voronoi$$1 = src_voronoi();\n\n  if (x) voronoi$$1.x(x);\n  if (y) voronoi$$1.y(y);\n\n  voronoi$$1.extent([[-1, -1], [width + 1, height + 1]]);\n\n  return voronoi$$1;\n});\n\nfunction vx_voronoi_es_callOrValue(maybeFn, data) {\n  if (typeof maybeFn === 'function') {\n    return maybeFn(data);\n  }\n  return maybeFn;\n}\n\nfunction vx_voronoi_es_additionalProps(restProps, data) {\n  return Object.keys(restProps).reduce(function (ret, cur) {\n    ret[cur] = vx_voronoi_es_callOrValue(restProps[cur], data);\n    return ret;\n  }, {});\n}\n\nvar vx_voronoi_es_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar vx_voronoi_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar vx_voronoi_es_propTypes = {\n  polygon: prop_types_default.a.arrayOf(prop_types_default.a.array)\n};\n\nfunction VoronoiPolygon(_ref) {\n  var polygon = _ref.polygon,\n      className = _ref.className,\n      restProps = vx_voronoi_es_objectWithoutProperties(_ref, ['polygon', 'className']);\n\n  if (!polygon) return null;\n  var data = polygon.data;\n  return react_default.a.createElement('path', vx_voronoi_es_extends({\n    className: classnames_default()('vx-voronoi-polygon', className),\n    d: 'M' + polygon.join('L') + 'Z'\n  }, vx_voronoi_es_additionalProps(restProps, data)));\n}\n\nVoronoiPolygon.propTypes = vx_voronoi_es_propTypes;\n\n\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/chart/Voronoi.js\nfunction Voronoi_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/* eslint react/no-array-index-key: 0, react/no-unused-prop-types: 0 */\n\n\n\n\nvar Voronoi_propTypes = {\n  data: prop_types_default.a.arrayOf(prop_types_default.a.object).isRequired,\n  onClick: prop_types_default.a.func,\n  onMouseMove: prop_types_default.a.func,\n  onMouseLeave: prop_types_default.a.func,\n  onMouseDown: prop_types_default.a.func,\n  showVoronoi: prop_types_default.a.bool,\n  width: prop_types_default.a.number.isRequired,\n  height: prop_types_default.a.number.isRequired,\n  x: prop_types_default.a.func.isRequired,\n  y: prop_types_default.a.func.isRequired\n};\nvar Voronoi_defaultProps = {\n  onClick: null,\n  onMouseMove: null,\n  onMouseLeave: null,\n  onMouseDown: null,\n  showVoronoi: false\n};\n\nvar Voronoi_Voronoi =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  Voronoi_inheritsLoose(Voronoi, _React$PureComponent);\n\n  Voronoi.getVoronoi = function getVoronoi(props) {\n    var x = props.x,\n        y = props.y,\n        data = props.data,\n        width = props.width,\n        height = props.height;\n    return voronoi$1({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    })(data);\n  };\n\n  function Voronoi(props) {\n    var _this;\n\n    _this = _React$PureComponent.call(this, props) || this;\n    _this.state = {\n      voronoi: Voronoi.getVoronoi(props)\n    };\n    return _this;\n  }\n\n  var _proto = Voronoi.prototype;\n\n  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _this2 = this;\n\n    if (['data', 'x', 'y', 'width', 'height'].some(function (prop) {\n      return _this2.props[prop] !== nextProps[prop];\n    } // eslint-disable-line react/destructuring-assignment\n    )) {\n      this.setState({\n        voronoi: Voronoi.getVoronoi(nextProps)\n      });\n    }\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        onMouseLeave = _this$props.onMouseLeave,\n        onMouseMove = _this$props.onMouseMove,\n        onClick = _this$props.onClick,\n        showVoronoi = _this$props.showVoronoi,\n        onMouseDown = _this$props.onMouseDown;\n    var voronoi = this.state.voronoi;\n    return react_default.a.createElement(vx_group_es[\"a\" /* Group */], null, voronoi.polygons().map(function (polygon, i) {\n      return react_default.a.createElement(VoronoiPolygon, {\n        key: \"voronoi-\" + polygon.length + \"-\" + i,\n        polygon: polygon,\n        fill: \"transparent\",\n        stroke: showVoronoi ? '#ddd' : 'transparent',\n        strokeWidth: 1,\n        onClick: onClick && function () {\n          return function (event) {\n            onClick({\n              event: event,\n              datum: polygon.data\n            });\n          };\n        },\n        onMouseMove: onMouseMove && function () {\n          return function (event) {\n            onMouseMove({\n              event: event,\n              datum: polygon.data\n            });\n          };\n        },\n        onMouseLeave: onMouseLeave && function () {\n          return onMouseLeave;\n        },\n        onMouseDown: onMouseDown && function () {\n          return onMouseDown;\n        }\n      });\n    }));\n  };\n\n  return Voronoi;\n}(react_default.a.PureComponent);\n\nVoronoi_Voronoi.propTypes = Voronoi_propTypes;\nVoronoi_Voronoi.defaultProps = Voronoi_defaultProps;\nVoronoi_Voronoi.displayName = 'Voronoi';\n/* harmony default export */ var chart_Voronoi = (Voronoi_Voronoi);\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/collectDataFromChildSeries.js\n\n\n\nfunction collectDataFromChildSeries(children) {\n  var allData = [];\n  react[\"Children\"].forEach(children, function (Child) {\n    if (Child && Child.props) {\n      var data = Child.props.data;\n      var name = Object(chartUtils[\"c\" /* componentName */])(Child);\n\n      if (name === AreaDifferenceSeries_AreaDifferenceSeries.displayName) {\n        allData = allData.concat(collectDataFromChildSeries(Child.props.children));\n      } else if (data && Object(chartUtils[\"l\" /* isSeries */])(name)) {\n        allData = allData.concat(Child.props.data);\n      }\n    }\n  });\n  return allData;\n}\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/getChartDimensions.js\nfunction getChartDimensions_extends() { getChartDimensions_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return getChartDimensions_extends.apply(this, arguments); }\n\n\nfunction getChartDimensions(_ref) {\n  var margin = _ref.margin,\n      width = _ref.width,\n      height = _ref.height;\n\n  var completeMargin = getChartDimensions_extends({}, chartUtils[\"a\" /* DEFAULT_CHART_MARGIN */], margin);\n\n  return {\n    margin: completeMargin,\n    innerHeight: Math.max(0, height - completeMargin.top - completeMargin.bottom),\n    innerWidth: Math.max(0, width - completeMargin.left - completeMargin.right)\n  };\n}\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-array/src/index.js + 31 modules\nvar src = __webpack_require__(324);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/init.js\nfunction initRange(domain, range) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.range(domain); break;\n    default: this.range(range).domain(domain); break;\n  }\n  return this;\n}\n\nfunction initInterpolator(domain, interpolator) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.interpolator(domain); break;\n    default: this.interpolator(interpolator).domain(domain); break;\n  }\n  return this;\n}\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-collection/src/index.js + 6 modules\nvar d3_collection_src = __webpack_require__(805);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/array.js\nvar array_array = Array.prototype;\n\nvar map = array_array.map;\nvar slice = array_array.slice;\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/ordinal.js\n\n\n\n\nvar implicit = {name: \"implicit\"};\n\nfunction ordinal() {\n  var index = Object(d3_collection_src[\"map\"])(),\n      domain = [],\n      range = [],\n      unknown = implicit;\n\n  function scale(d) {\n    var key = d + \"\", i = index.get(key);\n    if (!i) {\n      if (unknown !== implicit) return unknown;\n      index.set(key, i = domain.push(d));\n    }\n    return range[(i - 1) % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [], index = Object(d3_collection_src[\"map\"])();\n    var i = -1, n = _.length, d, key;\n    while (++i < n) if (!index.has(key = (d = _[i]) + \"\")) index.set(key, domain.push(d));\n    return scale;\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), scale) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return ordinal(domain, range).unknown(unknown);\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/band.js\n\n\n\n\nfunction band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse];\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = Object(src[\"range\"])(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = [+_[0], +_[1]], round = true, rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;\n  };\n\n  scale.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function() {\n    return band(domain(), range)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return initRange.apply(rescale(), arguments);\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  delete scale.paddingOuter;\n\n  scale.copy = function() {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nfunction band_point() {\n  return pointish(band.apply(null, arguments).paddingInner(1));\n}\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-interpolate/src/value.js\nvar src_value = __webpack_require__(167);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-interpolate/src/number.js\nvar number = __webpack_require__(84);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-interpolate/src/round.js\nvar src_round = __webpack_require__(399);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/constant.js\n/* harmony default export */ var src_constant = (function(x) {\n  return function() {\n    return x;\n  };\n});\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/number.js\n/* harmony default export */ var src_number = (function(x) {\n  return +x;\n});\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/continuous.js\n\n\n\n\n\n\nvar unit = [0, 1];\n\nfunction identity(x) {\n  return x;\n}\n\nfunction normalize(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : src_constant(isNaN(b) ? NaN : 0.5);\n}\n\nfunction clamper(domain) {\n  var a = domain[0], b = domain[domain.length - 1], t;\n  if (a > b) t = a, a = b, b = t;\n  return function(x) { return Math.max(a, Math.min(b, x)); };\n}\n\n// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].\nfunction bimap(domain, range, interpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];\n  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);\n  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction polymap(domain, range, interpolate) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = normalize(domain[i], domain[i + 1]);\n    r[i] = interpolate(range[i], range[i + 1]);\n  }\n\n  return function(x) {\n    var i = Object(src[\"bisect\"])(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nfunction copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nfunction transformer() {\n  var domain = unit,\n      range = unit,\n      interpolate = src_value[\"a\" /* default */],\n      transform,\n      untransform,\n      unknown,\n      clamp = identity,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));\n  }\n\n  scale.invert = function(y) {\n    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), number[\"a\" /* default */])))(y)));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = map.call(_, src_number), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = slice.call(_), interpolate = src_round[\"a\" /* default */], rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t, u) {\n    transform = t, untransform = u;\n    return rescale();\n  };\n}\n\nfunction continuous(transform, untransform) {\n  return transformer()(transform, untransform);\n}\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-format/src/formatSpecifier.js\nvar formatSpecifier = __webpack_require__(356);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-format/src/precisionPrefix.js\nvar precisionPrefix = __webpack_require__(1131);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-format/src/defaultLocale.js\nvar defaultLocale = __webpack_require__(197);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-format/src/precisionRound.js\nvar precisionRound = __webpack_require__(1132);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-format/src/precisionFixed.js\nvar precisionFixed = __webpack_require__(1133);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/tickFormat.js\n\n\n\n/* harmony default export */ var src_tickFormat = (function(start, stop, count, specifier) {\n  var step = Object(src[\"tickStep\"])(start, stop, count),\n      precision;\n  specifier = Object(formatSpecifier[\"b\" /* default */])(specifier == null ? \",f\" : specifier);\n  switch (specifier.type) {\n    case \"s\": {\n      var value = Math.max(Math.abs(start), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = Object(precisionPrefix[\"a\" /* default */])(step, value))) specifier.precision = precision;\n      return Object(defaultLocale[\"c\" /* formatPrefix */])(specifier, value);\n    }\n    case \"\":\n    case \"e\":\n    case \"g\":\n    case \"p\":\n    case \"r\": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionRound[\"a\" /* default */])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === \"e\");\n      break;\n    }\n    case \"f\":\n    case \"%\": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionFixed[\"a\" /* default */])(step))) specifier.precision = precision - (specifier.type === \"%\") * 2;\n      break;\n    }\n  }\n  return Object(defaultLocale[\"b\" /* format */])(specifier);\n});\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/linear.js\n\n\n\n\n\nfunction linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function(count) {\n    var d = domain();\n    return Object(src[\"ticks\"])(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    var d = domain();\n    return src_tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);\n  };\n\n  scale.nice = function(count) {\n    if (count == null) count = 10;\n\n    var d = domain(),\n        i0 = 0,\n        i1 = d.length - 1,\n        start = d[i0],\n        stop = d[i1],\n        step;\n\n    if (stop < start) {\n      step = start, start = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n\n    step = Object(src[\"tickIncrement\"])(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = Object(src[\"tickIncrement\"])(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = Object(src[\"tickIncrement\"])(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      domain(d);\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\n\nfunction linear_linear() {\n  var scale = continuous(identity, identity);\n\n  scale.copy = function() {\n    return copy(scale, linear_linear());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/identity.js\n\n\n\n\nfunction identity_identity(domain) {\n  var unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : x;\n  }\n\n  scale.invert = scale;\n\n  scale.domain = scale.range = function(_) {\n    return arguments.length ? (domain = map.call(_, src_number), scale) : domain.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return identity_identity(domain).unknown(unknown);\n  };\n\n  domain = arguments.length ? map.call(domain, src_number) : [0, 1];\n\n  return linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/nice.js\n/* harmony default export */ var src_nice = (function(domain, interval) {\n  domain = domain.slice();\n\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      t;\n\n  if (x1 < x0) {\n    t = i0, i0 = i1, i1 = t;\n    t = x0, x0 = x1, x1 = t;\n  }\n\n  domain[i0] = interval.floor(x0);\n  domain[i1] = interval.ceil(x1);\n  return domain;\n});\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/log.js\n\n\n\n\n\n\nfunction transformLog(x) {\n  return Math.log(x);\n}\n\nfunction transformExp(x) {\n  return Math.exp(x);\n}\n\nfunction transformLogn(x) {\n  return -Math.log(-x);\n}\n\nfunction transformExpn(x) {\n  return -Math.exp(-x);\n}\n\nfunction pow10(x) {\n  return isFinite(x) ? +(\"1e\" + x) : x < 0 ? 0 : x;\n}\n\nfunction powp(base) {\n  return base === 10 ? pow10\n      : base === Math.E ? Math.exp\n      : function(x) { return Math.pow(base, x); };\n}\n\nfunction logp(base) {\n  return base === Math.E ? Math.log\n      : base === 10 && Math.log10\n      || base === 2 && Math.log2\n      || (base = Math.log(base), function(x) { return Math.log(x) / base; });\n}\n\nfunction reflect(f) {\n  return function(x) {\n    return -f(-x);\n  };\n}\n\nfunction loggish(transform) {\n  var scale = transform(transformLog, transformExp),\n      domain = scale.domain,\n      base = 10,\n      logs,\n      pows;\n\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) {\n      logs = reflect(logs), pows = reflect(pows);\n      transform(transformLogn, transformExpn);\n    } else {\n      transform(transformLog, transformExp);\n    }\n    return scale;\n  }\n\n  scale.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.ticks = function(count) {\n    var d = domain(),\n        u = d[0],\n        v = d[d.length - 1],\n        r;\n\n    if (r = v < u) i = u, u = v, v = i;\n\n    var i = logs(u),\n        j = logs(v),\n        p,\n        k,\n        t,\n        n = count == null ? 10 : +count,\n        z = [];\n\n    if (!(base % 1) && j - i < n) {\n      i = Math.round(i) - 1, j = Math.round(j) + 1;\n      if (u > 0) for (; i < j; ++i) {\n        for (k = 1, p = pows(i); k < base; ++k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      } else for (; i < j; ++i) {\n        for (k = base - 1, p = pows(i); k >= 1; --k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      }\n    } else {\n      z = Object(src[\"ticks\"])(i, j, Math.min(j - i, n)).map(pows);\n    }\n\n    return r ? z.reverse() : z;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    if (specifier == null) specifier = base === 10 ? \".0e\" : \",\";\n    if (typeof specifier !== \"function\") specifier = Object(defaultLocale[\"b\" /* format */])(specifier);\n    if (count === Infinity) return specifier;\n    if (count == null) count = 10;\n    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n    return function(d) {\n      var i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5) i *= base;\n      return i <= k ? specifier(d) : \"\";\n    };\n  };\n\n  scale.nice = function() {\n    return domain(src_nice(domain(), {\n      floor: function(x) { return pows(Math.floor(logs(x))); },\n      ceil: function(x) { return pows(Math.ceil(logs(x))); }\n    }));\n  };\n\n  return scale;\n}\n\nfunction log() {\n  var scale = loggish(transformer()).domain([1, 10]);\n\n  scale.copy = function() {\n    return copy(scale, log()).base(scale.base());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/symlog.js\n\n\n\n\nfunction transformSymlog(c) {\n  return function(x) {\n    return Math.sign(x) * Math.log1p(Math.abs(x / c));\n  };\n}\n\nfunction transformSymexp(c) {\n  return function(x) {\n    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;\n  };\n}\n\nfunction symlogish(transform) {\n  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));\n\n  scale.constant = function(_) {\n    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;\n  };\n\n  return linearish(scale);\n}\n\nfunction symlog() {\n  var scale = symlogish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, symlog()).constant(scale.constant());\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/pow.js\n\n\n\n\nfunction transformPow(exponent) {\n  return function(x) {\n    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n  };\n}\n\nfunction transformSqrt(x) {\n  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);\n}\n\nfunction transformSquare(x) {\n  return x < 0 ? -x * x : x * x;\n}\n\nfunction powish(transform) {\n  var scale = transform(identity, identity),\n      exponent = 1;\n\n  function rescale() {\n    return exponent === 1 ? transform(identity, identity)\n        : exponent === 0.5 ? transform(transformSqrt, transformSquare)\n        : transform(transformPow(exponent), transformPow(1 / exponent));\n  }\n\n  scale.exponent = function(_) {\n    return arguments.length ? (exponent = +_, rescale()) : exponent;\n  };\n\n  return linearish(scale);\n}\n\nfunction pow() {\n  var scale = powish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, pow()).exponent(scale.exponent());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\nfunction sqrt() {\n  return pow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/quantile.js\n\n\n\n\nfunction quantile() {\n  var domain = [],\n      range = [],\n      thresholds = [],\n      unknown;\n\n  function rescale() {\n    var i = 0, n = Math.max(1, range.length);\n    thresholds = new Array(n - 1);\n    while (++i < n) thresholds[i - 1] = Object(src[\"quantile\"])(domain, i / n);\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : range[Object(src[\"bisect\"])(thresholds, x)];\n  }\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(src[\"ascending\"]);\n    return rescale();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.quantiles = function() {\n    return thresholds.slice();\n  };\n\n  scale.copy = function() {\n    return quantile()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/quantize.js\n\n\n\n\n\nfunction quantize() {\n  var x0 = 0,\n      x1 = 1,\n      n = 1,\n      domain = [0.5],\n      range = [0, 1],\n      unknown;\n\n  function scale(x) {\n    return x <= x ? range[Object(src[\"bisect\"])(domain, x, 0, n)] : unknown;\n  }\n\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);\n    return scale;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN]\n        : i < 1 ? [x0, domain[0]]\n        : i >= n ? [domain[n - 1], x1]\n        : [domain[i - 1], domain[i]];\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : scale;\n  };\n\n  scale.thresholds = function() {\n    return domain.slice();\n  };\n\n  scale.copy = function() {\n    return quantize()\n        .domain([x0, x1])\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(linearish(scale), arguments);\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/threshold.js\n\n\n\n\nfunction threshold() {\n  var domain = [0.5],\n      range = [0, 1],\n      unknown,\n      n = 1;\n\n  function scale(x) {\n    return x <= x ? range[Object(src[\"bisect\"])(domain, x, 0, n)] : unknown;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return [domain[i - 1], domain[i]];\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return threshold()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/year.js\nvar src_year = __webpack_require__(260);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/month.js\nvar src_month = __webpack_require__(1737);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/week.js\nvar src_week = __webpack_require__(180);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/day.js\nvar src_day = __webpack_require__(802);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/hour.js\nvar src_hour = __webpack_require__(1738);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/minute.js\nvar src_minute = __webpack_require__(1739);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/second.js\nvar src_second = __webpack_require__(1121);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/millisecond.js\nvar src_millisecond = __webpack_require__(1122);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time-format/src/defaultLocale.js\nvar src_defaultLocale = __webpack_require__(423);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/time.js\n\n\n\n\n\n\n\n\nvar durationSecond = 1000,\n    durationMinute = durationSecond * 60,\n    durationHour = durationMinute * 60,\n    durationDay = durationHour * 24,\n    durationWeek = durationDay * 7,\n    durationMonth = durationDay * 30,\n    durationYear = durationDay * 365;\n\nfunction date(t) {\n  return new Date(t);\n}\n\nfunction time_number(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nfunction calendar(year, month, week, day, hour, minute, second, millisecond, format) {\n  var scale = continuous(identity, identity),\n      invert = scale.invert,\n      domain = scale.domain;\n\n  var formatMillisecond = format(\".%L\"),\n      formatSecond = format(\":%S\"),\n      formatMinute = format(\"%I:%M\"),\n      formatHour = format(\"%I %p\"),\n      formatDay = format(\"%a %d\"),\n      formatWeek = format(\"%b %d\"),\n      formatMonth = format(\"%B\"),\n      formatYear = format(\"%Y\");\n\n  var tickIntervals = [\n    [second,  1,      durationSecond],\n    [second,  5,  5 * durationSecond],\n    [second, 15, 15 * durationSecond],\n    [second, 30, 30 * durationSecond],\n    [minute,  1,      durationMinute],\n    [minute,  5,  5 * durationMinute],\n    [minute, 15, 15 * durationMinute],\n    [minute, 30, 30 * durationMinute],\n    [  hour,  1,      durationHour  ],\n    [  hour,  3,  3 * durationHour  ],\n    [  hour,  6,  6 * durationHour  ],\n    [  hour, 12, 12 * durationHour  ],\n    [   day,  1,      durationDay   ],\n    [   day,  2,  2 * durationDay   ],\n    [  week,  1,      durationWeek  ],\n    [ month,  1,      durationMonth ],\n    [ month,  3,  3 * durationMonth ],\n    [  year,  1,      durationYear  ]\n  ];\n\n  function tickFormat(date) {\n    return (second(date) < date ? formatMillisecond\n        : minute(date) < date ? formatSecond\n        : hour(date) < date ? formatMinute\n        : day(date) < date ? formatHour\n        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)\n        : year(date) < date ? formatMonth\n        : formatYear)(date);\n  }\n\n  function tickInterval(interval, start, stop, step) {\n    if (interval == null) interval = 10;\n\n    // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n    if (typeof interval === \"number\") {\n      var target = Math.abs(stop - start) / interval,\n          i = Object(src[\"bisector\"])(function(i) { return i[2]; }).right(tickIntervals, target);\n      if (i === tickIntervals.length) {\n        step = Object(src[\"tickStep\"])(start / durationYear, stop / durationYear, interval);\n        interval = year;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval = i[0];\n      } else {\n        step = Math.max(Object(src[\"tickStep\"])(start, stop, interval), 1);\n        interval = millisecond;\n      }\n    }\n\n    return step == null ? interval : interval.every(step);\n  }\n\n  scale.invert = function(y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? domain(map.call(_, time_number)) : domain().map(date);\n  };\n\n  scale.ticks = function(interval, step) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval, t0, t1, step);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function(interval, step) {\n    var d = domain();\n    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))\n        ? domain(src_nice(d, interval))\n        : scale;\n  };\n\n  scale.copy = function() {\n    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));\n  };\n\n  return scale;\n}\n\n/* harmony default export */ var time = (function() {\n  return initRange.apply(calendar(src_year[\"a\" /* default */], src_month[\"a\" /* default */], src_week[\"d\" /* sunday */], src_day[\"a\" /* default */], src_hour[\"a\" /* default */], src_minute[\"a\" /* default */], src_second[\"a\" /* default */], src_millisecond[\"a\" /* default */], src_defaultLocale[\"a\" /* timeFormat */]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);\n});\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/utcYear.js\nvar utcYear = __webpack_require__(261);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/utcMonth.js\nvar utcMonth = __webpack_require__(1740);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/utcWeek.js\nvar utcWeek = __webpack_require__(181);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/utcDay.js\nvar utcDay = __webpack_require__(803);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/utcHour.js\nvar utcHour = __webpack_require__(1741);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3-time/src/utcMinute.js\nvar utcMinute = __webpack_require__(1742);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/utcTime.js\n\n\n\n\n\n/* harmony default export */ var utcTime = (function() {\n  return initRange.apply(calendar(utcYear[\"a\" /* default */], utcMonth[\"a\" /* default */], utcWeek[\"d\" /* utcSunday */], utcDay[\"a\" /* default */], utcHour[\"a\" /* default */], utcMinute[\"a\" /* default */], src_second[\"a\" /* default */], src_millisecond[\"a\" /* default */], src_defaultLocale[\"b\" /* utcFormat */]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);\n});\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/sequential.js\n\n\n\n\n\n\n\nfunction sequential_transformer() {\n  var x0 = 0,\n      x1 = 1,\n      t0,\n      t1,\n      k10,\n      transform,\n      interpolator = identity,\n      clamp = false,\n      unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t) {\n    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);\n    return scale;\n  };\n}\n\nfunction sequential_copy(source, target) {\n  return target\n      .domain(source.domain())\n      .interpolator(source.interpolator())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nfunction sequential() {\n  var scale = linearish(sequential_transformer()(identity));\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequential());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialLog() {\n  var scale = loggish(sequential_transformer()).domain([1, 10]);\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialLog()).base(scale.base());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialSymlog() {\n  var scale = symlogish(sequential_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialSymlog()).constant(scale.constant());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialPow() {\n  var scale = powish(sequential_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialPow()).exponent(scale.exponent());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialSqrt() {\n  return sequentialPow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/sequentialQuantile.js\n\n\n\n\nfunction sequentialQuantile() {\n  var domain = [],\n      interpolator = identity;\n\n  function scale(x) {\n    if (!isNaN(x = +x)) return interpolator((Object(src[\"bisect\"])(domain, x) - 1) / (domain.length - 1));\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(src[\"ascending\"]);\n    return scale;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.copy = function() {\n    return sequentialQuantile(interpolator).domain(domain);\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/diverging.js\n\n\n\n\n\n\n\n\nfunction diverging_transformer() {\n  var x0 = 0,\n      x1 = 0.5,\n      x2 = 1,\n      t0,\n      t1,\n      t2,\n      k10,\n      k21,\n      interpolator = identity,\n      transform,\n      clamp = false,\n      unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t) {\n    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);\n    return scale;\n  };\n}\n\nfunction diverging_diverging() {\n  var scale = linearish(diverging_transformer()(identity));\n\n  scale.copy = function() {\n    return sequential_copy(scale, diverging_diverging());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingLog() {\n  var scale = loggish(diverging_transformer()).domain([0.1, 1, 10]);\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingLog()).base(scale.base());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingSymlog() {\n  var scale = symlogish(diverging_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingSymlog()).constant(scale.constant());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingPow() {\n  var scale = powish(diverging_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingPow()).exponent(scale.exponent());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingSqrt() {\n  return divergingPow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/d3-scale/src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/scale/dist/vx-scale.es.js\n\n\nvar vx_scale_es_band = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      padding = _ref.padding,\n      paddingInner = _ref.paddingInner,\n      paddingOuter = _ref.paddingOuter,\n      align = _ref.align,\n      tickFormat = _ref.tickFormat;\n\n  var scale = band();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (padding) scale.padding(padding);\n  if (paddingInner) scale.paddingInner(paddingInner);\n  if (paddingOuter) scale.paddingOuter(paddingOuter);\n  if (align) scale.align(align);\n  if (tickFormat) scale.tickFormat = tickFormat;\n\n  return scale;\n});\n\nvar vx_scale_es_point = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      padding = _ref.padding,\n      align = _ref.align,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice;\n\n  var scale = band_point();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (padding) scale.padding(padding);\n  if (align) scale.align(align);\n\n  return scale;\n});\n\nvar vx_scale_es_linear = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = linear_linear();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar vx_scale_es_time = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = time();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar utc = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = utcTime();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar vx_scale_es_log = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      base = _ref.base,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = log();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n  if (base) scale.base(base);\n\n  return scale;\n});\n\nvar power = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      exponent = _ref.exponent,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = pow();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n  if (exponent) scale.exponent(exponent);\n\n  return scale;\n});\n\nvar vx_scale_es_ordinal = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain,\n      unknown = _ref.unknown;\n\n  var scale = ordinal();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n  if (unknown) scale.unknown(unknown);\n\n  return scale;\n});\n\nvar vx_scale_es_quantize = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain,\n      ticks = _ref.ticks,\n      tickFormat = _ref.tickFormat,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice;\n\n  var scale = quantize();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (ticks) scale.ticks(ticks);\n  if (tickFormat) scale.tickFormat(tickFormat);\n\n  return scale;\n});\n\nvar vx_scale_es_quantile = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain;\n\n  var scale = quantile();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n\n  return scale;\n});\n\nvar vx_scale_es_threshold = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain;\n\n  var scale = threshold();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n\n  return scale;\n});\n\nvar vx_scale_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction updateScale(scale, _ref) {\n  var args = vx_scale_es_objectWithoutProperties(_ref, []);\n\n  var nextScale = scale.copy();\n  Object.keys(args).forEach(function (key) {\n    if (nextScale.hasOwnProperty(key)) nextScale[key](args[key]);\n  });\n  return nextScale;\n}\n\n\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/getScaleForAccessor.js\nfunction getScaleForAccessor_extends() { getScaleForAccessor_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return getScaleForAccessor_extends.apply(this, arguments); }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nvar scaleTypeToScale = {\n  time: vx_scale_es_time,\n  timeUtc: utc,\n  linear: vx_scale_es_linear,\n  band: vx_scale_es_band,\n  ordinal: vx_scale_es_ordinal\n};\nfunction getScaleForAccessor(_ref) {\n  var allData = _ref.allData,\n      minAccessor = _ref.minAccessor,\n      maxAccessor = _ref.maxAccessor,\n      type = _ref.type,\n      _ref$includeZero = _ref.includeZero,\n      includeZero = _ref$includeZero === void 0 ? true : _ref$includeZero,\n      range = _ref.range,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"allData\", \"minAccessor\", \"maxAccessor\", \"type\", \"includeZero\", \"range\"]);\n\n  var domain;\n\n  if (type === 'band' || type === 'ordinal') {\n    domain = allData.map(minAccessor);\n  }\n\n  if (type === 'linear' || type === 'time' || type === 'timeUtc') {\n    var _extent = Object(src[\"extent\"])([].concat(Object(src[\"extent\"])(allData, minAccessor), Object(src[\"extent\"])(allData, maxAccessor))),\n        min = _extent[0],\n        max = _extent[1];\n\n    domain = [type === 'linear' && includeZero ? Math.min(0, min) : min, type === 'linear' && includeZero ? Math.max(0, max) : max];\n  }\n\n  return scaleTypeToScale[type](getScaleForAccessor_extends({\n    domain: domain,\n    range: range\n  }, rest));\n}\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/collectScalesFromProps.js\nfunction collectScalesFromProps_extends() { collectScalesFromProps_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return collectScalesFromProps_extends.apply(this, arguments); }\n\n\n // import collectExtentsFromChildSeries from './collectExtentsFromChildSeries';\n\n\n\n\n\nvar collectScalesFromProps_getX = function getX(d) {\n  return d && d.x;\n};\n\nvar xString = function xString(d) {\n  return collectScalesFromProps_getX(d).toString();\n};\n\nvar collectScalesFromProps_getY = function getY(d) {\n  return d && d.y;\n};\n\nvar yString = function yString(d) {\n  return collectScalesFromProps_getY(d).toString();\n};\n\nfunction collectScalesFromProps(props) {\n  var xScaleObject = props.xScale,\n      yScaleObject = props.yScale,\n      children = props.children;\n\n  var _getChartDimensions = getChartDimensions(props),\n      innerWidth = _getChartDimensions.innerWidth,\n      innerHeight = _getChartDimensions.innerHeight;\n\n  var allData = collectDataFromChildSeries(children); // TODO could collect data extents from child series\n  // which would support passing arbitrary x/y accessors\n  // const [xExtent, yExtent] = collectExtentsFromChildSeries(children);\n  // issues:\n  //  voronoi transforms data via scale(getXorY(d))\n  //    => Could be solved by transforming in data collection\n  //  tooltip/crosshair transforms data via scale(getXorY(d))\n  //    => could be solved by transforming in the mousemove call so series own it?\n\n  var xScale = getScaleForAccessor(collectScalesFromProps_extends({\n    allData: allData,\n    minAccessor: function minAccessor(d) {\n      return typeof d.x0 === 'undefined' ? d.x : d.x0;\n    },\n    maxAccessor: function maxAccessor(d) {\n      return typeof d.x1 === 'undefined' ? d.x : d.x1;\n    },\n    range: [0, innerWidth]\n  }, xScaleObject));\n  var yScale = getScaleForAccessor(collectScalesFromProps_extends({\n    allData: allData,\n    minAccessor: function minAccessor(d) {\n      return typeof d.y0 === 'undefined' ? d.y : d.y0;\n    },\n    maxAccessor: function maxAccessor(d) {\n      return typeof d.y1 === 'undefined' ? d.y : d.y1;\n    },\n    range: [innerHeight, 0]\n  }, yScaleObject));\n  react[\"Children\"].forEach(children, function (Child) {\n    // Child-specific scales or adjustments here\n    var name = Object(chartUtils[\"c\" /* componentName */])(Child);\n\n    if (Object(chartUtils[\"f\" /* isBarSeries */])(name)) {\n      var horizontal = Child.props.horizontal;\n      var categoryScaleObject = horizontal ? yScaleObject : xScaleObject;\n\n      if (categoryScaleObject.type !== 'band') {\n        var categoryScale = horizontal ? yScale : xScale;\n        var range = horizontal ? innerHeight : innerWidth;\n        var dummyBand = getScaleForAccessor({\n          allData: allData,\n          minAccessor: horizontal ? yString : xString,\n          maxAccessor: horizontal ? yString : xString,\n          type: 'band',\n          rangeRound: [0, range],\n          paddingOuter: 1\n        });\n        var offset = dummyBand.bandwidth() / 2;\n        categoryScale.range([offset, range - offset]);\n        categoryScale.barWidth = dummyBand.bandwidth();\n        categoryScale.offset = offset;\n      }\n    }\n\n    if (Object(chartUtils[\"h\" /* isCirclePackSeries */])(name)) {\n      yScale.domain([-innerHeight / 2, innerHeight / 2]);\n    }\n  });\n  return {\n    xScale: xScale,\n    yScale: yScale\n  };\n}\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/@data-ui/xy-chart/esm/chart/XYChart.js\nfunction XYChart_extends() { XYChart_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return XYChart_extends.apply(this, arguments); }\n\nfunction XYChart_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar CONTAINER_TRIGGER = 'container';\nvar SERIES_TRIGGER = 'series';\nvar VORONOI_TRIGGER = 'voronoi';\nvar Y_LABEL_OFFSET = 0.7;\nvar XYChart_propTypes = {\n  ariaLabel: prop_types_default.a.string.isRequired,\n  children: prop_types_default.a.node,\n  disableMouseEvents: prop_types_default.a.bool,\n  eventTrigger: prop_types_default.a.oneOf([CONTAINER_TRIGGER, SERIES_TRIGGER, VORONOI_TRIGGER]),\n  eventTriggerRefs: prop_types_default.a.func,\n  height: prop_types_default.a.number.isRequired,\n  innerRef: prop_types_default.a.func,\n  margin: prop_types_default.a.shape({\n    top: prop_types_default.a.number,\n    right: prop_types_default.a.number,\n    bottom: prop_types_default.a.number,\n    left: prop_types_default.a.number\n  }),\n  renderTooltip: prop_types_default.a.func,\n  showXGrid: prop_types_default.a.bool,\n  xGridValues: prop_types_default.a.arrayOf(propShapes[\"j\" /* stringNumberDateObjectPropType */]),\n  xGridOffset: prop_types_default.a.number,\n  showYGrid: prop_types_default.a.bool,\n  yGridValues: prop_types_default.a.arrayOf(propShapes[\"j\" /* stringNumberDateObjectPropType */]),\n  yGridOffset: prop_types_default.a.number,\n  showVoronoi: prop_types_default.a.bool,\n  snapTooltipToDataX: prop_types_default.a.bool,\n  snapTooltipToDataY: prop_types_default.a.bool,\n  theme: propShapes[\"k\" /* themeShape */],\n  width: prop_types_default.a.number.isRequired,\n  xScale: propShapes[\"i\" /* scaleShape */].isRequired,\n  yScale: propShapes[\"i\" /* scaleShape */].isRequired,\n  // these may be passed from WithTooltip\n  onClick: prop_types_default.a.func,\n  // expects to be called like func({ event, datum })\n  onMouseMove: prop_types_default.a.func,\n  // expects to be called like func({ event, datum })\n  onMouseLeave: prop_types_default.a.func,\n  // expects to be called like func({ event, datum })\n  tooltipData: prop_types_default.a.shape({\n    event: prop_types_default.a.object,\n    datum: prop_types_default.a.object,\n    series: prop_types_default.a.object\n  })\n};\nvar XYChart_defaultProps = {\n  children: null,\n  disableMouseEvents: false,\n  eventTrigger: SERIES_TRIGGER,\n  eventTriggerRefs: null,\n  innerRef: null,\n  margin: chartUtils[\"a\" /* DEFAULT_CHART_MARGIN */],\n  renderTooltip: null,\n  showVoronoi: false,\n  showXGrid: false,\n  xGridValues: null,\n  xGridOffset: null,\n  showYGrid: false,\n  yGridValues: null,\n  yGridOffset: null,\n  snapTooltipToDataX: false,\n  snapTooltipToDataY: false,\n  theme: {},\n  onClick: null,\n  onMouseMove: null,\n  onMouseLeave: null,\n  tooltipData: null\n}; // accessors\n\nvar XYChart_getX = function getX(d) {\n  return d && d.x;\n};\n\nvar XYChart_getY = function getY(d) {\n  return d && d.y;\n};\n\nvar XYChart_XYChart =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  XYChart_inheritsLoose(XYChart, _React$PureComponent);\n\n  function XYChart(props) {\n    var _this;\n\n    _this = _React$PureComponent.call(this, props) || this; // if renderTooltip is passed we return another XYChart wrapped in WithTooltip\n    // therefore we don't want to compute state if the nested chart will do so\n\n    _this.state = props.renderTooltip ? {} : XYChart.getStateFromProps(props);\n    _this.getDatumCoords = _this.getDatumCoords.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleMouseLeave = _this.handleMouseLeave.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleMouseMove = _this.handleMouseMove.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleMouseDown = _this.handleMouseDown.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleContainerEvent = _this.handleContainerEvent.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  var _proto = XYChart.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this$props = this.props,\n        renderTooltip = _this$props.renderTooltip,\n        eventTriggerRefs = _this$props.eventTriggerRefs;\n\n    if (!renderTooltip && eventTriggerRefs) {\n      eventTriggerRefs({\n        mousemove: this.handleMouseMove,\n        mouseleave: this.handleMouseLeave,\n        click: this.handleClick\n      });\n    }\n  };\n\n  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _this2 = this;\n\n    var shouldComputeScales = false;\n\n    if (['width', 'height', 'children'].some(function (prop) {\n      return _this2.props[prop] !== nextProps[prop];\n    } // eslint-disable-line react/destructuring-assignment\n    )) {\n      shouldComputeScales = true;\n    }\n\n    if (['margin', 'xScale', 'yScale'].some( // eslint-disable-next-line react/destructuring-assignment\n    function (prop) {\n      return !shallowCompareObjectEntries(_this2.props[prop], nextProps[prop]);\n    })) {\n      shouldComputeScales = true;\n    }\n\n    if (shouldComputeScales) this.setState(XYChart.getStateFromProps(nextProps));\n  };\n\n  XYChart.getStateFromProps = function getStateFromProps(props) {\n    var _getChartDimensions = getChartDimensions(props),\n        margin = _getChartDimensions.margin,\n        innerWidth = _getChartDimensions.innerWidth,\n        innerHeight = _getChartDimensions.innerHeight;\n\n    var _collectScalesFromPro = collectScalesFromProps(props),\n        xScale = _collectScalesFromPro.xScale,\n        yScale = _collectScalesFromPro.yScale;\n\n    var voronoiData = collectVoronoiData({\n      children: props.children,\n      getX: XYChart_getX,\n      getY: XYChart_getY\n    });\n    return {\n      innerHeight: innerHeight,\n      innerWidth: innerWidth,\n      margin: margin,\n      xScale: xScale,\n      yScale: yScale,\n      voronoiData: voronoiData,\n      voronoiX: function voronoiX(d) {\n        return xScale(XYChart_getX(d));\n      },\n      voronoiY: function voronoiY(d) {\n        return yScale(XYChart_getY(d));\n      }\n    };\n  };\n\n  _proto.getNumTicksAndGridValues = function getNumTicksAndGridValues(innerWidth, innerHeight) {\n    var _this$props2 = this.props,\n        children = _this$props2.children,\n        xGridValues = _this$props2.xGridValues,\n        yGridValues = _this$props2.yGridValues;\n    var xAxis = Object(chartUtils[\"d\" /* getChildWithName */])('XAxis', children);\n    var yAxis = Object(chartUtils[\"d\" /* getChildWithName */])('YAxis', children); // use num ticks and tickValues defined on Axes, if relevant\n\n    return {\n      numXTicks: Object(chartUtils[\"o\" /* propOrFallback */])(xAxis && xAxis.props, 'numTicks', Object(chartUtils[\"n\" /* numTicksForWidth */])(innerWidth)),\n      numYTicks: Object(chartUtils[\"o\" /* propOrFallback */])(yAxis && yAxis.props, 'numTicks', Object(chartUtils[\"m\" /* numTicksForHeight */])(innerHeight)),\n      xGridValues: xGridValues || (xAxis && xAxis.props && xAxis.props.tickValues ? xAxis.props.tickValues : null),\n      yGridValues: yGridValues || (yAxis && yAxis.props && yAxis.props.tickValues ? yAxis.props.tickValues : null)\n    };\n  };\n\n  _proto.getDatumCoords = function getDatumCoords(datum) {\n    var _this$state = this.state,\n        xScale = _this$state.xScale,\n        yScale = _this$state.yScale,\n        margin = _this$state.margin;\n    var coords = {}; // tooltip operates in full width/height space so we must account for margins\n\n    if (datum) coords.x = xScale(XYChart_getX(datum)) + margin.left;\n    if (datum) coords.y = yScale(XYChart_getY(datum)) + margin.top;\n    return coords;\n  };\n\n  _proto.handleContainerEvent = function handleContainerEvent(event) {\n    var _this$state2 = this.state,\n        xScale = _this$state2.xScale,\n        yScale = _this$state2.yScale,\n        margin = _this$state2.margin;\n    var children = this.props.children;\n\n    var _findClosestDatums = findClosestDatums({\n      children: children,\n      event: event,\n      getX: XYChart_getX,\n      getY: XYChart_getY,\n      xScale: xScale,\n      yScale: yScale,\n      margin: margin\n    }),\n        closestDatum = _findClosestDatums.closestDatum,\n        series = _findClosestDatums.series;\n\n    if (closestDatum || Object.keys(series).length > 0) {\n      event.persist();\n      var args = {\n        event: event,\n        datum: closestDatum,\n        series: series\n      };\n      if (event.type === 'mousemove') this.handleMouseMove(args);else if (event.type === 'click') this.handleClick(args);\n    }\n  };\n\n  _proto.handleMouseDown = function handleMouseDown(event) {\n    if (this.fireBrushStart) {\n      this.fireBrushStart(event);\n    }\n  };\n\n  _proto.handleMouseMove = function handleMouseMove(args) {\n    var _this$props3 = this.props,\n        snapTooltipToDataX = _this$props3.snapTooltipToDataX,\n        snapTooltipToDataY = _this$props3.snapTooltipToDataY,\n        onMouseMove = _this$props3.onMouseMove;\n    var isFocusEvent = args.event && args.event.type === 'focus';\n\n    if (onMouseMove) {\n      var _this$getDatumCoords = this.getDatumCoords(args.datum),\n          x = _this$getDatumCoords.x,\n          y = _this$getDatumCoords.y;\n\n      onMouseMove(XYChart_extends({}, args, {\n        coords: XYChart_extends({}, (isFocusEvent || snapTooltipToDataX) && {\n          x: x\n        }, (isFocusEvent || snapTooltipToDataY) && {\n          y: y\n        }, args.coords)\n      }));\n    }\n  };\n\n  _proto.handleMouseLeave = function handleMouseLeave(args) {\n    var onMouseLeave = this.props.onMouseLeave;\n    if (onMouseLeave) onMouseLeave(args);\n  };\n\n  _proto.handleClick = function handleClick(args) {\n    var _this$props4 = this.props,\n        snapTooltipToDataX = _this$props4.snapTooltipToDataX,\n        snapTooltipToDataY = _this$props4.snapTooltipToDataY,\n        onClick = _this$props4.onClick;\n\n    if (onClick) {\n      var coords = this.getDatumCoords(args.datum);\n      onClick(XYChart_extends({}, args, {\n        coords: XYChart_extends({\n          x: snapTooltipToDataX ? coords.x : undefined,\n          y: snapTooltipToDataY ? coords.y : undefined\n        }, args.coords)\n      }));\n    }\n  };\n\n  _proto.render = function render() {\n    var _this3 = this;\n\n    var renderTooltip = this.props.renderTooltip;\n\n    if (renderTooltip) {\n      return react_default.a.createElement(WithTooltip[\"a\" /* default */], {\n        renderTooltip: renderTooltip\n      }, react_default.a.createElement(XYChart, XYChart_extends({}, this.props, {\n        renderTooltip: null\n      })));\n    }\n\n    var _this$props5 = this.props,\n        ariaLabel = _this$props5.ariaLabel,\n        eventTrigger = _this$props5.eventTrigger,\n        children = _this$props5.children,\n        showXGrid = _this$props5.showXGrid,\n        showYGrid = _this$props5.showYGrid,\n        theme = _this$props5.theme,\n        height = _this$props5.height,\n        width = _this$props5.width,\n        innerRef = _this$props5.innerRef,\n        tooltipData = _this$props5.tooltipData,\n        showVoronoi = _this$props5.showVoronoi,\n        xGridOffset = _this$props5.xGridOffset,\n        yGridOffset = _this$props5.yGridOffset;\n    var _this$state3 = this.state,\n        innerWidth = _this$state3.innerWidth,\n        innerHeight = _this$state3.innerHeight,\n        margin = _this$state3.margin,\n        voronoiData = _this$state3.voronoiData,\n        voronoiX = _this$state3.voronoiX,\n        voronoiY = _this$state3.voronoiY,\n        xScale = _this$state3.xScale,\n        yScale = _this$state3.yScale;\n\n    var _this$getNumTicksAndG = this.getNumTicksAndGridValues(innerWidth, innerHeight),\n        numXTicks = _this$getNumTicksAndG.numXTicks,\n        numYTicks = _this$getNumTicksAndG.numYTicks,\n        xGridValues = _this$getNumTicksAndG.xGridValues,\n        yGridValues = _this$getNumTicksAndG.yGridValues;\n\n    var CrossHairs = []; // ensure these are the top-most layer\n\n    var Brush = null;\n    var xAxisOrientation;\n    var yAxisOrientation;\n    return innerWidth > 0 && innerHeight > 0 && react_default.a.createElement(\"svg\", {\n      \"aria-label\": ariaLabel,\n      role: \"img\",\n      width: width,\n      height: height,\n      ref: innerRef\n    }, react_default.a.createElement(vx_group_es[\"a\" /* Group */], {\n      left: margin.left,\n      top: margin.top\n    }, showXGrid && react_default.a.createElement(Columns, {\n      scale: xScale,\n      height: innerHeight,\n      numTicks: numXTicks,\n      stroke: theme.gridStyles && theme.gridStyles.stroke,\n      strokeWidth: theme.gridStyles && theme.gridStyles.strokeWidth,\n      tickValues: xGridValues,\n      offset: Object(chartUtils[\"j\" /* isDefined */])(xGridOffset) ? xGridOffset : xScale.bandwidth && xScale.bandwidth() / 2 || 0\n    }), showYGrid && react_default.a.createElement(Rows, {\n      scale: yScale,\n      width: innerWidth,\n      numTicks: numYTicks,\n      stroke: theme.gridStyles && theme.gridStyles.stroke,\n      strokeWidth: theme.gridStyles && theme.gridStyles.strokeWidth,\n      tickValues: yGridValues,\n      offset: Object(chartUtils[\"j\" /* isDefined */])(yGridOffset) ? yGridOffset : yScale.bandwidth && yScale.bandwidth() / 2 || 0\n    }), react_default.a.Children.map(children, function (Child) {\n      var name = Object(chartUtils[\"c\" /* componentName */])(Child);\n\n      if (Object(chartUtils[\"e\" /* isAxis */])(name)) {\n        var styleKey = name[0].toLowerCase();\n        var labelOffset = typeof Child.props.labelOffset === 'number' ? Child.props.labelOffset : name === 'YAxis' && Y_LABEL_OFFSET * margin[Child.props.orientation] || 0;\n\n        if (name === 'XAxis') {\n          xAxisOrientation = Child.props.orientation;\n        } else {\n          yAxisOrientation = Child.props.orientation;\n        }\n\n        return react_default.a.cloneElement(Child, {\n          innerHeight: innerHeight,\n          innerWidth: innerWidth,\n          height: height,\n          width: width,\n          labelOffset: labelOffset,\n          numTicks: name === 'XAxis' ? numXTicks : numYTicks,\n          scale: name === 'XAxis' ? xScale : yScale,\n          rangePadding: Child.props.rangePadding || (name === 'XAxis' ? xScale.offset : undefined),\n          axisStyles: XYChart_extends({}, theme[styleKey + \"AxisStyles\"], Child.props.axisStyles),\n          tickStyles: XYChart_extends({}, theme[styleKey + \"TickStyles\"], Child.props.tickStyles)\n        });\n      } else if (Object(chartUtils[\"l\" /* isSeries */])(name)) {\n        return react_default.a.cloneElement(Child, {\n          xScale: xScale,\n          yScale: yScale,\n          margin: margin,\n          onClick: Child.props.onClick || (Child.props.disableMouseEvents ? undefined : _this3.handleClick),\n          onMouseLeave: Child.props.onMouseLeave || (Child.props.disableMouseEvents ? undefined : _this3.handleMouseLeave),\n          onMouseMove: Child.props.onMouseMove || (Child.props.disableMouseEvents ? undefined : _this3.handleMouseMove)\n        });\n      } else if (Object(chartUtils[\"i\" /* isCrossHair */])(name)) {\n        CrossHairs.push(Child);\n        return null;\n      } else if (Object(chartUtils[\"k\" /* isReferenceLine */])(name)) {\n        return react_default.a.cloneElement(Child, {\n          xScale: xScale,\n          yScale: yScale\n        });\n      } else if (Object(chartUtils[\"g\" /* isBrush */])(name)) {\n        Brush = Child;\n        return null;\n      }\n\n      return Child;\n    }), eventTrigger === VORONOI_TRIGGER && react_default.a.createElement(chart_Voronoi, {\n      data: voronoiData,\n      x: voronoiX,\n      y: voronoiY,\n      width: innerWidth,\n      height: innerHeight,\n      onClick: this.handleClick,\n      onMouseDown: this.handleMouseDown,\n      onMouseMove: this.handleMouseMove,\n      onMouseLeave: this.handleMouseLeave,\n      showVoronoi: showVoronoi\n    }), eventTrigger === CONTAINER_TRIGGER && react_default.a.createElement(\"rect\", {\n      x: 0,\n      y: 0,\n      width: innerWidth,\n      height: innerHeight,\n      fill: \"transparent\",\n      fillOpacity: 0,\n      onMouseDown: this.handleMouseDown,\n      onClick: this.handleContainerEvent,\n      onMouseMove: this.handleContainerEvent,\n      onMouseLeave: this.handleMouseLeave\n    }), Brush && react_default.a.cloneElement(Brush, {\n      xScale: xScale,\n      yScale: yScale,\n      innerHeight: innerHeight,\n      innerWidth: innerWidth,\n      margin: margin,\n      onMouseMove: this.handleContainerEvent,\n      onMouseLeave: this.handleMouseLeave,\n      onClick: this.handleContainerEvent,\n      xAxisOrientation: xAxisOrientation,\n      yAxisOrientation: yAxisOrientation\n    }), tooltipData && CrossHairs.length > 0 && CrossHairs.map(function (CrossHair, i) {\n      return react_default.a.cloneElement(CrossHair, {\n        key: \"crosshair-\" + i,\n        // eslint-disable-line react/no-array-index-key\n        datum: tooltipData.datum,\n        series: tooltipData.series,\n        getScaledX: function getScaledX(d) {\n          return xScale(XYChart_getX(d) || 0) + (xScale.bandwidth ? xScale.bandwidth() / 2 : 0);\n        },\n        getScaledY: function getScaledY(d) {\n          return yScale(XYChart_getY(d) || 0) + (yScale.bandwidth ? yScale.bandwidth() / 2 : 0);\n        },\n        xScale: xScale,\n        yScale: yScale\n      });\n    })));\n  };\n\n  return XYChart;\n}(react_default.a.PureComponent);\n\nXYChart_XYChart.propTypes = XYChart_propTypes;\nXYChart_XYChart.defaultProps = XYChart_defaultProps;\nXYChart_XYChart.displayName = 'XYChart';\n/* harmony default export */ var chart_XYChart = __webpack_exports__[\"a\"] = (XYChart_XYChart);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ4MS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvbm9kZV9tb2R1bGVzL0B2eC9ncmlkL25vZGVfbW9kdWxlcy9AdngvZ3JvdXAvZGlzdC92eC1ncm91cC5lcy5qcz8yMzdkIiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvbm9kZV9tb2R1bGVzL0B2eC9ncmlkL25vZGVfbW9kdWxlcy9Adngvc2hhcGUvZGlzdC92eC1zaGFwZS5lcy5qcz8xZDk4Iiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvbm9kZV9tb2R1bGVzL0B2eC9ncmlkL2Rpc3QvdngtZ3JpZC5lcy5qcz80ZTNlIiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3RocmVzaG9sZC9ub2RlX21vZHVsZXMvQHZ4L3NoYXBlL2Rpc3Qvdngtc2hhcGUuZXMuanM/NzU4OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC90aHJlc2hvbGQvbm9kZV9tb2R1bGVzL0B2eC9jbGlwLXBhdGgvZGlzdC92eC1jbGlwLXBhdGguZXMuanM/NjIzYiIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC90aHJlc2hvbGQvZGlzdC92eC10aHJlc2hvbGQuZXMuanM/OWMyNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L2VzbS9zZXJpZXMvQXJlYURpZmZlcmVuY2VTZXJpZXMuanM/ZGUxYiIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L2VzbS91dGlscy9jb2xsZWN0Vm9yb25vaURhdGEuanM/NTYxZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9ldmVudC9kaXN0L3Z4LWV2ZW50LmVzLmpzPzM3MGEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9lc20vdXRpbHMvZmluZENsb3Nlc3REYXR1bXMuanM/MmI5NiIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L2VzbS91dGlscy9zaGFsbG93Q29tcGFyZU9iamVjdEVudHJpZXMuanM/NGFjOCIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXZvcm9ub2kvc3JjL2NvbnN0YW50LmpzPzQ2OGIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9kMy12b3Jvbm9pL3NyYy9wb2ludC5qcz9lNWMwIiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZDMtdm9yb25vaS9zcmMvUmVkQmxhY2tUcmVlLmpzP2M4YzAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9kMy12b3Jvbm9pL3NyYy9FZGdlLmpzPzdiM2IiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9kMy12b3Jvbm9pL3NyYy9DZWxsLmpzPzViYmUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9kMy12b3Jvbm9pL3NyYy9DaXJjbGUuanM/NDNjZSIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXZvcm9ub2kvc3JjL0JlYWNoLmpzPzgzMzgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9kMy12b3Jvbm9pL3NyYy9EaWFncmFtLmpzPzA5YWMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9kMy12b3Jvbm9pL3NyYy92b3Jvbm9pLmpzP2E1MGIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9kMy12b3Jvbm9pL3NyYy9pbmRleC5qcz84ZTEwIiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3Zvcm9ub2kvZGlzdC92eC12b3Jvbm9pLmVzLmpzP2ZlZTYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9lc20vY2hhcnQvVm9yb25vaS5qcz9lM2QzIiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvZXNtL3V0aWxzL2NvbGxlY3REYXRhRnJvbUNoaWxkU2VyaWVzLmpzP2Y0M2EiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9lc20vdXRpbHMvZ2V0Q2hhcnREaW1lbnNpb25zLmpzPzc3MjgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2luaXQuanM/ODI0MiIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvYXJyYXkuanM/YzdkNCIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvb3JkaW5hbC5qcz82OTM4Iiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9iYW5kLmpzP2Q2OWEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnN0YW50LmpzPzMzZDIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL251bWJlci5qcz8wZGEwIiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9jb250aW51b3VzLmpzP2VjMGQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3RpY2tGb3JtYXQuanM/NjkyZSIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbGluZWFyLmpzP2Q1NjQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2lkZW50aXR5LmpzP2U5ZGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL25pY2UuanM/NDZhZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbG9nLmpzP2U2MTIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3N5bWxvZy5qcz85NzI0Iiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9wb3cuanM/ZTM4ZiIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvcXVhbnRpbGUuanM/ZDcyNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvcXVhbnRpemUuanM/YTUyZiIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGhyZXNob2xkLmpzP2ZlNGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3RpbWUuanM/Mjk2NSIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdXRjVGltZS5qcz8zMWUyIiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zZXF1ZW50aWFsLmpzPzM3YTMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3NlcXVlbnRpYWxRdWFudGlsZS5qcz8wMzM1Iiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9kaXZlcmdpbmcuanM/MWNiZSIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvaW5kZXguanM/Y2JkZiIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9Adngvc2NhbGUvZGlzdC92eC1zY2FsZS5lcy5qcz84ZjEyIiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvZXNtL3V0aWxzL2dldFNjYWxlRm9yQWNjZXNzb3IuanM/ZDhkZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2thbWlsZ2FicnlqZWxza2kvcHJvamVjdHMvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L2VzbS91dGlscy9jb2xsZWN0U2NhbGVzRnJvbVByb3BzLmpzPzVmYmMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9lc20vY2hhcnQvWFlDaGFydC5qcz8wZTQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmZ1bmN0aW9uIEdyb3VwKF9yZWYpIHtcbiAgdmFyIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIHRyYW5zZm9ybSA9IF9yZWYudHJhbnNmb3JtLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3RvcCcsICdsZWZ0JywgJ3RyYW5zZm9ybScsICdjbGFzc05hbWUnLCAnY2hpbGRyZW4nXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWdyb3VwJywgY2xhc3NOYW1lKSxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtIHx8ICd0cmFuc2xhdGUoJyArIGxlZnQgKyAnLCAnICsgdG9wICsgJyknXG4gICAgfSwgcmVzdFByb3BzKSxcbiAgICBjaGlsZHJlblxuICApO1xufVxuXG5leHBvcnQgeyBHcm91cCB9O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBhcmMsIHBpZSwgbGluZSwgcmFkaWFsTGluZSwgYXJlYSwgc3RhY2ssIHN0YWNrT3JkZXJBc2NlbmRpbmcsIHN0YWNrT3JkZXJEZXNjZW5kaW5nLCBzdGFja09yZGVySW5zaWRlT3V0LCBzdGFja09yZGVyTm9uZSwgc3RhY2tPcmRlclJldmVyc2UsIHN0YWNrT2Zmc2V0RXhwYW5kLCBzdGFja09mZnNldERpdmVyZ2luZywgc3RhY2tPZmZzZXROb25lLCBzdGFja09mZnNldFNpbGhvdWV0dGUsIHN0YWNrT2Zmc2V0V2lnZ2xlLCBsaW5rSG9yaXpvbnRhbCwgbGlua1ZlcnRpY2FsLCBsaW5rUmFkaWFsIH0gZnJvbSAnZDMtc2hhcGUnO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICdAdngvZ3JvdXAnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICdAdngvcG9pbnQnO1xuaW1wb3J0IHsgY3VydmVMaW5lYXIgfSBmcm9tICdAdngvY3VydmUnO1xuaW1wb3J0IHsgcGF0aCB9IGZyb20gJ2QzLXBhdGgnO1xuXG5mdW5jdGlvbiBjYWxsT3JWYWx1ZShtYXliZUZuLCBkYXRhKSB7XG4gIGlmICh0eXBlb2YgbWF5YmVGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUZuKGRhdGEpO1xuICB9XG4gIHJldHVybiBtYXliZUZuO1xufVxuXG5mdW5jdGlvbiBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhyZXN0UHJvcHMpLnJlZHVjZShmdW5jdGlvbiAocmV0LCBjdXIpIHtcbiAgICByZXRbY3VyXSA9IGNhbGxPclZhbHVlKHJlc3RQcm9wc1tjdXJdLCBkYXRhKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LCB7fSk7XG59XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICB9XG59O1xuXG5BcmMucHJvcFR5cGVzID0ge1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGRhdGE6IFByb3BUeXBlcy5hbnksXG4gIGNlbnRyb2lkOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBpbm5lclJhZGl1czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgb3V0ZXJSYWRpdXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIGNvcm5lclJhZGl1czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgc3RhcnRBbmdsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgZW5kQW5nbGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHBhZEFuZ2xlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBwYWRSYWRpdXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSlcbn07XG5cbmZ1bmN0aW9uIEFyYyhfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjZW50cm9pZCA9IF9yZWYuY2VudHJvaWQsXG4gICAgICBpbm5lclJhZGl1cyA9IF9yZWYuaW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1cyA9IF9yZWYub3V0ZXJSYWRpdXMsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBfcmVmLmNvcm5lclJhZGl1cyxcbiAgICAgIHN0YXJ0QW5nbGUgPSBfcmVmLnN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IF9yZWYuZW5kQW5nbGUsXG4gICAgICBwYWRBbmdsZSA9IF9yZWYucGFkQW5nbGUsXG4gICAgICBwYWRSYWRpdXMgPSBfcmVmLnBhZFJhZGl1cyxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJywgJ2RhdGEnLCAnY2VudHJvaWQnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnY29ybmVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAncGFkQW5nbGUnLCAncGFkUmFkaXVzJ10pO1xuXG4gIHZhciBhcmMkJDEgPSBhcmMoKTtcbiAgaWYgKGNlbnRyb2lkKSBhcmMkJDEuY2VudHJvaWQoY2VudHJvaWQpO1xuICBpZiAoaW5uZXJSYWRpdXMpIGFyYyQkMS5pbm5lclJhZGl1cyhpbm5lclJhZGl1cyk7XG4gIGlmIChvdXRlclJhZGl1cykgYXJjJCQxLm91dGVyUmFkaXVzKG91dGVyUmFkaXVzKTtcbiAgaWYgKGNvcm5lclJhZGl1cykgYXJjJCQxLmNvcm5lclJhZGl1cyhjb3JuZXJSYWRpdXMpO1xuICBpZiAoc3RhcnRBbmdsZSkgYXJjJCQxLnN0YXJ0QW5nbGUoc3RhcnRBbmdsZSk7XG4gIGlmIChlbmRBbmdsZSkgYXJjJCQxLmVuZEFuZ2xlKGVuZEFuZ2xlKTtcbiAgaWYgKHBhZEFuZ2xlKSBhcmMkJDEucGFkQW5nbGUocGFkQW5nbGUpO1xuICBpZiAocGFkUmFkaXVzKSBhcmMkJDEucGFkUmFkaXVzKHBhZFJhZGl1cyk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoeyBjbGFzc05hbWU6IGN4KCd2eC1hcmMnLCBjbGFzc05hbWUpLCBkOiBhcmMkJDEoZGF0YSkgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuUGllLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheSxcbiAgY2VudHJvaWQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIGlubmVyUmFkaXVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBvdXRlclJhZGl1czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgY29ybmVyUmFkaXVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBzdGFydEFuZ2xlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBlbmRBbmdsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgcGFkQW5nbGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHBhZFJhZGl1czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgcGllU29ydDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBpZVNvcnRWYWx1ZXM6IFByb3BUeXBlcy5mdW5jLFxuICBwaWVWYWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBQaWUoX3JlZikge1xuICB2YXIgX3JlZiRjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYkY2xhc3NOYW1lID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkY2xhc3NOYW1lLFxuICAgICAgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3AsXG4gICAgICBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIGNlbnRyb2lkID0gX3JlZi5jZW50cm9pZCxcbiAgICAgIF9yZWYkaW5uZXJSYWRpdXMgPSBfcmVmLmlubmVyUmFkaXVzLFxuICAgICAgaW5uZXJSYWRpdXMgPSBfcmVmJGlubmVyUmFkaXVzID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRpbm5lclJhZGl1cyxcbiAgICAgIG91dGVyUmFkaXVzID0gX3JlZi5vdXRlclJhZGl1cyxcbiAgICAgIGNvcm5lclJhZGl1cyA9IF9yZWYuY29ybmVyUmFkaXVzLFxuICAgICAgX3JlZiRzdGFydEFuZ2xlID0gX3JlZi5zdGFydEFuZ2xlLFxuICAgICAgc3RhcnRBbmdsZSA9IF9yZWYkc3RhcnRBbmdsZSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlID0gX3JlZi5lbmRBbmdsZSxcbiAgICAgIHBhZEFuZ2xlID0gX3JlZi5wYWRBbmdsZSxcbiAgICAgIHBhZFJhZGl1cyA9IF9yZWYucGFkUmFkaXVzLFxuICAgICAgcGllU29ydCA9IF9yZWYucGllU29ydCxcbiAgICAgIHBpZVNvcnRWYWx1ZXMgPSBfcmVmLnBpZVNvcnRWYWx1ZXMsXG4gICAgICBwaWVWYWx1ZSA9IF9yZWYucGllVmFsdWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICdkYXRhJywgJ2NlbnRyb2lkJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ2Nvcm5lclJhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ3BhZEFuZ2xlJywgJ3BhZFJhZGl1cycsICdwaWVTb3J0JywgJ3BpZVNvcnRWYWx1ZXMnLCAncGllVmFsdWUnLCAnY2hpbGRyZW4nXSk7XG5cbiAgdmFyIHBhdGgkJDEgPSBhcmMoKTtcbiAgcGF0aCQkMS5pbm5lclJhZGl1cyhpbm5lclJhZGl1cyk7XG4gIGlmIChvdXRlclJhZGl1cykgcGF0aCQkMS5vdXRlclJhZGl1cyhvdXRlclJhZGl1cyk7XG4gIGlmIChjb3JuZXJSYWRpdXMpIHBhdGgkJDEuY29ybmVyUmFkaXVzKGNvcm5lclJhZGl1cyk7XG4gIGlmIChwYWRSYWRpdXMpIHBhdGgkJDEucGFkUmFkaXVzKHBhZFJhZGl1cyk7XG4gIHZhciBwaWUkJDEgPSBwaWUoKTtcbiAgaWYgKHBpZVNvcnQgIT09IHVuZGVmaW5lZCkgcGllJCQxLnNvcnQocGllU29ydCk7XG4gIGlmIChwaWVTb3J0VmFsdWVzICE9PSB1bmRlZmluZWQpIHBpZSQkMS5zb3J0VmFsdWVzKHBpZVNvcnRWYWx1ZXMpO1xuICBpZiAocGllVmFsdWUpIHBpZSQkMS52YWx1ZShwaWVWYWx1ZSk7XG4gIGlmIChwYWRBbmdsZSAhPSBudWxsKSBwaWUkJDEucGFkQW5nbGUocGFkQW5nbGUpO1xuICBpZiAoc3RhcnRBbmdsZSAhPSBudWxsKSBwaWUkJDEuc3RhcnRBbmdsZShzdGFydEFuZ2xlKTtcbiAgaWYgKGVuZEFuZ2xlICE9IG51bGwpIHBpZSQkMS5lbmRBbmdsZShlbmRBbmdsZSk7XG4gIHZhciBhcmNzID0gcGllJCQxKGRhdGEpO1xuICB2YXIgcmVuZGVyRnVuY3Rpb25BcmcgPSB7XG4gICAgYXJjczogYXJjcyxcbiAgICBnZW5lcmF0ZVBhdGhQcm9wczogZnVuY3Rpb24gZ2VuZXJhdGVQYXRoUHJvcHMoYXJjJCQxLCBpbmRleCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgY2xhc3NOYW1lOiBjeCgndngtcGllLWFyYycsIGNsYXNzTmFtZSksXG4gICAgICAgIGQ6IHBhdGgkJDEoYXJjJCQxKVxuICAgICAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgX2V4dGVuZHMoe30sIGFyYyQkMSwge1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNlbnRyb2lkOiBjZW50cm9pZCA/IHBhdGgkJDEuY2VudHJvaWQoYXJjJCQxKSA6IHVuZGVmaW5lZFxuICAgICAgfSkpKTtcbiAgICB9LFxuICAgIGdlbmVyYXRlQ2VudHJvaWQ6IGZ1bmN0aW9uIGdlbmVyYXRlQ2VudHJvaWQoYXJjJCQxKSB7XG4gICAgICByZXR1cm4gY2VudHJvaWQgJiYgY2VudHJvaWQocGF0aCQkMS5jZW50cm9pZChhcmMkJDEpLCBhcmMkJDEpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6ICd2eC1waWUtYXJjcy1ncm91cCcsIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgY2hpbGRyZW4gPyBjaGlsZHJlbihyZW5kZXJGdW5jdGlvbkFyZykgOiBhcmNzLm1hcChmdW5jdGlvbiAoYXJjJCQxLCBpKSB7XG4gICAgICB2YXIgcGF0aFByb3BzID0gcmVuZGVyRnVuY3Rpb25BcmcuZ2VuZXJhdGVQYXRoUHJvcHMoYXJjJCQxLCBpKTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZycsXG4gICAgICAgIHsga2V5OiAncGllLWFyYy0nICsgaSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgcGF0aFByb3BzKSxcbiAgICAgICAgcmVuZGVyRnVuY3Rpb25BcmcuZ2VuZXJhdGVDZW50cm9pZChhcmMkJDEpXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbkxpbmUucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmUoX3JlZikge1xuICB2YXIgX3JlZiRmcm9tID0gX3JlZi5mcm9tLFxuICAgICAgZnJvbSA9IF9yZWYkZnJvbSA9PT0gdW5kZWZpbmVkID8gbmV3IFBvaW50KHsgeDogMCwgeTogMCB9KSA6IF9yZWYkZnJvbSxcbiAgICAgIF9yZWYkdG8gPSBfcmVmLnRvLFxuICAgICAgdG8gPSBfcmVmJHRvID09PSB1bmRlZmluZWQgPyBuZXcgUG9pbnQoeyB4OiAxLCB5OiAxIH0pIDogX3JlZiR0byxcbiAgICAgIF9yZWYkc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2UgPSBfcmVmJHN0cm9rZSA9PT0gdW5kZWZpbmVkID8gJ2JsYWNrJyA6IF9yZWYkc3Ryb2tlLFxuICAgICAgX3JlZiRzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYkc3Ryb2tlV2lkdGggPT09IHVuZGVmaW5lZCA/IDEgOiBfcmVmJHN0cm9rZVdpZHRoLFxuICAgICAgX3JlZiRzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYkc3Ryb2tlRGFzaGFycmF5ID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgX3JlZiR0cmFuc2Zvcm0gPSBfcmVmLnRyYW5zZm9ybSxcbiAgICAgIHRyYW5zZm9ybSA9IF9yZWYkdHJhbnNmb3JtID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkdHJhbnNmb3JtLFxuICAgICAgX3JlZiRjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYkY2xhc3NOYW1lID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkY2xhc3NOYW1lLFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnZnJvbScsICd0bycsICdzdHJva2UnLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3RyYW5zZm9ybScsICdjbGFzc05hbWUnLCAnZGF0YScsICdpbm5lclJlZiddKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgnbGluZScsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmUnLCBjbGFzc05hbWUpLFxuICAgIHgxOiBmcm9tLngsXG4gICAgeTE6IGZyb20ueSxcbiAgICB4MjogdG8ueCxcbiAgICB5MjogdG8ueSxcbiAgICBzdHJva2U6IHN0cm9rZSxcbiAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1cbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuTGluZVBhdGgucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHhTY2FsZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHlTY2FsZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheSxcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBkZWZpbmVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgc3Ryb2tlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgZ2x5cGg6IFByb3BUeXBlcy5mdW5jLFxuICBjdXJ2ZTogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmVQYXRoKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICB4U2NhbGUgPSBfcmVmLnhTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICBfcmVmJGRlZmluZWQgPSBfcmVmLmRlZmluZWQsXG4gICAgICBkZWZpbmVkID0gX3JlZiRkZWZpbmVkID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gOiBfcmVmJGRlZmluZWQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIF9yZWYkc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2UgPSBfcmVmJHN0cm9rZSA9PT0gdW5kZWZpbmVkID8gJ3N0ZWVsYmx1ZScgOiBfcmVmJHN0cm9rZSxcbiAgICAgIF9yZWYkc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmJHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQgPyAyIDogX3JlZiRzdHJva2VXaWR0aCxcbiAgICAgIF9yZWYkc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmJHN0cm9rZURhc2hhcnJheSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJHN0cm9rZURhc2hhcnJheSxcbiAgICAgIF9yZWYkc3Ryb2tlRGFzaG9mZnNldCA9IF9yZWYuc3Ryb2tlRGFzaG9mZnNldCxcbiAgICAgIHN0cm9rZURhc2hvZmZzZXQgPSBfcmVmJHN0cm9rZURhc2hvZmZzZXQgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHN0cm9rZURhc2hvZmZzZXQsXG4gICAgICBfcmVmJGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICBmaWxsID0gX3JlZiRmaWxsID09PSB1bmRlZmluZWQgPyAnbm9uZScgOiBfcmVmJGZpbGwsXG4gICAgICBfcmVmJGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGN1cnZlID0gX3JlZiRjdXJ2ZSA9PT0gdW5kZWZpbmVkID8gY3VydmVMaW5lYXIgOiBfcmVmJGN1cnZlLFxuICAgICAgZ2x5cGggPSBfcmVmLmdseXBoLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmLmlubmVyUmVmLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydjaGlsZHJlbicsICdkYXRhJywgJ3hTY2FsZScsICd5U2NhbGUnLCAneCcsICd5JywgJ2RlZmluZWQnLCAnY2xhc3NOYW1lJywgJ3N0cm9rZScsICdzdHJva2VXaWR0aCcsICdzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlRGFzaG9mZnNldCcsICdmaWxsJywgJ2N1cnZlJywgJ2dseXBoJywgJ2lubmVyUmVmJ10pO1xuXG4gIHZhciBwYXRoJCQxID0gbGluZSgpLngoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KS55KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geVNjYWxlKHkuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSkuZGVmaW5lZChkZWZpbmVkKS5jdXJ2ZShjdXJ2ZSk7XG4gIGlmIChjaGlsZHJlbikgcmV0dXJuIGNoaWxkcmVuKHsgcGF0aDogcGF0aCQkMSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIG51bGwsXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICAgIHJlZjogaW5uZXJSZWYsXG4gICAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5lcGF0aCcsIGNsYXNzTmFtZSksXG4gICAgICBkOiBwYXRoJCQxKGRhdGEpLFxuICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IHN0cm9rZURhc2hvZmZzZXQsXG4gICAgICBmaWxsOiBmaWxsXG4gICAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKSxcbiAgICBnbHlwaCAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ2cnLFxuICAgICAgeyBjbGFzc05hbWU6ICd2eC1saW5lcGF0aC1nbHlwaHMnIH0sXG4gICAgICBkYXRhLm1hcChnbHlwaClcbiAgICApXG4gICk7XG59XG5cbkxpbmVSYWRpYWwucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmVSYWRpYWwoX3JlZikge1xuICB2YXIgX3JlZiRjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYkY2xhc3NOYW1lID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkY2xhc3NOYW1lLFxuICAgICAgYW5nbGUgPSBfcmVmLmFuZ2xlLFxuICAgICAgcmFkaXVzID0gX3JlZi5yYWRpdXMsXG4gICAgICBkZWZpbmVkID0gX3JlZi5kZWZpbmVkLFxuICAgICAgY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJywgJ2FuZ2xlJywgJ3JhZGl1cycsICdkZWZpbmVkJywgJ2N1cnZlJywgJ2RhdGEnLCAnaW5uZXJSZWYnXSk7XG5cbiAgdmFyIHBhdGgkJDEgPSByYWRpYWxMaW5lKCk7XG4gIGlmIChhbmdsZSkgcGF0aCQkMS5hbmdsZShhbmdsZSk7XG4gIGlmIChyYWRpdXMpIHBhdGgkJDEucmFkaXVzKHJhZGl1cyk7XG4gIGlmIChkZWZpbmVkKSBwYXRoJCQxLmRlZmluZWQoZGVmaW5lZCk7XG4gIGlmIChjdXJ2ZSkgcGF0aCQkMS5jdXJ2ZShjdXJ2ZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICdnJyxcbiAgICBudWxsLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgY2xhc3NOYW1lOiBjeCgndngtbGluZS1yYWRpYWwnLCBjbGFzc05hbWUpLFxuICAgICAgZDogcGF0aCQkMShkYXRhKVxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSlcbiAgKTtcbn1cblxuQXJlYS5wcm9wVHlwZXMgPSB7XG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB4MDogUHJvcFR5cGVzLmZ1bmMsXG4gIHgxOiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHkwOiBQcm9wVHlwZXMuZnVuYyxcbiAgeTE6IFByb3BUeXBlcy5mdW5jLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLFxuICB5U2NhbGU6IFByb3BUeXBlcy5mdW5jLFxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXksXG4gIGRlZmluZWQ6IFByb3BUeXBlcy5mdW5jLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuYXJyYXldKSxcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBzdHJva2VEYXNoYXJyYXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGZpbGw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGN1cnZlOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gQXJlYShfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeDAgPSBfcmVmLngwLFxuICAgICAgeDEgPSBfcmVmLngxLFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHkwID0gX3JlZi55MCxcbiAgICAgIHkxID0gX3JlZi55MSxcbiAgICAgIHhTY2FsZSA9IF9yZWYueFNjYWxlLFxuICAgICAgeVNjYWxlID0gX3JlZi55U2NhbGUsXG4gICAgICBfcmVmJGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBkYXRhID0gX3JlZiRkYXRhID09PSB1bmRlZmluZWQgPyBbXSA6IF9yZWYkZGF0YSxcbiAgICAgIF9yZWYkZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIGRlZmluZWQgPSBfcmVmJGRlZmluZWQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSA6IF9yZWYkZGVmaW5lZCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICBfcmVmJHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZiRzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gMiA6IF9yZWYkc3Ryb2tlV2lkdGgsXG4gICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHVuZGVmaW5lZCA/ICdibGFjaycgOiBfcmVmJHN0cm9rZSxcbiAgICAgIF9yZWYkZmlsbCA9IF9yZWYuZmlsbCxcbiAgICAgIGZpbGwgPSBfcmVmJGZpbGwgPT09IHVuZGVmaW5lZCA/ICdyZ2JhKDAsMCwwLDAuMyknIDogX3JlZiRmaWxsLFxuICAgICAgY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmLmlubmVyUmVmLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydjaGlsZHJlbicsICd4JywgJ3gwJywgJ3gxJywgJ3knLCAneTAnLCAneTEnLCAneFNjYWxlJywgJ3lTY2FsZScsICdkYXRhJywgJ2RlZmluZWQnLCAnY2xhc3NOYW1lJywgJ3N0cm9rZURhc2hhcnJheScsICdzdHJva2VXaWR0aCcsICdzdHJva2UnLCAnZmlsbCcsICdjdXJ2ZScsICdpbm5lclJlZiddKTtcblxuICB2YXIgcGF0aCQkMSA9IGFyZWEoKTtcbiAgaWYgKHgpIHBhdGgkJDEueChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHhTY2FsZSh4LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pO1xuICBpZiAoeDApIHBhdGgkJDEueDAoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeDAuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSk7XG4gIGlmICh4MSkgcGF0aCQkMS54MShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHhTY2FsZSh4MS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KTtcbiAgaWYgKHkpIHBhdGgkJDEueShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHlTY2FsZSh5LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pO1xuICBpZiAoeTApIHBhdGgkJDEueTAoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeTAuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSk7XG4gIGlmICh5MSkgcGF0aCQkMS55MShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHlTY2FsZSh5MS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KTtcbiAgaWYgKGRlZmluZWQpIHBhdGgkJDEuZGVmaW5lZChkZWZpbmVkKTtcbiAgaWYgKGN1cnZlKSBwYXRoJCQxLmN1cnZlKGN1cnZlKTtcbiAgaWYgKGNoaWxkcmVuKSByZXR1cm4gY2hpbGRyZW4oeyBwYXRoOiBwYXRoJCQxIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgbnVsbCxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgcmVmOiBpbm5lclJlZixcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWFyZWEnLCBjbGFzc05hbWUpLFxuICAgICAgZDogcGF0aCQkMShkYXRhKSxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgICBmaWxsOiBmaWxsXG4gICAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKVxuICApO1xufVxuXG5BcmVhQ2xvc2VkLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBBcmVhQ2xvc2VkKF9yZWYpIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgeTAgPSBfcmVmLnkwLFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB5U2NhbGUgPSBfcmVmLnlTY2FsZSxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBfcmVmJGRlZmluZWQgPSBfcmVmLmRlZmluZWQsXG4gICAgICBkZWZpbmVkID0gX3JlZiRkZWZpbmVkID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gOiBfcmVmJGRlZmluZWQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgX3JlZiRzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYkc3Ryb2tlV2lkdGggPT09IHVuZGVmaW5lZCA/IDIgOiBfcmVmJHN0cm9rZVdpZHRoLFxuICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB1bmRlZmluZWQgPyAnYmxhY2snIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICBmaWxsID0gX3JlZiRmaWxsID09PSB1bmRlZmluZWQgPyAncmdiYSgwLDAsMCwwLjMpJyA6IF9yZWYkZmlsbCxcbiAgICAgIGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsneCcsICd5JywgJ3kwJywgJ3hTY2FsZScsICd5U2NhbGUnLCAnZGF0YScsICdkZWZpbmVkJywgJ2NsYXNzTmFtZScsICdzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlJywgJ2ZpbGwnLCAnY3VydmUnLCAnaW5uZXJSZWYnXSk7XG5cbiAgdmFyIHBhdGgkJDEgPSBhcmVhKCkueChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHhTY2FsZSh4LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pLnkwKHkwIHx8IHlTY2FsZS5yYW5nZSgpWzBdKS55MShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHlTY2FsZSh5LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pLmRlZmluZWQoZGVmaW5lZCk7XG4gIGlmIChjdXJ2ZSkgcGF0aCQkMS5jdXJ2ZShjdXJ2ZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICdnJyxcbiAgICBudWxsLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgY2xhc3NOYW1lOiBjeCgndngtYXJlYS1jbG9zZWQnLCBjbGFzc05hbWUpLFxuICAgICAgZDogcGF0aCQkMShkYXRhKSxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgICBmaWxsOiBmaWxsXG4gICAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKVxuICApO1xufVxuXG5BcmVhU3RhY2sucHJvcFR5cGVzID0ge1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAga2V5czogUHJvcFR5cGVzLmFycmF5LFxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXksXG4gIGN1cnZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgZGVmaW5lZDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5ib29sXSksXG4gIHg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHgwOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICB4MTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgeTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgeTA6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHkxOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBnbHlwaDogUHJvcFR5cGVzLmJvb2wsXG4gIHJldmVyc2U6IFByb3BUeXBlcy5ib29sXG59O1xuXG5mdW5jdGlvbiBBcmVhU3RhY2soX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBrZXlzID0gX3JlZi5rZXlzLFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGRlZmluZWQgPSBfcmVmLmRlZmluZWQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeDAgPSBfcmVmLngwLFxuICAgICAgeDEgPSBfcmVmLngxLFxuICAgICAgeTAgPSBfcmVmLnkwLFxuICAgICAgeTEgPSBfcmVmLnkxLFxuICAgICAgZ2x5cGggPSBfcmVmLmdseXBoLFxuICAgICAgX3JlZiRyZXZlcnNlID0gX3JlZi5yZXZlcnNlLFxuICAgICAgcmV2ZXJzZSA9IF9yZWYkcmV2ZXJzZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHJldmVyc2UsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICdrZXlzJywgJ2RhdGEnLCAnY3VydmUnLCAnZGVmaW5lZCcsICd4JywgJ3gwJywgJ3gxJywgJ3kwJywgJ3kxJywgJ2dseXBoJywgJ3JldmVyc2UnXSk7XG5cbiAgdmFyIHN0YWNrJCQxID0gc3RhY2soKTtcbiAgaWYgKGtleXMpIHN0YWNrJCQxLmtleXMoa2V5cyk7XG5cbiAgdmFyIHBhdGgkJDEgPSBhcmVhKCk7XG4gIGlmICh4KSBwYXRoJCQxLngoeCk7XG4gIGlmICh4MCkgcGF0aCQkMS54MCh4MCk7XG4gIGlmICh4MSkgcGF0aCQkMS54MSh4MSk7XG4gIGlmICh5MCkgcGF0aCQkMS55MCh5MCk7XG4gIGlmICh5MSkgcGF0aCQkMS55MSh5MSk7XG4gIGlmIChjdXJ2ZSkgcGF0aCQkMS5jdXJ2ZShjdXJ2ZSk7XG4gIGlmIChkZWZpbmVkKSBwYXRoJCQxLmRlZmluZWQoZGVmaW5lZCk7XG5cbiAgdmFyIHNlcmllc0RhdGEgPSBzdGFjayQkMShkYXRhKTtcbiAgaWYgKHJldmVyc2UpIHNlcmllc0RhdGEucmV2ZXJzZSgpO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICdnJyxcbiAgICBudWxsLFxuICAgIHNlcmllc0RhdGEubWFwKGZ1bmN0aW9uIChzZXJpZXMsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgICBjbGFzc05hbWU6IGN4KCd2eC1hcmVhLXN0YWNrJywgY2xhc3NOYW1lKSxcbiAgICAgICAga2V5OiAnYXJlYS1zdGFjay0nICsgaSArICctJyArIChzZXJpZXMua2V5IHx8ICcnKSxcbiAgICAgICAgZDogcGF0aCQkMShzZXJpZXMpXG4gICAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCB7XG4gICAgICAgIGRhdHVtOiBzZXJpZXNbaV0sXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICBzZXJpZXM6IHNlcmllc1xuICAgICAgfSkpKTtcbiAgICB9KSxcbiAgICAhIWdseXBoICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZycsXG4gICAgICB7IGNsYXNzTmFtZTogJ3Z4LWFyZWEtc3RhY2stZ2x5cGhzJyB9LFxuICAgICAgZGF0YS5tYXAoZ2x5cGgpXG4gICAgKVxuICApO1xufVxuXG5CYXIucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEJhcihfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBfcmVmJHggPSBfcmVmLngsXG4gICAgICB4ID0gX3JlZiR4ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR4LFxuICAgICAgX3JlZiR5ID0gX3JlZi55LFxuICAgICAgeSA9IF9yZWYkeSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkeSxcbiAgICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgcnggPSBfcmVmLnJ4LFxuICAgICAgcnkgPSBfcmVmLnJ5LFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdW5kZWZpbmVkID8gJ3N0ZWVsYmx1ZScgOiBfcmVmJGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eSA9IF9yZWYuZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgc3Ryb2tlTGluZWNhcCA9IF9yZWYuc3Ryb2tlTGluZWNhcCxcbiAgICAgIHN0cm9rZUxpbmVqb2luID0gX3JlZi5zdHJva2VMaW5lam9pbixcbiAgICAgIHN0cm9rZU1pdGVybGltaXQgPSBfcmVmLnN0cm9rZU1pdGVybGltaXQsXG4gICAgICBzdHJva2VPcGFjaXR5ID0gX3JlZi5zdHJva2VPcGFjaXR5LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3J4JywgJ3J5JywgJ2ZpbGwnLCAnZmlsbE9wYWNpdHknLCAnc3Ryb2tlJywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZURhc2hhcnJheScsICdzdHJva2VMaW5lY2FwJywgJ3N0cm9rZUxpbmVqb2luJywgJ3N0cm9rZU1pdGVybGltaXQnLCAnc3Ryb2tlT3BhY2l0eSddKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncmVjdCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWJhcicsIGNsYXNzTmFtZSksXG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICByeDogcngsXG4gICAgcnk6IHJ5LFxuICAgIGZpbGw6IGZpbGwsXG4gICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5LFxuICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICBzdHJva2VMaW5lY2FwOiBzdHJva2VMaW5lY2FwLFxuICAgIHN0cm9rZUxpbmVqb2luOiBzdHJva2VMaW5lam9pbixcbiAgICBzdHJva2VNaXRlcmxpbWl0OiBzdHJva2VNaXRlcmxpbWl0LFxuICAgIHN0cm9rZU9wYWNpdHk6IHN0cm9rZU9wYWNpdHlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuQmFyR3JvdXAucHJvcFR5cGVzID0ge1xuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgeDA6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHgwU2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHgxU2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHlTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgelNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBrZXlzOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyXG59O1xuXG5mdW5jdGlvbiBCYXJHcm91cChfcmVmKSB7XG4gIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICB4MCA9IF9yZWYueDAsXG4gICAgICB4MFNjYWxlID0gX3JlZi54MFNjYWxlLFxuICAgICAgeDFTY2FsZSA9IF9yZWYueDFTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgelNjYWxlID0gX3JlZi56U2NhbGUsXG4gICAgICBrZXlzID0gX3JlZi5rZXlzLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2RhdGEnLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3gwJywgJ3gwU2NhbGUnLCAneDFTY2FsZScsICd5U2NhbGUnLCAnelNjYWxlJywgJ2tleXMnLCAnaGVpZ2h0J10pO1xuXG4gIHZhciBmb3JtYXQgPSB4MFNjYWxlLnRpY2tGb3JtYXQgPyB4MFNjYWxlLnRpY2tGb3JtYXQoKSA6IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiBjeCgndngtYmFyLWdyb3VwJywgY2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBkYXRhICYmIGRhdGEubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgR3JvdXAsXG4gICAgICAgIHsga2V5OiAnYmFyLWdyb3VwLScgKyBpICsgJy0nICsgeDAoZCksIGxlZnQ6IHgwU2NhbGUoeDAoZCkpIH0sXG4gICAgICAgIGtleXMgJiYga2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaikge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGRba2V5XTtcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChCYXIsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIGtleTogJ2Jhci1ncm91cC1iYXItJyArIGkgKyAnLScgKyBqICsgJy0nICsgdmFsdWUgKyAnLScgKyBrZXksXG4gICAgICAgICAgICB4OiB4MVNjYWxlKGtleSksXG4gICAgICAgICAgICB5OiB5U2NhbGUodmFsdWUpLFxuICAgICAgICAgICAgd2lkdGg6IHgxU2NhbGUuYmFuZHdpZHRoKCksXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAtIHlTY2FsZSh2YWx1ZSksXG4gICAgICAgICAgICBmaWxsOiB6U2NhbGUoa2V5KSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgeDogZm9ybWF0KHgwKGQpKSxcbiAgICAgICAgICAgICAgZGF0YTogZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlc3RQcm9wcykpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KVxuICApO1xufVxuXG5CYXJHcm91cEhvcml6b250YWwucHJvcFR5cGVzID0ge1xuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgeTA6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHkwU2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHkxU2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHhTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgelNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBrZXlzOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXJcbn07XG5cbmZ1bmN0aW9uIEJhckdyb3VwSG9yaXpvbnRhbChfcmVmKSB7XG4gIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB5MFNjYWxlID0gX3JlZi55MFNjYWxlLFxuICAgICAgeTFTY2FsZSA9IF9yZWYueTFTY2FsZSxcbiAgICAgIHhTY2FsZSA9IF9yZWYueFNjYWxlLFxuICAgICAgelNjYWxlID0gX3JlZi56U2NhbGUsXG4gICAgICBrZXlzID0gX3JlZi5rZXlzLFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydkYXRhJywgJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICd5MCcsICd5MFNjYWxlJywgJ3kxU2NhbGUnLCAneFNjYWxlJywgJ3pTY2FsZScsICdrZXlzJywgJ3dpZHRoJ10pO1xuXG4gIHZhciBmb3JtYXQgPSB5MFNjYWxlLnRpY2tGb3JtYXQgPyB5MFNjYWxlLnRpY2tGb3JtYXQoKSA6IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiBjeCgndngtYmFyLWdyb3VwLWhvcml6b250YWwnLCBjbGFzc05hbWUpLCB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIGRhdGEgJiYgZGF0YS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBHcm91cCxcbiAgICAgICAgeyBrZXk6ICdiYXItZ3JvdXAtJyArIGkgKyAnLScgKyB5MChkKSwgdG9wOiB5MFNjYWxlKHkwKGQpKSB9LFxuICAgICAgICBrZXlzICYmIGtleXMubWFwKGZ1bmN0aW9uIChrZXksIGopIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBkW2tleV07XG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBrZXk6ICdiYXItZ3JvdXAtYmFyLScgKyBpICsgJy0nICsgaiArICctJyArIHZhbHVlICsgJy0nICsga2V5LFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IHkxU2NhbGUoa2V5KSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCAtIHhTY2FsZSh2YWx1ZSksXG4gICAgICAgICAgICBoZWlnaHQ6IHkxU2NhbGUuYmFuZHdpZHRoKCksXG4gICAgICAgICAgICBmaWxsOiB6U2NhbGUoa2V5KSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgeTogZm9ybWF0KHkwKGQpKSxcbiAgICAgICAgICAgICAgZGF0YTogZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlc3RQcm9wcykpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KVxuICApO1xufVxuXG5mdW5jdGlvbiBvYmpIYXNNZXRob2Qob2JqLCBmdW5jTmFtZSkge1xuICByZXR1cm4gISFvYmpbZnVuY05hbWVdICYmIHR5cGVvZiBvYmpbZnVuY05hbWVdID09PSAnZnVuY3Rpb24nO1xufVxuXG5CYXJTdGFjay5wcm9wVHlwZXMgPSB7XG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICB4OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHlTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgelNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBrZXlzOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXJcbn07XG5cbmZ1bmN0aW9uIEJhclN0YWNrKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB4U2NhbGUgPSBfcmVmLnhTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgelNjYWxlID0gX3JlZi56U2NhbGUsXG4gICAgICBrZXlzID0gX3JlZi5rZXlzLFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2RhdGEnLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3gnLCAneFNjYWxlJywgJ3lTY2FsZScsICd6U2NhbGUnLCAna2V5cycsICd3aWR0aCcsICdoZWlnaHQnXSk7XG5cbiAgdmFyIHNlcmllcyA9IHN0YWNrKCkua2V5cyhrZXlzKShkYXRhKTtcbiAgdmFyIGZvcm1hdCA9IHhTY2FsZS50aWNrRm9ybWF0ID8geFNjYWxlLnRpY2tGb3JtYXQoKSA6IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG4gIHZhciB4UmFuZ2UgPSB4U2NhbGUucmFuZ2UoKTtcbiAgdmFyIHhEb21haW4gPSB4U2NhbGUuZG9tYWluKCk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiBjeCgndngtYmFyLXN0YWNrJywgY2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBzZXJpZXMgJiYgc2VyaWVzLm1hcChmdW5jdGlvbiAocywgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ3Z4LWJhci1zdGFjay0nICsgaSB9LFxuICAgICAgICBzLm1hcChmdW5jdGlvbiAoZCwgaWkpIHtcbiAgICAgICAgICB2YXIgYmFySGVpZ2h0ID0geVNjYWxlKGRbMF0pIC0geVNjYWxlKGRbMV0pO1xuICAgICAgICAgIHZhciBiYXJXaWR0aCA9IHdpZHRoIHx8IChvYmpIYXNNZXRob2QoeFNjYWxlLCAnYmFuZHdpZHRoJykgPyB4U2NhbGUuYmFuZHdpZHRoKCkgOiBNYXRoLmFicyh4UmFuZ2VbeFJhbmdlLmxlbmd0aCAtIDFdIC0geFJhbmdlWzBdKSAvIHhEb21haW4ubGVuZ3RoKTtcblxuICAgICAgICAgIHZhciBiYXJYID0gb2JqSGFzTWV0aG9kKHhTY2FsZSwgJ2JhbmR3aWR0aCcpID8geFNjYWxlKHgoZC5kYXRhKSkgOiB4U2NhbGUoeChkLmRhdGEpKSAtIGJhcldpZHRoIC8gMjtcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChCYXIsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIGtleTogJ2Jhci1ncm91cC1iYXItJyArIGkgKyAnLScgKyBpaSArICctJyArIHMua2V5LFxuICAgICAgICAgICAgeDogYmFyWCxcbiAgICAgICAgICAgIHk6IHlTY2FsZShkWzFdKSxcbiAgICAgICAgICAgIHdpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgICAgZmlsbDogelNjYWxlKHMua2V5KSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgcGFkZGluZ0lubmVyOiBvYmpIYXNNZXRob2QoeFNjYWxlLCAncGFkZGluZ0lubmVyJykgJiYgeFNjYWxlLnBhZGRpbmdJbm5lcigpLFxuICAgICAgICAgICAgICBwYWRkaW5nT3V0ZXI6IG9iakhhc01ldGhvZCh4U2NhbGUsICdwYWRkaW5nT3V0ZXInKSAmJiB4U2NhbGUucGFkZGluZ091dGVyKCksXG4gICAgICAgICAgICAgIHN0ZXA6IG9iakhhc01ldGhvZCh4U2NhbGUsICdzdGVwJykgJiYgeFNjYWxlLnN0ZXAoKSxcbiAgICAgICAgICAgICAga2V5OiBzLmtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGRbMV0sXG4gICAgICAgICAgICAgIGhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICAgIHg6IHgoZC5kYXRhKSxcbiAgICAgICAgICAgICAgeEZvcm1hdHRlZDogZm9ybWF0KHgoZC5kYXRhKSksXG4gICAgICAgICAgICAgIGRhdGE6IGQuZGF0YVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlc3RQcm9wcykpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KVxuICApO1xufVxuXG5CYXJTdGFja0hvcml6b250YWwucHJvcFR5cGVzID0ge1xuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgeTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgeFNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHpTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAga2V5czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyXG59O1xuXG5mdW5jdGlvbiBCYXJTdGFja0hvcml6b250YWwoX3JlZikge1xuICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHhTY2FsZSA9IF9yZWYueFNjYWxlLFxuICAgICAgeVNjYWxlID0gX3JlZi55U2NhbGUsXG4gICAgICB6U2NhbGUgPSBfcmVmLnpTY2FsZSxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnZGF0YScsICdjbGFzc05hbWUnLCAndG9wJywgJ2xlZnQnLCAneScsICd4U2NhbGUnLCAneVNjYWxlJywgJ3pTY2FsZScsICdrZXlzJywgJ3dpZHRoJywgJ2hlaWdodCddKTtcblxuICB2YXIgc2VyaWVzID0gc3RhY2soKS5rZXlzKGtleXMpKGRhdGEpO1xuICB2YXIgZm9ybWF0ID0geVNjYWxlLnRpY2tGb3JtYXQgPyB5U2NhbGUudGlja0Zvcm1hdCgpIDogZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfTtcbiAgdmFyIHlSYW5nZSA9IHlTY2FsZS5yYW5nZSgpO1xuICB2YXIgeURvbWFpbiA9IHlTY2FsZS5kb21haW4oKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1iYXItc3RhY2staG9yaXpvbnRhbCcsIGNsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgc2VyaWVzICYmIHNlcmllcy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBHcm91cCxcbiAgICAgICAgeyBrZXk6ICd2eC1iYXItc3RhY2staG9yaXpvbnRhbC0nICsgaSB9LFxuICAgICAgICBzLm1hcChmdW5jdGlvbiAoZCwgaWkpIHtcbiAgICAgICAgICB2YXIgYmFyV2lkdGggPSB4U2NhbGUoZFsxXSkgLSB4U2NhbGUoZFswXSk7XG4gICAgICAgICAgdmFyIGJhckhlaWdodCA9IHdpZHRoIHx8IChvYmpIYXNNZXRob2QoeVNjYWxlLCAnYmFuZHdpZHRoJykgPyB5U2NhbGUuYmFuZHdpZHRoKCkgOiBNYXRoLmFicyh5UmFuZ2VbeVJhbmdlLmxlbmd0aCAtIDFdIC0geVJhbmdlWzBdKSAvIHlEb21haW4ubGVuZ3RoKTtcblxuICAgICAgICAgIHZhciBiYXJZID0gb2JqSGFzTWV0aG9kKHlTY2FsZSwgJ2JhbmR3aWR0aCcpID8geVNjYWxlKHkoZC5kYXRhKSkgOiB5U2NhbGUoeShkLmRhdGEpKSAtIGJhckhlaWdodCAvIDI7XG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBrZXk6ICdiYXItZ3JvdXAtYmFyLScgKyBpICsgJy0nICsgaWkgKyAnLScgKyBzLmtleSxcbiAgICAgICAgICAgIHg6IHhTY2FsZShkWzBdKSxcbiAgICAgICAgICAgIHk6IGJhclksXG4gICAgICAgICAgICB3aWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgIGZpbGw6IHpTY2FsZShzLmtleSksXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHBhZGRpbmdJbm5lcjogb2JqSGFzTWV0aG9kKHlTY2FsZSwgJ3BhZGRpbmdJbm5lcicpICYmIHlTY2FsZS5wYWRkaW5nSW5uZXIoKSxcbiAgICAgICAgICAgICAgcGFkZGluZ091dGVyOiBvYmpIYXNNZXRob2QoeVNjYWxlLCAncGFkZGluZ091dGVyJykgJiYgeVNjYWxlLnBhZGRpbmdPdXRlcigpLFxuICAgICAgICAgICAgICBzdGVwOiBvYmpIYXNNZXRob2QoeVNjYWxlLCAnc3RlcCcpICYmIHlTY2FsZS5zdGVwKCksXG4gICAgICAgICAgICAgIGtleTogcy5rZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBkWzBdLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgICB5OiB5KGQuZGF0YSksXG4gICAgICAgICAgICAgIHlGb3JtYXR0ZWQ6IGZvcm1hdCh5KGQuZGF0YSkpLFxuICAgICAgICAgICAgICBkYXRhOiBkLmRhdGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXN0UHJvcHMpKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSlcbiAgKTtcbn1cblxudmFyIFNUQUNLX09SREVSUyA9IHtcbiAgYXNjZW5kaW5nOiBzdGFja09yZGVyQXNjZW5kaW5nLFxuICBkZXNjZW5kaW5nOiBzdGFja09yZGVyRGVzY2VuZGluZyxcbiAgaW5zaWRlb3V0OiBzdGFja09yZGVySW5zaWRlT3V0LFxuICBub25lOiBzdGFja09yZGVyTm9uZSxcbiAgcmV2ZXJzZTogc3RhY2tPcmRlclJldmVyc2Vcbn07XG5cbnZhciBTVEFDS19PUkRFUl9OQU1FUyA9IE9iamVjdC5rZXlzKFNUQUNLX09SREVSUyk7XG5cbmZ1bmN0aW9uIHN0YWNrT3JkZXIob3JkZXIpIHtcbiAgcmV0dXJuIFNUQUNLX09SREVSU1tvcmRlcl0gfHwgU1RBQ0tfT1JERVJTLm5vbmU7XG59XG5cbnZhciBTVEFDS19PRkZTRVRTID0ge1xuICBleHBhbmQ6IHN0YWNrT2Zmc2V0RXhwYW5kLFxuICBkaXZlcmdpbmc6IHN0YWNrT2Zmc2V0RGl2ZXJnaW5nLFxuICBub25lOiBzdGFja09mZnNldE5vbmUsXG4gIHNpbGhvdWV0dGU6IHN0YWNrT2Zmc2V0U2lsaG91ZXR0ZSxcbiAgd2lnZ2xlOiBzdGFja09mZnNldFdpZ2dsZVxufTtcblxudmFyIFNUQUNLX09GRlNFVF9OQU1FUyA9IE9iamVjdC5rZXlzKFNUQUNLX09GRlNFVFMpO1xuXG5mdW5jdGlvbiBzdGFja09mZnNldChvZmZzZXQpIHtcbiAgcmV0dXJuIFNUQUNLX09GRlNFVFNbb2Zmc2V0XSB8fCBTVEFDS19PRkZTRVRTLm5vbmU7XG59XG5cblN0YWNrLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGtleXM6IFByb3BUeXBlcy5hcnJheSxcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LFxuICBjdXJ2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGRlZmluZWQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuYm9vbF0pLFxuICB4OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICB4MDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgeDE6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHkwOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICB5MTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIG9yZGVyOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLmFycmF5LCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIG9mZnNldDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICByZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICByZXZlcnNlOiBQcm9wVHlwZXMuYm9vbFxufTtcblxuZnVuY3Rpb24gU3RhY2soX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBfcmVmJHRvcCA9IF9yZWYudG9wLFxuICAgICAgdG9wID0gX3JlZiR0b3AgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHRvcCxcbiAgICAgIF9yZWYkbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIGxlZnQgPSBfcmVmJGxlZnQgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJGxlZnQsXG4gICAgICBrZXlzID0gX3JlZi5rZXlzLFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGRlZmluZWQgPSBfcmVmLmRlZmluZWQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeDAgPSBfcmVmLngwLFxuICAgICAgeDEgPSBfcmVmLngxLFxuICAgICAgeTAgPSBfcmVmLnkwLFxuICAgICAgeTEgPSBfcmVmLnkxLFxuICAgICAgdmFsdWUgPSBfcmVmLnZhbHVlLFxuICAgICAgb3JkZXIgPSBfcmVmLm9yZGVyLFxuICAgICAgb2Zmc2V0ID0gX3JlZi5vZmZzZXQsXG4gICAgICByZW5kZXIgPSBfcmVmLnJlbmRlcixcbiAgICAgIF9yZWYkcmV2ZXJzZSA9IF9yZWYucmV2ZXJzZSxcbiAgICAgIHJldmVyc2UgPSBfcmVmJHJldmVyc2UgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRyZXZlcnNlLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydjbGFzc05hbWUnLCAndG9wJywgJ2xlZnQnLCAna2V5cycsICdkYXRhJywgJ2N1cnZlJywgJ2RlZmluZWQnLCAneCcsICd4MCcsICd4MScsICd5MCcsICd5MScsICd2YWx1ZScsICdvcmRlcicsICdvZmZzZXQnLCAncmVuZGVyJywgJ3JldmVyc2UnXSk7XG5cbiAgdmFyIHN0YWNrJCQxID0gc3RhY2soKTtcbiAgaWYgKGtleXMpIHN0YWNrJCQxLmtleXMoa2V5cyk7XG4gIGlmICh2YWx1ZSkgc3RhY2skJDEudmFsdWUodmFsdWUpO1xuICBpZiAob3JkZXIpIHN0YWNrJCQxLm9yZGVyKHN0YWNrT3JkZXIob3JkZXIpKTtcbiAgaWYgKG9mZnNldCkgc3RhY2skJDEub2Zmc2V0KHN0YWNrT2Zmc2V0KG9mZnNldCkpO1xuXG4gIHZhciBwYXRoJCQxID0gYXJlYSgpO1xuICBpZiAoeCkgcGF0aCQkMS54KHgpO1xuICBpZiAoeDApIHBhdGgkJDEueDAoeDApO1xuICBpZiAoeDEpIHBhdGgkJDEueDEoeDEpO1xuICBpZiAoeTApIHBhdGgkJDEueTAoeTApO1xuICBpZiAoeTEpIHBhdGgkJDEueTEoeTEpO1xuICBpZiAoY3VydmUpIHBhdGgkJDEuY3VydmUoY3VydmUpO1xuICBpZiAoZGVmaW5lZCkgcGF0aCQkMS5kZWZpbmVkKGRlZmluZWQpO1xuXG4gIHZhciBzZXJpZXNEYXRhID0gc3RhY2skJDEoZGF0YSk7XG4gIGlmIChyZXZlcnNlKSBzZXJpZXNEYXRhLnJldmVyc2UoKTtcblxuICBpZiAocmVuZGVyKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBHcm91cCxcbiAgICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICAgIHJlbmRlcih7IHNlcmllc0RhdGE6IHNlcmllc0RhdGEsIHBhdGg6IHBhdGgkJDEgfSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIHNlcmllc0RhdGEubWFwKGZ1bmN0aW9uIChzZXJpZXMsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgICBjbGFzc05hbWU6IGN4KCd2eC1zdGFjaycsIGNsYXNzTmFtZSksXG4gICAgICAgIGtleTogJ3N0YWNrLScgKyBpICsgJy0nICsgKHNlcmllcy5rZXkgfHwgJycpLFxuICAgICAgICBkOiBwYXRoJCQxKHNlcmllcylcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIHtcbiAgICAgICAgZGF0dW06IHNlcmllc1tpXSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICB9KSkpO1xuICAgIH0pXG4gICk7XG59XG5cbnZhciBkZWdyZWVzVG9SYWRpYW5zID0gZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKSB7XG4gIHJldHVybiBNYXRoLlBJIC8gMTgwICogZGVncmVlcztcbn07XG5cbmZ1bmN0aW9uIHBhdGhIb3Jpem9udGFsRGlhZ29uYWwoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsaW5rID0gbGlua0hvcml6b250YWwoKTtcbiAgICBsaW5rLngoeCk7XG4gICAgbGluay55KHkpO1xuICAgIGxpbmsuc291cmNlKHNvdXJjZSk7XG4gICAgbGluay50YXJnZXQodGFyZ2V0KTtcbiAgICByZXR1cm4gbGluayhkYXRhKTtcbiAgfTtcbn1cblxuTGlua0hvcml6b250YWwucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtIb3Jpem9udGFsKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhIb3Jpem9udGFsRGlhZ29uYWwoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluay1ob3Jpem9udGFsJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhWZXJ0aWNhbERpYWdvbmFsKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbGluayA9IGxpbmtWZXJ0aWNhbCgpO1xuICAgIGxpbmsueCh4KTtcbiAgICBsaW5rLnkoeSk7XG4gICAgbGluay5zb3VyY2Uoc291cmNlKTtcbiAgICBsaW5rLnRhcmdldCh0YXJnZXQpO1xuICAgIHJldHVybiBsaW5rKGRhdGEpO1xuICB9O1xufVxuXG5MaW5rVmVydGljYWwucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtWZXJ0aWNhbChfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoVmVydGljYWxEaWFnb25hbCh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rLXZlcnRpY2FsJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhSYWRpYWxEaWFnb25hbChfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgYW5nbGUgPSBfcmVmLmFuZ2xlLFxuICAgICAgcmFkaXVzID0gX3JlZi5yYWRpdXM7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGxpbmsgPSBsaW5rUmFkaWFsKCk7XG4gICAgbGluay5hbmdsZShhbmdsZSk7XG4gICAgbGluay5yYWRpdXMocmFkaXVzKTtcbiAgICBsaW5rLnNvdXJjZShzb3VyY2UpO1xuICAgIGxpbmsudGFyZ2V0KHRhcmdldCk7XG4gICAgcmV0dXJuIGxpbmsoZGF0YSk7XG4gIH07XG59XG5cbkxpbmtSYWRpYWwucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIGFuZ2xlOiBQcm9wVHlwZXMuZnVuYyxcbiAgcmFkaXVzOiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtSYWRpYWwoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkYW5nbGUgPSBfcmVmMi5hbmdsZSxcbiAgICAgIGFuZ2xlID0gX3JlZjIkYW5nbGUgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJGFuZ2xlLFxuICAgICAgX3JlZjIkcmFkaXVzID0gX3JlZjIucmFkaXVzLFxuICAgICAgcmFkaXVzID0gX3JlZjIkcmFkaXVzID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiRyYWRpdXMsXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAnYW5nbGUnLCAncmFkaXVzJywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFJhZGlhbERpYWdvbmFsKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCBhbmdsZTogYW5nbGUsIHJhZGl1czogcmFkaXVzIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmstcmFkaXVzJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhIb3Jpem9udGFsQ3VydmUoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgcGVyY2VudCA9IF9yZWYucGVyY2VudDtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgZHggPSB0eCAtIHN4O1xuICAgIHZhciBkeSA9IHR5IC0gc3k7XG4gICAgdmFyIGl4ID0gcGVyY2VudCAqIChkeCArIGR5KTtcbiAgICB2YXIgaXkgPSBwZXJjZW50ICogKGR5IC0gZHgpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3gsIHN5KTtcbiAgICBwYXRoJCQxLmJlemllckN1cnZlVG8oc3ggKyBpeCwgc3kgKyBpeSwgdHggKyBpeSwgdHkgLSBpeCwgdHgsIHR5KTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtIb3Jpem9udGFsQ3VydmUucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtIb3Jpem9udGFsQ3VydmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuMiA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0JywgJ3BlcmNlbnQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aEhvcml6b250YWxDdXJ2ZSh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSwgcGVyY2VudDogcGVyY2VudCB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhWZXJ0aWNhbEN1cnZlKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHBlcmNlbnQgPSBfcmVmLnBlcmNlbnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc3ggPSB4KHNvdXJjZURhdGEpO1xuICAgIHZhciBzeSA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHR4ID0geCh0YXJnZXREYXRhKTtcbiAgICB2YXIgdHkgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIGR4ID0gdHggLSBzeDtcbiAgICB2YXIgZHkgPSB0eSAtIHN5O1xuICAgIHZhciBpeCA9IHBlcmNlbnQgKiAoZHggKyBkeSk7XG4gICAgdmFyIGl5ID0gcGVyY2VudCAqIChkeSAtIGR4KTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHN4LCBzeSk7XG4gICAgcGF0aCQkMS5iZXppZXJDdXJ2ZVRvKHN4ICsgaXgsIHN5ICsgaXksIHR4ICsgaXksIHR5IC0gaXgsIHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rVmVydGljYWxDdXJ2ZS5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlcixcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua1ZlcnRpY2FsQ3VydmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuMiA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0JywgJ3BlcmNlbnQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFZlcnRpY2FsQ3VydmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHksIHBlcmNlbnQ6IHBlcmNlbnQgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoUmFkaWFsQ3VydmUoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgcGVyY2VudCA9IF9yZWYucGVyY2VudDtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzYSA9IHgoc291cmNlRGF0YSkgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgc3IgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0YSA9IHgodGFyZ2V0RGF0YSkgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgdHIgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIHNjID0gTWF0aC5jb3Moc2EpO1xuICAgIHZhciBzcyA9IE1hdGguc2luKHNhKTtcbiAgICB2YXIgdGMgPSBNYXRoLmNvcyh0YSk7XG4gICAgdmFyIHRzID0gTWF0aC5zaW4odGEpO1xuXG4gICAgdmFyIHN4ID0gc3IgKiBzYztcbiAgICB2YXIgc3kgPSBzciAqIHNzO1xuICAgIHZhciB0eCA9IHRyICogdGM7XG4gICAgdmFyIHR5ID0gdHIgKiB0cztcblxuICAgIHZhciBkeCA9IHR4IC0gc3g7XG4gICAgdmFyIGR5ID0gdHkgLSBzeTtcbiAgICB2YXIgaXggPSBwZXJjZW50ICogKGR4ICsgZHkpO1xuICAgIHZhciBpeSA9IHBlcmNlbnQgKiAoZHkgLSBkeCk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEuYmV6aWVyQ3VydmVUbyhzeCArIGl4LCBzeSArIGl5LCB0eCArIGl5LCB0eSAtIGl4LCB0eCwgdHkpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua1JhZGlhbEN1cnZlLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwZXJjZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rUmFkaWFsQ3VydmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuMiA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0JywgJ3BlcmNlbnQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFJhZGlhbEN1cnZlKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5LCBwZXJjZW50OiBwZXJjZW50IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aEhvcml6b250YWxMaW5lKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEubGluZVRvKHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rSG9yaXpvbnRhbExpbmUucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtIb3Jpem9udGFsTGluZShfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoSG9yaXpvbnRhbExpbmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoVmVydGljYWxMaW5lKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEubGluZVRvKHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rVmVydGljYWxMaW5lLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuYyxcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rVmVydGljYWxMaW5lKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhWZXJ0aWNhbExpbmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoUmFkaWFsTGluZShfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc2EgPSB4KHNvdXJjZURhdGEpIC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHNyID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdGEgPSB4KHRhcmdldERhdGEpIC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHRyID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBzYyA9IE1hdGguY29zKHNhKTtcbiAgICB2YXIgc3MgPSBNYXRoLnNpbihzYSk7XG4gICAgdmFyIHRjID0gTWF0aC5jb3ModGEpO1xuICAgIHZhciB0cyA9IE1hdGguc2luKHRhKTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHNyICogc2MsIHNyICogc3MpO1xuICAgIHBhdGgkJDEubGluZVRvKHRyICogdGMsIHRyICogdHMpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua1JhZGlhbFN0ZXAucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtSYWRpYWxTdGVwKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhSYWRpYWxMaW5lKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aEhvcml6b250YWxTdGVwKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHBlcmNlbnQgPSBfcmVmLnBlcmNlbnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc3ggPSB4KHNvdXJjZURhdGEpO1xuICAgIHZhciBzeSA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHR4ID0geCh0YXJnZXREYXRhKTtcbiAgICB2YXIgdHkgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3gsIHN5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyhzeCArICh0eCAtIHN4KSAqIHBlcmNlbnQsIHN5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyhzeCArICh0eCAtIHN4KSAqIHBlcmNlbnQsIHR5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyh0eCwgdHkpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua0hvcml6b250YWxTdGVwLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwZXJjZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rSG9yaXpvbnRhbFN0ZXAoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkcGVyY2VudCA9IF9yZWYyLnBlcmNlbnQsXG4gICAgICBwZXJjZW50ID0gX3JlZjIkcGVyY2VudCA9PT0gdW5kZWZpbmVkID8gMC41IDogX3JlZjIkcGVyY2VudCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3BlcmNlbnQnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aEhvcml6b250YWxTdGVwKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5LCBwZXJjZW50OiBwZXJjZW50IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aFZlcnRpY2FsU3RlcChfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICBwZXJjZW50ID0gX3JlZi5wZXJjZW50O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzb3VyY2VEYXRhID0gc291cmNlKGRhdGEpO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0KGRhdGEpO1xuXG4gICAgdmFyIHN4ID0geChzb3VyY2VEYXRhKTtcbiAgICB2YXIgc3kgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0eCA9IHgodGFyZ2V0RGF0YSk7XG4gICAgdmFyIHR5ID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHN4LCBzeSk7XG4gICAgcGF0aCQkMS5saW5lVG8oc3gsIHN5ICsgKHR5IC0gc3kpICogcGVyY2VudCk7XG4gICAgcGF0aCQkMS5saW5lVG8odHgsIHN5ICsgKHR5IC0gc3kpICogcGVyY2VudCk7XG4gICAgcGF0aCQkMS5saW5lVG8odHgsIHR5KTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtWZXJ0aWNhbFN0ZXAucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtWZXJ0aWNhbFN0ZXAoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkcGVyY2VudCA9IF9yZWYyLnBlcmNlbnQsXG4gICAgICBwZXJjZW50ID0gX3JlZjIkcGVyY2VudCA9PT0gdW5kZWZpbmVkID8gMC41IDogX3JlZjIkcGVyY2VudCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3BlcmNlbnQnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFZlcnRpY2FsU3RlcCh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSwgcGVyY2VudDogcGVyY2VudCB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhSYWRpYWxTdGVwKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgc2EgPSBzeCAtIE1hdGguUEkgLyAyO1xuICAgIHZhciBzciA9IHN5O1xuICAgIHZhciB0YSA9IHR4IC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHRyID0gdHk7XG5cbiAgICB2YXIgc2MgPSBNYXRoLmNvcyhzYSk7XG4gICAgdmFyIHNzID0gTWF0aC5zaW4oc2EpO1xuICAgIHZhciB0YyA9IE1hdGguY29zKHRhKTtcbiAgICB2YXIgdHMgPSBNYXRoLnNpbih0YSk7XG4gICAgdmFyIHNmID0gTWF0aC5hYnModGEgLSBzYSkgPiBNYXRoLlBJID8gdGEgPD0gc2EgOiB0YSA+IHNhO1xuXG4gICAgcmV0dXJuICdcXG4gICAgICBNJyArIHNyICogc2MgKyAnLCcgKyBzciAqIHNzICsgJ1xcbiAgICAgIEEnICsgc3IgKyAnLCcgKyBzciArICcsMCwwLCcgKyAoc2YgPyAxIDogMCkgKyAnLCcgKyBzciAqIHRjICsgJywnICsgc3IgKiB0cyArICdcXG4gICAgICBMJyArIHRyICogdGMgKyAnLCcgKyB0ciAqIHRzICsgJ1xcbiAgICAnO1xuICB9O1xufVxuXG5MaW5rUmFkaWFsU3RlcCQxLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rUmFkaWFsU3RlcCQxKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhSYWRpYWxTdGVwKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuUG9seWdvbi5wcm9wVHlwZXMgPSB7XG4gIHNpZGVzOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHNpemU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICByb3RhdGU6IFByb3BUeXBlcy5udW1iZXJcbn07XG5cbnZhciBnZXRQb2ludCA9IGZ1bmN0aW9uIGdldFBvaW50KF9yZWYpIHtcbiAgdmFyIHNpZGVzID0gX3JlZi5zaWRlcyxcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICBjZW50ZXIgPSBfcmVmLmNlbnRlcixcbiAgICAgIHJvdGF0ZSA9IF9yZWYucm90YXRlLFxuICAgICAgc2lkZSA9IF9yZWYuc2lkZTtcblxuICB2YXIgZGVncmVlcyA9IDM2MCAvIHNpZGVzICogc2lkZSAtIHJvdGF0ZTtcbiAgdmFyIHJhZGlhbnMgPSBkZWdyZWVzVG9SYWRpYW5zKGRlZ3JlZXMpO1xuXG4gIHJldHVybiBuZXcgUG9pbnQoe1xuICAgIHg6IGNlbnRlci54ICsgc2l6ZSAqIE1hdGguY29zKHJhZGlhbnMpLFxuICAgIHk6IGNlbnRlci55ICsgc2l6ZSAqIE1hdGguc2luKHJhZGlhbnMpXG4gIH0pO1xufTtcblxudmFyIGdldFBvaW50cyA9IGZ1bmN0aW9uIGdldFBvaW50cyhfcmVmMikge1xuICB2YXIgc2lkZXMgPSBfcmVmMi5zaWRlcyxcbiAgICAgIHNpemUgPSBfcmVmMi5zaXplLFxuICAgICAgY2VudGVyID0gX3JlZjIuY2VudGVyLFxuICAgICAgcm90YXRlID0gX3JlZjIucm90YXRlO1xuXG4gIHJldHVybiBbXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoQXJyYXkoc2lkZXMpLmtleXMoKSkpLm1hcChmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBnZXRQb2ludCh7XG4gICAgICBzaWRlczogc2lkZXMsXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICAgIHNpZGU6IHNpZGVcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBQb2x5Z29uKF9yZWYzKSB7XG4gIHZhciBzaWRlcyA9IF9yZWYzLnNpZGVzLFxuICAgICAgX3JlZjMkc2l6ZSA9IF9yZWYzLnNpemUsXG4gICAgICBzaXplID0gX3JlZjMkc2l6ZSA9PT0gdW5kZWZpbmVkID8gMjUgOiBfcmVmMyRzaXplLFxuICAgICAgX3JlZjMkY2VudGVyID0gX3JlZjMuY2VudGVyLFxuICAgICAgY2VudGVyID0gX3JlZjMkY2VudGVyID09PSB1bmRlZmluZWQgPyBuZXcgUG9pbnQoeyB4OiAwLCB5OiAwIH0pIDogX3JlZjMkY2VudGVyLFxuICAgICAgX3JlZjMkcm90YXRlID0gX3JlZjMucm90YXRlLFxuICAgICAgcm90YXRlID0gX3JlZjMkcm90YXRlID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjMkcm90YXRlLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZjMuY2xhc3NOYW1lLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjMsIFsnc2lkZXMnLCAnc2l6ZScsICdjZW50ZXInLCAncm90YXRlJywgJ2NsYXNzTmFtZSddKTtcblxuICB2YXIgcG9pbnRzID0gZ2V0UG9pbnRzKHtcbiAgICBzaWRlczogc2lkZXMsXG4gICAgc2l6ZTogc2l6ZSxcbiAgICBjZW50ZXI6IGNlbnRlcixcbiAgICByb3RhdGU6IHJvdGF0ZVxuICB9KS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC50b0FycmF5KCk7XG4gIH0pLmpvaW4oJyAnKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncG9seWdvbicsIF9leHRlbmRzKHsgcG9pbnRzOiBwb2ludHMsIGNsYXNzTmFtZTogY3goJ3Z4LXBvbHlnb24nLCBjbGFzc05hbWUpIH0sIHJlc3RQcm9wcykpO1xufVxuXG5leHBvcnQgeyBBcmMsIFBpZSwgTGluZSwgTGluZVBhdGgsIExpbmVSYWRpYWwsIEFyZWEsIEFyZWFDbG9zZWQsIEFyZWFTdGFjaywgQmFyLCBCYXJHcm91cCwgQmFyR3JvdXBIb3Jpem9udGFsLCBCYXJTdGFjaywgQmFyU3RhY2tIb3Jpem9udGFsLCBTdGFjaywgY2FsbE9yVmFsdWUsIHN0YWNrT2Zmc2V0LCBTVEFDS19PRkZTRVRTLCBTVEFDS19PRkZTRVRfTkFNRVMsIHN0YWNrT3JkZXIsIFNUQUNLX09SREVSUywgU1RBQ0tfT1JERVJfTkFNRVMsIGRlZ3JlZXNUb1JhZGlhbnMsIExpbmtIb3Jpem9udGFsLCBwYXRoSG9yaXpvbnRhbERpYWdvbmFsLCBMaW5rVmVydGljYWwsIHBhdGhWZXJ0aWNhbERpYWdvbmFsLCBMaW5rUmFkaWFsLCBwYXRoUmFkaWFsRGlhZ29uYWwsIExpbmtIb3Jpem9udGFsQ3VydmUsIHBhdGhIb3Jpem9udGFsQ3VydmUsIExpbmtWZXJ0aWNhbEN1cnZlLCBwYXRoVmVydGljYWxDdXJ2ZSwgTGlua1JhZGlhbEN1cnZlLCBwYXRoUmFkaWFsQ3VydmUsIExpbmtIb3Jpem9udGFsTGluZSwgcGF0aEhvcml6b250YWxMaW5lLCBMaW5rVmVydGljYWxMaW5lLCBwYXRoVmVydGljYWxMaW5lLCBMaW5rUmFkaWFsU3RlcCBhcyBMaW5rUmFkaWFsTGluZSwgcGF0aFJhZGlhbExpbmUsIExpbmtIb3Jpem9udGFsU3RlcCwgcGF0aEhvcml6b250YWxTdGVwLCBMaW5rVmVydGljYWxTdGVwLCBwYXRoVmVydGljYWxTdGVwLCBMaW5rUmFkaWFsU3RlcCQxIGFzIExpbmtSYWRpYWxTdGVwLCBwYXRoUmFkaWFsU3RlcCwgUG9seWdvbiwgZ2V0UG9pbnRzLCBnZXRQb2ludCB9O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBMaW5lIH0gZnJvbSAnQHZ4L3NoYXBlJztcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZ4L2dyb3VwJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnQHZ4L3BvaW50JztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuUm93cy5wcm9wVHlwZXMgPSB7XG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbnVtVGlja3M6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxpbmVTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgb2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBzY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgdGlja1ZhbHVlczogUHJvcFR5cGVzLmFycmF5XG59O1xuXG5mdW5jdGlvbiBSb3dzKF9yZWYpIHtcbiAgdmFyIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIHNjYWxlID0gX3JlZi5zY2FsZSxcbiAgICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIF9yZWYkc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2UgPSBfcmVmJHN0cm9rZSA9PT0gdW5kZWZpbmVkID8gJyNlYWYwZjYnIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZiRzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gMSA6IF9yZWYkc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgX3JlZiRudW1UaWNrcyA9IF9yZWYubnVtVGlja3MsXG4gICAgICBudW1UaWNrcyA9IF9yZWYkbnVtVGlja3MgPT09IHVuZGVmaW5lZCA/IDEwIDogX3JlZiRudW1UaWNrcyxcbiAgICAgIGxpbmVTdHlsZSA9IF9yZWYubGluZVN0eWxlLFxuICAgICAgb2Zmc2V0ID0gX3JlZi5vZmZzZXQsXG4gICAgICB0aWNrVmFsdWVzID0gX3JlZi50aWNrVmFsdWVzLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWyd0b3AnLCAnbGVmdCcsICdzY2FsZScsICd3aWR0aCcsICdzdHJva2UnLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ2NsYXNzTmFtZScsICdudW1UaWNrcycsICdsaW5lU3R5bGUnLCAnb2Zmc2V0JywgJ3RpY2tWYWx1ZXMnXSk7XG5cbiAgdmFyIHRpY2tzID0gc2NhbGUudGlja3MgPyBzY2FsZS50aWNrcyhudW1UaWNrcykgOiBzY2FsZS5kb21haW4oKTtcbiAgaWYgKHRpY2tWYWx1ZXMpIHRpY2tzID0gdGlja1ZhbHVlcztcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1yb3dzJywgY2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICB0aWNrcy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHZhciB5ID0gb2Zmc2V0ID8gc2NhbGUoZCkgKyBvZmZzZXQgOiBzY2FsZShkKTtcbiAgICAgIHZhciBmcm9tUG9pbnQgPSBuZXcgUG9pbnQoe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICAgIHZhciB0b1BvaW50ID0gbmV3IFBvaW50KHtcbiAgICAgICAgeDogd2lkdGgsXG4gICAgICAgIHk6IHlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluZSwgX2V4dGVuZHMoe1xuICAgICAgICBrZXk6ICdyb3ctbGluZS0nICsgZCArICctJyArIGksXG4gICAgICAgIGZyb206IGZyb21Qb2ludCxcbiAgICAgICAgdG86IHRvUG9pbnQsXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgICBzdHlsZTogbGluZVN0eWxlXG4gICAgICB9LCByZXN0UHJvcHMpKTtcbiAgICB9KVxuICApO1xufVxuXG5Db2x1bW5zLnByb3BUeXBlcyA9IHtcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgc3Ryb2tlRGFzaGFycmF5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBudW1UaWNrczogUHJvcFR5cGVzLm51bWJlcixcbiAgbGluZVN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBvZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgdGlja1ZhbHVlczogUHJvcFR5cGVzLmFycmF5XG59O1xuXG5mdW5jdGlvbiBDb2x1bW5zKF9yZWYpIHtcbiAgdmFyIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIHNjYWxlID0gX3JlZi5zY2FsZSxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB1bmRlZmluZWQgPyAnI2VhZjBmNicgOiBfcmVmJHN0cm9rZSxcbiAgICAgIF9yZWYkc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmJHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQgPyAxIDogX3JlZiRzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBfcmVmJG51bVRpY2tzID0gX3JlZi5udW1UaWNrcyxcbiAgICAgIG51bVRpY2tzID0gX3JlZiRudW1UaWNrcyA9PT0gdW5kZWZpbmVkID8gMTAgOiBfcmVmJG51bVRpY2tzLFxuICAgICAgbGluZVN0eWxlID0gX3JlZi5saW5lU3R5bGUsXG4gICAgICBvZmZzZXQgPSBfcmVmLm9mZnNldCxcbiAgICAgIHRpY2tWYWx1ZXMgPSBfcmVmLnRpY2tWYWx1ZXMsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3RvcCcsICdsZWZ0JywgJ3NjYWxlJywgJ2hlaWdodCcsICdzdHJva2UnLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ2NsYXNzTmFtZScsICdudW1UaWNrcycsICdsaW5lU3R5bGUnLCAnb2Zmc2V0JywgJ3RpY2tWYWx1ZXMnXSk7XG5cbiAgdmFyIHRpY2tzID0gc2NhbGUudGlja3MgPyBzY2FsZS50aWNrcyhudW1UaWNrcykgOiBzY2FsZS5kb21haW4oKTtcbiAgaWYgKHRpY2tWYWx1ZXMpIHRpY2tzID0gdGlja1ZhbHVlcztcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1jb2x1bW5zJywgY2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICB0aWNrcy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHZhciB4ID0gb2Zmc2V0ID8gc2NhbGUoZCkgKyBvZmZzZXQgOiBzY2FsZShkKTtcbiAgICAgIHZhciBmcm9tUG9pbnQgPSBuZXcgUG9pbnQoe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiAwXG4gICAgICB9KTtcbiAgICAgIHZhciB0b1BvaW50ID0gbmV3IFBvaW50KHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogaGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmUsIF9leHRlbmRzKHtcbiAgICAgICAga2V5OiAnY29sdW1uLWxpbmUtJyArIGQgKyAnLScgKyBpLFxuICAgICAgICBmcm9tOiBmcm9tUG9pbnQsXG4gICAgICAgIHRvOiB0b1BvaW50LFxuICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICAgICAgc3R5bGU6IGxpbmVTdHlsZVxuICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgfSlcbiAgKTtcbn1cblxuR3JpZC5wcm9wVHlwZXMgPSB7XG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbnVtVGlja3NSb3dzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBudW1UaWNrc0NvbHVtbnM6IFByb3BUeXBlcy5udW1iZXIsXG4gIHJvd0xpbmVTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgY29sdW1uTGluZVN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICB4T2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLFxuICB5T2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHlTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHJvd1RpY2tWYWx1ZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgY29sdW1uVGlja1ZhbHVlczogUHJvcFR5cGVzLmFycmF5XG59O1xuXG5mdW5jdGlvbiBHcmlkKF9yZWYpIHtcbiAgdmFyIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHhTY2FsZSA9IF9yZWYueFNjYWxlLFxuICAgICAgeVNjYWxlID0gX3JlZi55U2NhbGUsXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIG51bVRpY2tzUm93cyA9IF9yZWYubnVtVGlja3NSb3dzLFxuICAgICAgbnVtVGlja3NDb2x1bW5zID0gX3JlZi5udW1UaWNrc0NvbHVtbnMsXG4gICAgICByb3dMaW5lU3R5bGUgPSBfcmVmLnJvd0xpbmVTdHlsZSxcbiAgICAgIGNvbHVtbkxpbmVTdHlsZSA9IF9yZWYuY29sdW1uTGluZVN0eWxlLFxuICAgICAgeE9mZnNldCA9IF9yZWYueE9mZnNldCxcbiAgICAgIHlPZmZzZXQgPSBfcmVmLnlPZmZzZXQsXG4gICAgICByb3dUaWNrVmFsdWVzID0gX3JlZi5yb3dUaWNrVmFsdWVzLFxuICAgICAgY29sdW1uVGlja1ZhbHVlcyA9IF9yZWYuY29sdW1uVGlja1ZhbHVlcyxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsndG9wJywgJ2xlZnQnLCAneFNjYWxlJywgJ3lTY2FsZScsICd3aWR0aCcsICdoZWlnaHQnLCAnY2xhc3NOYW1lJywgJ3N0cm9rZScsICdzdHJva2VXaWR0aCcsICdzdHJva2VEYXNoYXJyYXknLCAnbnVtVGlja3NSb3dzJywgJ251bVRpY2tzQ29sdW1ucycsICdyb3dMaW5lU3R5bGUnLCAnY29sdW1uTGluZVN0eWxlJywgJ3hPZmZzZXQnLCAneU9mZnNldCcsICdyb3dUaWNrVmFsdWVzJywgJ2NvbHVtblRpY2tWYWx1ZXMnXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1ncmlkJywgY2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvd3MsIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgc2NhbGU6IHlTY2FsZSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgICBudW1UaWNrczogbnVtVGlja3NSb3dzLFxuICAgICAgc3R5bGU6IHJvd0xpbmVTdHlsZSxcbiAgICAgIG9mZnNldDogeU9mZnNldCxcbiAgICAgIHRpY2tWYWx1ZXM6IHJvd1RpY2tWYWx1ZXNcbiAgICB9LCByZXN0UHJvcHMpKSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENvbHVtbnMsIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgc2NhbGU6IHhTY2FsZSxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICAgIG51bVRpY2tzOiBudW1UaWNrc0NvbHVtbnMsXG4gICAgICBzdHlsZTogY29sdW1uTGluZVN0eWxlLFxuICAgICAgb2Zmc2V0OiB4T2Zmc2V0LFxuICAgICAgdGlja1ZhbHVlczogY29sdW1uVGlja1ZhbHVlc1xuICAgIH0sIHJlc3RQcm9wcykpXG4gICk7XG59XG5cbmV4cG9ydCB7IFJvd3MgYXMgR3JpZFJvd3MsIENvbHVtbnMgYXMgR3JpZENvbHVtbnMsIEdyaWQgfTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBhcmMsIHBpZSwgbGluZSwgcmFkaWFsTGluZSwgYXJlYSwgc3RhY2ssIHN0YWNrT3JkZXJBc2NlbmRpbmcsIHN0YWNrT3JkZXJEZXNjZW5kaW5nLCBzdGFja09yZGVySW5zaWRlT3V0LCBzdGFja09yZGVyTm9uZSwgc3RhY2tPcmRlclJldmVyc2UsIHN0YWNrT2Zmc2V0RXhwYW5kLCBzdGFja09mZnNldERpdmVyZ2luZywgc3RhY2tPZmZzZXROb25lLCBzdGFja09mZnNldFNpbGhvdWV0dGUsIHN0YWNrT2Zmc2V0V2lnZ2xlLCBsaW5rSG9yaXpvbnRhbCwgbGlua1ZlcnRpY2FsLCBsaW5rUmFkaWFsIH0gZnJvbSAnZDMtc2hhcGUnO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICdAdngvZ3JvdXAnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnQHZ4L3BvaW50JztcbmltcG9ydCB7IGN1cnZlTGluZWFyIH0gZnJvbSAnQHZ4L2N1cnZlJztcbmltcG9ydCB7IHBhdGggfSBmcm9tICdkMy1wYXRoJztcblxuZnVuY3Rpb24gY2FsbE9yVmFsdWUobWF5YmVGbiwgZGF0YSkge1xuICBpZiAodHlwZW9mIG1heWJlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVGbihkYXRhKTtcbiAgfVxuICByZXR1cm4gbWF5YmVGbjtcbn1cblxuZnVuY3Rpb24gYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMocmVzdFByb3BzKS5yZWR1Y2UoZnVuY3Rpb24gKHJldCwgY3VyKSB7XG4gICAgcmV0W2N1cl0gPSBjYWxsT3JWYWx1ZShyZXN0UHJvcHNbY3VyXSwgZGF0YSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSwge30pO1xufVxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5mdW5jdGlvbiBBcmMoX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2VudHJvaWQgPSBfcmVmLmNlbnRyb2lkLFxuICAgICAgaW5uZXJSYWRpdXMgPSBfcmVmLmlubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXMgPSBfcmVmLm91dGVyUmFkaXVzLFxuICAgICAgY29ybmVyUmFkaXVzID0gX3JlZi5jb3JuZXJSYWRpdXMsXG4gICAgICBzdGFydEFuZ2xlID0gX3JlZi5zdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUgPSBfcmVmLmVuZEFuZ2xlLFxuICAgICAgcGFkQW5nbGUgPSBfcmVmLnBhZEFuZ2xlLFxuICAgICAgcGFkUmFkaXVzID0gX3JlZi5wYWRSYWRpdXMsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICdkYXRhJywgJ2NlbnRyb2lkJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ2Nvcm5lclJhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ3BhZEFuZ2xlJywgJ3BhZFJhZGl1cyddKTtcblxuICB2YXIgYXJjJCQxID0gYXJjKCk7XG4gIGlmIChjZW50cm9pZCkgYXJjJCQxLmNlbnRyb2lkKGNlbnRyb2lkKTtcbiAgaWYgKGlubmVyUmFkaXVzKSBhcmMkJDEuaW5uZXJSYWRpdXMoaW5uZXJSYWRpdXMpO1xuICBpZiAob3V0ZXJSYWRpdXMpIGFyYyQkMS5vdXRlclJhZGl1cyhvdXRlclJhZGl1cyk7XG4gIGlmIChjb3JuZXJSYWRpdXMpIGFyYyQkMS5jb3JuZXJSYWRpdXMoY29ybmVyUmFkaXVzKTtcbiAgaWYgKHN0YXJ0QW5nbGUpIGFyYyQkMS5zdGFydEFuZ2xlKHN0YXJ0QW5nbGUpO1xuICBpZiAoZW5kQW5nbGUpIGFyYyQkMS5lbmRBbmdsZShlbmRBbmdsZSk7XG4gIGlmIChwYWRBbmdsZSkgYXJjJCQxLnBhZEFuZ2xlKHBhZEFuZ2xlKTtcbiAgaWYgKHBhZFJhZGl1cykgYXJjJCQxLnBhZFJhZGl1cyhwYWRSYWRpdXMpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHsgY2xhc3NOYW1lOiBjeCgndngtYXJjJywgY2xhc3NOYW1lKSwgZDogYXJjJCQxKGRhdGEpIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIFBpZShfcmVmKSB7XG4gIHZhciBfcmVmJGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZiRjbGFzc05hbWUgPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRjbGFzc05hbWUsXG4gICAgICBfcmVmJHRvcCA9IF9yZWYudG9wLFxuICAgICAgdG9wID0gX3JlZiR0b3AgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHRvcCxcbiAgICAgIF9yZWYkbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIGxlZnQgPSBfcmVmJGxlZnQgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJGxlZnQsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2VudHJvaWQgPSBfcmVmLmNlbnRyb2lkLFxuICAgICAgX3JlZiRpbm5lclJhZGl1cyA9IF9yZWYuaW5uZXJSYWRpdXMsXG4gICAgICBpbm5lclJhZGl1cyA9IF9yZWYkaW5uZXJSYWRpdXMgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJGlubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXMgPSBfcmVmLm91dGVyUmFkaXVzLFxuICAgICAgY29ybmVyUmFkaXVzID0gX3JlZi5jb3JuZXJSYWRpdXMsXG4gICAgICBfcmVmJHN0YXJ0QW5nbGUgPSBfcmVmLnN0YXJ0QW5nbGUsXG4gICAgICBzdGFydEFuZ2xlID0gX3JlZiRzdGFydEFuZ2xlID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRzdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUgPSBfcmVmLmVuZEFuZ2xlLFxuICAgICAgcGFkQW5nbGUgPSBfcmVmLnBhZEFuZ2xlLFxuICAgICAgcGFkUmFkaXVzID0gX3JlZi5wYWRSYWRpdXMsXG4gICAgICBwaWVTb3J0ID0gX3JlZi5waWVTb3J0LFxuICAgICAgcGllU29ydFZhbHVlcyA9IF9yZWYucGllU29ydFZhbHVlcyxcbiAgICAgIHBpZVZhbHVlID0gX3JlZi5waWVWYWx1ZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ2RhdGEnLCAnY2VudHJvaWQnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnY29ybmVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAncGFkQW5nbGUnLCAncGFkUmFkaXVzJywgJ3BpZVNvcnQnLCAncGllU29ydFZhbHVlcycsICdwaWVWYWx1ZScsICdjaGlsZHJlbiddKTtcblxuICB2YXIgcGF0aCQkMSA9IGFyYygpO1xuICBwYXRoJCQxLmlubmVyUmFkaXVzKGlubmVyUmFkaXVzKTtcbiAgaWYgKG91dGVyUmFkaXVzKSBwYXRoJCQxLm91dGVyUmFkaXVzKG91dGVyUmFkaXVzKTtcbiAgaWYgKGNvcm5lclJhZGl1cykgcGF0aCQkMS5jb3JuZXJSYWRpdXMoY29ybmVyUmFkaXVzKTtcbiAgaWYgKHBhZFJhZGl1cykgcGF0aCQkMS5wYWRSYWRpdXMocGFkUmFkaXVzKTtcbiAgdmFyIHBpZSQkMSA9IHBpZSgpO1xuICBpZiAocGllU29ydCkgcGllJCQxLnNvcnQocGllU29ydCk7XG4gIGlmIChwaWVTb3J0VmFsdWVzKSBwaWUkJDEuc29ydFZhbHVlcyhwaWVTb3J0VmFsdWVzKTtcbiAgaWYgKHBpZVZhbHVlKSBwaWUkJDEudmFsdWUocGllVmFsdWUpO1xuICBpZiAocGFkQW5nbGUgIT0gbnVsbCkgcGllJCQxLnBhZEFuZ2xlKHBhZEFuZ2xlKTtcbiAgaWYgKHN0YXJ0QW5nbGUgIT0gbnVsbCkgcGllJCQxLnN0YXJ0QW5nbGUoc3RhcnRBbmdsZSk7XG4gIGlmIChlbmRBbmdsZSAhPSBudWxsKSBwaWUkJDEuZW5kQW5nbGUoZW5kQW5nbGUpO1xuICB2YXIgYXJjcyA9IHBpZSQkMShkYXRhKTtcbiAgdmFyIHJlbmRlckZ1bmN0aW9uQXJnID0ge1xuICAgIGFyY3M6IGFyY3MsXG4gICAgZ2VuZXJhdGVQYXRoUHJvcHM6IGZ1bmN0aW9uIGdlbmVyYXRlUGF0aFByb3BzKGFyYyQkMSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LXBpZS1hcmMnLCBjbGFzc05hbWUpLFxuICAgICAgICBkOiBwYXRoJCQxKGFyYyQkMSlcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIF9leHRlbmRzKHt9LCBhcmMkJDEsIHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjZW50cm9pZDogY2VudHJvaWQgPyBwYXRoJCQxLmNlbnRyb2lkKGFyYyQkMSkgOiB1bmRlZmluZWRcbiAgICAgIH0pKSk7XG4gICAgfSxcbiAgICBnZW5lcmF0ZUNlbnRyb2lkOiBmdW5jdGlvbiBnZW5lcmF0ZUNlbnRyb2lkKGFyYyQkMSkge1xuICAgICAgcmV0dXJuIGNlbnRyb2lkICYmIGNlbnRyb2lkKHBhdGgkJDEuY2VudHJvaWQoYXJjJCQxKSwgYXJjJCQxKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiAndngtcGllLWFyY3MtZ3JvdXAnLCB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIGNoaWxkcmVuID8gY2hpbGRyZW4ocmVuZGVyRnVuY3Rpb25BcmcpIDogYXJjcy5tYXAoZnVuY3Rpb24gKGFyYyQkMSwgaSkge1xuICAgICAgdmFyIHBhdGhQcm9wcyA9IHJlbmRlckZ1bmN0aW9uQXJnLmdlbmVyYXRlUGF0aFByb3BzKGFyYyQkMSwgaSk7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2cnLFxuICAgICAgICB7IGtleTogJ3BpZS1hcmMtJyArIGkgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIHBhdGhQcm9wcyksXG4gICAgICAgIHJlbmRlckZ1bmN0aW9uQXJnLmdlbmVyYXRlQ2VudHJvaWQoYXJjJCQxKVxuICAgICAgKTtcbiAgICB9KVxuICApO1xufVxuXG5MaW5lLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5lKF9yZWYpIHtcbiAgdmFyIF9yZWYkZnJvbSA9IF9yZWYuZnJvbSxcbiAgICAgIGZyb20gPSBfcmVmJGZyb20gPT09IHVuZGVmaW5lZCA/IG5ldyBQb2ludCh7IHg6IDAsIHk6IDAgfSkgOiBfcmVmJGZyb20sXG4gICAgICBfcmVmJHRvID0gX3JlZi50byxcbiAgICAgIHRvID0gX3JlZiR0byA9PT0gdW5kZWZpbmVkID8gbmV3IFBvaW50KHsgeDogMSwgeTogMSB9KSA6IF9yZWYkdG8sXG4gICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHVuZGVmaW5lZCA/ICdibGFjaycgOiBfcmVmJHN0cm9rZSxcbiAgICAgIF9yZWYkc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmJHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQgPyAxIDogX3JlZiRzdHJva2VXaWR0aCxcbiAgICAgIF9yZWYkc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmJHN0cm9rZURhc2hhcnJheSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJHN0cm9rZURhc2hhcnJheSxcbiAgICAgIF9yZWYkdHJhbnNmb3JtID0gX3JlZi50cmFuc2Zvcm0sXG4gICAgICB0cmFuc2Zvcm0gPSBfcmVmJHRyYW5zZm9ybSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJHRyYW5zZm9ybSxcbiAgICAgIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGNsYXNzTmFtZSxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2Zyb20nLCAndG8nLCAnc3Ryb2tlJywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZURhc2hhcnJheScsICd0cmFuc2Zvcm0nLCAnY2xhc3NOYW1lJywgJ2RhdGEnLCAnaW5uZXJSZWYnXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2xpbmUnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5lJywgY2xhc3NOYW1lKSxcbiAgICB4MTogZnJvbS54LFxuICAgIHkxOiBmcm9tLnksXG4gICAgeDI6IHRvLngsXG4gICAgeTI6IHRvLnksXG4gICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbkxpbmVQYXRoLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLFxuICB5U2NhbGU6IFByb3BUeXBlcy5mdW5jLFxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXksXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgZGVmaW5lZDogUHJvcFR5cGVzLmZ1bmMsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGdseXBoOiBQcm9wVHlwZXMuZnVuYyxcbiAgY3VydmU6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5lUGF0aChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB5U2NhbGUgPSBfcmVmLnlTY2FsZSxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgX3JlZiRkZWZpbmVkID0gX3JlZi5kZWZpbmVkLFxuICAgICAgZGVmaW5lZCA9IF9yZWYkZGVmaW5lZCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IDogX3JlZiRkZWZpbmVkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHVuZGVmaW5lZCA/ICdzdGVlbGJsdWUnIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZiRzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gMiA6IF9yZWYkc3Ryb2tlV2lkdGgsXG4gICAgICBfcmVmJHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZiRzdHJva2VEYXNoYXJyYXkgPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRzdHJva2VEYXNoYXJyYXksXG4gICAgICBfcmVmJHN0cm9rZURhc2hvZmZzZXQgPSBfcmVmLnN0cm9rZURhc2hvZmZzZXQsXG4gICAgICBzdHJva2VEYXNob2Zmc2V0ID0gX3JlZiRzdHJva2VEYXNob2Zmc2V0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRzdHJva2VEYXNob2Zmc2V0LFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdW5kZWZpbmVkID8gJ25vbmUnIDogX3JlZiRmaWxsLFxuICAgICAgX3JlZiRjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICBjdXJ2ZSA9IF9yZWYkY3VydmUgPT09IHVuZGVmaW5lZCA/IGN1cnZlTGluZWFyIDogX3JlZiRjdXJ2ZSxcbiAgICAgIGdseXBoID0gX3JlZi5nbHlwaCxcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAnZGF0YScsICd4U2NhbGUnLCAneVNjYWxlJywgJ3gnLCAneScsICdkZWZpbmVkJywgJ2NsYXNzTmFtZScsICdzdHJva2UnLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZURhc2hvZmZzZXQnLCAnZmlsbCcsICdjdXJ2ZScsICdnbHlwaCcsICdpbm5lclJlZiddKTtcblxuICB2YXIgcGF0aCQkMSA9IGxpbmUoKS54KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geFNjYWxlKHguYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSkueShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHlTY2FsZSh5LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pLmRlZmluZWQoZGVmaW5lZCkuY3VydmUoY3VydmUpO1xuICBpZiAoY2hpbGRyZW4pIHJldHVybiBjaGlsZHJlbih7IHBhdGg6IHBhdGgkJDEgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICdnJyxcbiAgICBudWxsLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgY2xhc3NOYW1lOiBjeCgndngtbGluZXBhdGgnLCBjbGFzc05hbWUpLFxuICAgICAgZDogcGF0aCQkMShkYXRhKSxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VEYXNob2Zmc2V0OiBzdHJva2VEYXNob2Zmc2V0LFxuICAgICAgZmlsbDogZmlsbFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSksXG4gICAgZ2x5cGggJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdnJyxcbiAgICAgIHsgY2xhc3NOYW1lOiAndngtbGluZXBhdGgtZ2x5cGhzJyB9LFxuICAgICAgZGF0YS5tYXAoZ2x5cGgpXG4gICAgKVxuICApO1xufVxuXG5MaW5lUmFkaWFsLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5lUmFkaWFsKF9yZWYpIHtcbiAgdmFyIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGNsYXNzTmFtZSxcbiAgICAgIGFuZ2xlID0gX3JlZi5hbmdsZSxcbiAgICAgIHJhZGl1cyA9IF9yZWYucmFkaXVzLFxuICAgICAgZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICdhbmdsZScsICdyYWRpdXMnLCAnZGVmaW5lZCcsICdjdXJ2ZScsICdkYXRhJywgJ2lubmVyUmVmJ10pO1xuXG4gIHZhciBwYXRoJCQxID0gcmFkaWFsTGluZSgpO1xuICBpZiAoYW5nbGUpIHBhdGgkJDEuYW5nbGUoYW5nbGUpO1xuICBpZiAocmFkaXVzKSBwYXRoJCQxLnJhZGl1cyhyYWRpdXMpO1xuICBpZiAoZGVmaW5lZCkgcGF0aCQkMS5kZWZpbmVkKGRlZmluZWQpO1xuICBpZiAoY3VydmUpIHBhdGgkJDEuY3VydmUoY3VydmUpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgbnVsbCxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgcmVmOiBpbm5lclJlZixcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmUtcmFkaWFsJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpXG4gICk7XG59XG5cbkFyZWEucHJvcFR5cGVzID0ge1xuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeDA6IFByb3BUeXBlcy5mdW5jLFxuICB4MTogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICB5MDogUHJvcFR5cGVzLmZ1bmMsXG4gIHkxOiBQcm9wVHlwZXMuZnVuYyxcbiAgeFNjYWxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgeVNjYWxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LFxuICBkZWZpbmVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmFycmF5XSksXG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgc3Ryb2tlRGFzaGFycmF5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgc3Ryb2tlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmaWxsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjdXJ2ZTogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEFyZWEoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHgwID0gX3JlZi54MCxcbiAgICAgIHgxID0gX3JlZi54MSxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB5MSA9IF9yZWYueTEsXG4gICAgICB4U2NhbGUgPSBfcmVmLnhTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgX3JlZiRkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgZGF0YSA9IF9yZWYkZGF0YSA9PT0gdW5kZWZpbmVkID8gW10gOiBfcmVmJGRhdGEsXG4gICAgICBfcmVmJGRlZmluZWQgPSBfcmVmLmRlZmluZWQsXG4gICAgICBkZWZpbmVkID0gX3JlZiRkZWZpbmVkID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gOiBfcmVmJGRlZmluZWQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgX3JlZiRzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYkc3Ryb2tlV2lkdGggPT09IHVuZGVmaW5lZCA/IDIgOiBfcmVmJHN0cm9rZVdpZHRoLFxuICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB1bmRlZmluZWQgPyAnYmxhY2snIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICBmaWxsID0gX3JlZiRmaWxsID09PSB1bmRlZmluZWQgPyAncmdiYSgwLDAsMCwwLjMpJyA6IF9yZWYkZmlsbCxcbiAgICAgIGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAneCcsICd4MCcsICd4MScsICd5JywgJ3kwJywgJ3kxJywgJ3hTY2FsZScsICd5U2NhbGUnLCAnZGF0YScsICdkZWZpbmVkJywgJ2NsYXNzTmFtZScsICdzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlJywgJ2ZpbGwnLCAnY3VydmUnLCAnaW5uZXJSZWYnXSk7XG5cbiAgdmFyIHBhdGgkJDEgPSBhcmVhKCk7XG4gIGlmICh4KSBwYXRoJCQxLngoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KTtcbiAgaWYgKHgwKSBwYXRoJCQxLngwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geFNjYWxlKHgwLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pO1xuICBpZiAoeDEpIHBhdGgkJDEueDEoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeDEuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSk7XG4gIGlmICh5KSBwYXRoJCQxLnkoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KTtcbiAgaWYgKHkwKSBwYXRoJCQxLnkwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geVNjYWxlKHkwLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pO1xuICBpZiAoeTEpIHBhdGgkJDEueTEoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeTEuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSk7XG4gIGlmIChkZWZpbmVkKSBwYXRoJCQxLmRlZmluZWQoZGVmaW5lZCk7XG4gIGlmIChjdXJ2ZSkgcGF0aCQkMS5jdXJ2ZShjdXJ2ZSk7XG4gIGlmIChjaGlsZHJlbikgcmV0dXJuIGNoaWxkcmVuKHsgcGF0aDogcGF0aCQkMSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIG51bGwsXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICAgIHJlZjogaW5uZXJSZWYsXG4gICAgICBjbGFzc05hbWU6IGN4KCd2eC1hcmVhJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgkJDEoZGF0YSksXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgZmlsbDogZmlsbFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSlcbiAgKTtcbn1cblxuQXJlYUNsb3NlZC5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gQXJlYUNsb3NlZChfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHkwID0gX3JlZi55MCxcbiAgICAgIHhTY2FsZSA9IF9yZWYueFNjYWxlLFxuICAgICAgeVNjYWxlID0gX3JlZi55U2NhbGUsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgX3JlZiRkZWZpbmVkID0gX3JlZi5kZWZpbmVkLFxuICAgICAgZGVmaW5lZCA9IF9yZWYkZGVmaW5lZCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IDogX3JlZiRkZWZpbmVkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIF9yZWYkc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmJHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQgPyAyIDogX3JlZiRzdHJva2VXaWR0aCxcbiAgICAgIF9yZWYkc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2UgPSBfcmVmJHN0cm9rZSA9PT0gdW5kZWZpbmVkID8gJ2JsYWNrJyA6IF9yZWYkc3Ryb2tlLFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdW5kZWZpbmVkID8gJ3JnYmEoMCwwLDAsMC4zKScgOiBfcmVmJGZpbGwsXG4gICAgICBjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3gnLCAneScsICd5MCcsICd4U2NhbGUnLCAneVNjYWxlJywgJ2RhdGEnLCAnZGVmaW5lZCcsICdjbGFzc05hbWUnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZScsICdmaWxsJywgJ2N1cnZlJywgJ2lubmVyUmVmJ10pO1xuXG4gIHZhciBwYXRoJCQxID0gYXJlYSgpLngoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KS55MCh5MCB8fCB5U2NhbGUucmFuZ2UoKVswXSkueTEoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KS5kZWZpbmVkKGRlZmluZWQpO1xuICBpZiAoY3VydmUpIHBhdGgkJDEuY3VydmUoY3VydmUpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgbnVsbCxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgcmVmOiBpbm5lclJlZixcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWFyZWEtY2xvc2VkJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgkJDEoZGF0YSksXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgZmlsbDogZmlsbFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gQXJlYVN0YWNrKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIF9yZWYkbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB4MCA9IF9yZWYueDAsXG4gICAgICB4MSA9IF9yZWYueDEsXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB5MSA9IF9yZWYueTEsXG4gICAgICBnbHlwaCA9IF9yZWYuZ2x5cGgsXG4gICAgICBfcmVmJHJldmVyc2UgPSBfcmVmLnJldmVyc2UsXG4gICAgICByZXZlcnNlID0gX3JlZiRyZXZlcnNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkcmV2ZXJzZSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ2tleXMnLCAnZGF0YScsICdjdXJ2ZScsICdkZWZpbmVkJywgJ3gnLCAneDAnLCAneDEnLCAneTAnLCAneTEnLCAnZ2x5cGgnLCAncmV2ZXJzZSddKTtcblxuICB2YXIgc3RhY2skJDEgPSBzdGFjaygpO1xuICBpZiAoa2V5cykgc3RhY2skJDEua2V5cyhrZXlzKTtcblxuICB2YXIgcGF0aCQkMSA9IGFyZWEoKTtcbiAgaWYgKHgpIHBhdGgkJDEueCh4KTtcbiAgaWYgKHgwKSBwYXRoJCQxLngwKHgwKTtcbiAgaWYgKHgxKSBwYXRoJCQxLngxKHgxKTtcbiAgaWYgKHkwKSBwYXRoJCQxLnkwKHkwKTtcbiAgaWYgKHkxKSBwYXRoJCQxLnkxKHkxKTtcbiAgaWYgKGN1cnZlKSBwYXRoJCQxLmN1cnZlKGN1cnZlKTtcbiAgaWYgKGRlZmluZWQpIHBhdGgkJDEuZGVmaW5lZChkZWZpbmVkKTtcblxuICB2YXIgc2VyaWVzRGF0YSA9IHN0YWNrJCQxKGRhdGEpO1xuICBpZiAocmV2ZXJzZSkgc2VyaWVzRGF0YS5yZXZlcnNlKCk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIG51bGwsXG4gICAgc2VyaWVzRGF0YS5tYXAoZnVuY3Rpb24gKHNlcmllcywgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWFyZWEtc3RhY2snLCBjbGFzc05hbWUpLFxuICAgICAgICBrZXk6ICdhcmVhLXN0YWNrLScgKyBpICsgJy0nICsgKHNlcmllcy5rZXkgfHwgJycpLFxuICAgICAgICBkOiBwYXRoJCQxKHNlcmllcylcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIHtcbiAgICAgICAgZGF0dW06IHNlcmllc1tpXSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICB9KSkpO1xuICAgIH0pLFxuICAgICEhZ2x5cGggJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdnJyxcbiAgICAgIHsgY2xhc3NOYW1lOiAndngtYXJlYS1zdGFjay1nbHlwaHMnIH0sXG4gICAgICBkYXRhLm1hcChnbHlwaClcbiAgICApXG4gICk7XG59XG5cbkJhci5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gQmFyKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIF9yZWYkeCA9IF9yZWYueCxcbiAgICAgIHggPSBfcmVmJHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHgsXG4gICAgICBfcmVmJHkgPSBfcmVmLnksXG4gICAgICB5ID0gX3JlZiR5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR5LFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICByeCA9IF9yZWYucngsXG4gICAgICByeSA9IF9yZWYucnksXG4gICAgICBfcmVmJGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICBmaWxsID0gX3JlZiRmaWxsID09PSB1bmRlZmluZWQgPyAnc3RlZWxibHVlJyA6IF9yZWYkZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5ID0gX3JlZi5maWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VMaW5lY2FwID0gX3JlZi5zdHJva2VMaW5lY2FwLFxuICAgICAgc3Ryb2tlTGluZWpvaW4gPSBfcmVmLnN0cm9rZUxpbmVqb2luLFxuICAgICAgc3Ryb2tlTWl0ZXJsaW1pdCA9IF9yZWYuc3Ryb2tlTWl0ZXJsaW1pdCxcbiAgICAgIHN0cm9rZU9wYWNpdHkgPSBfcmVmLnN0cm9rZU9wYWNpdHksXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAncngnLCAncnknLCAnZmlsbCcsICdmaWxsT3BhY2l0eScsICdzdHJva2UnLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZUxpbmVjYXAnLCAnc3Ryb2tlTGluZWpvaW4nLCAnc3Ryb2tlTWl0ZXJsaW1pdCcsICdzdHJva2VPcGFjaXR5J10pO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdyZWN0JywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtYmFyJywgY2xhc3NOYW1lKSxcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHJ4OiByeCxcbiAgICByeTogcnksXG4gICAgZmlsbDogZmlsbCxcbiAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHksXG4gICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgIHN0cm9rZUxpbmVjYXA6IHN0cm9rZUxpbmVjYXAsXG4gICAgc3Ryb2tlTGluZWpvaW46IHN0cm9rZUxpbmVqb2luLFxuICAgIHN0cm9rZU1pdGVybGltaXQ6IHN0cm9rZU1pdGVybGltaXQsXG4gICAgc3Ryb2tlT3BhY2l0eTogc3Ryb2tlT3BhY2l0eVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBCYXJHcm91cChfcmVmKSB7XG4gIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICB4MCA9IF9yZWYueDAsXG4gICAgICB4MFNjYWxlID0gX3JlZi54MFNjYWxlLFxuICAgICAgeDFTY2FsZSA9IF9yZWYueDFTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgelNjYWxlID0gX3JlZi56U2NhbGUsXG4gICAgICBrZXlzID0gX3JlZi5rZXlzLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2RhdGEnLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3gwJywgJ3gwU2NhbGUnLCAneDFTY2FsZScsICd5U2NhbGUnLCAnelNjYWxlJywgJ2tleXMnLCAnaGVpZ2h0J10pO1xuXG4gIHZhciBmb3JtYXQgPSB4MFNjYWxlLnRpY2tGb3JtYXQgPyB4MFNjYWxlLnRpY2tGb3JtYXQoKSA6IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiBjeCgndngtYmFyLWdyb3VwJywgY2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBkYXRhICYmIGRhdGEubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgR3JvdXAsXG4gICAgICAgIHsga2V5OiAnYmFyLWdyb3VwLScgKyBpICsgJy0nICsgeDAoZCksIGxlZnQ6IHgwU2NhbGUoeDAoZCkpIH0sXG4gICAgICAgIGtleXMgJiYga2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGRba2V5XTtcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChCYXIsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIGtleTogJ2Jhci1ncm91cC1iYXItJyArIGkgKyAnLScgKyB2YWx1ZSArICctJyArIGtleSxcbiAgICAgICAgICAgIHg6IHgxU2NhbGUoa2V5KSxcbiAgICAgICAgICAgIHk6IHlTY2FsZSh2YWx1ZSksXG4gICAgICAgICAgICB3aWR0aDogeDFTY2FsZS5iYW5kd2lkdGgoKSxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC0geVNjYWxlKHZhbHVlKSxcbiAgICAgICAgICAgIGZpbGw6IHpTY2FsZShrZXkpLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICB4OiBmb3JtYXQoeDAoZCkpLFxuICAgICAgICAgICAgICBkYXRhOiBkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbkJhckdyb3VwLnByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHgwOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4MFNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4MVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHpTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAga2V5czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlclxufTtcblxuZnVuY3Rpb24gQmFyR3JvdXBIb3Jpem9udGFsKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHkwID0gX3JlZi55MCxcbiAgICAgIHkwU2NhbGUgPSBfcmVmLnkwU2NhbGUsXG4gICAgICB5MVNjYWxlID0gX3JlZi55MVNjYWxlLFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB6U2NhbGUgPSBfcmVmLnpTY2FsZSxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2RhdGEnLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3kwJywgJ3kwU2NhbGUnLCAneTFTY2FsZScsICd4U2NhbGUnLCAnelNjYWxlJywgJ2tleXMnLCAnd2lkdGgnXSk7XG5cbiAgdmFyIGZvcm1hdCA9IHkwU2NhbGUudGlja0Zvcm1hdCA/IHkwU2NhbGUudGlja0Zvcm1hdCgpIDogZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1iYXItZ3JvdXAtaG9yaXpvbnRhbCcsIGNsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgZGF0YSAmJiBkYXRhLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ2Jhci1ncm91cC0nICsgaSArICctJyArIHkwKGQpLCB0b3A6IHkwU2NhbGUoeTAoZCkpIH0sXG4gICAgICAgIGtleXMgJiYga2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGRba2V5XTtcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChCYXIsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIGtleTogJ2Jhci1ncm91cC1iYXItJyArIGkgKyAnLScgKyB2YWx1ZSArICctJyArIGtleSxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiB5MVNjYWxlKGtleSksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGggLSB4U2NhbGUodmFsdWUpLFxuICAgICAgICAgICAgaGVpZ2h0OiB5MVNjYWxlLmJhbmR3aWR0aCgpLFxuICAgICAgICAgICAgZmlsbDogelNjYWxlKGtleSksXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHk6IGZvcm1hdCh5MChkKSksXG4gICAgICAgICAgICAgIGRhdGE6IGRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXN0UHJvcHMpKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSlcbiAgKTtcbn1cblxuQmFyR3JvdXBIb3Jpem9udGFsLnByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHkwOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5MFNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5MVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHpTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAga2V5czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyXG59O1xuXG5mdW5jdGlvbiBCYXJTdGFjayhfcmVmKSB7XG4gIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB5U2NhbGUgPSBfcmVmLnlTY2FsZSxcbiAgICAgIHpTY2FsZSA9IF9yZWYuelNjYWxlLFxuICAgICAga2V5cyA9IF9yZWYua2V5cyxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydkYXRhJywgJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICd4JywgJ3hTY2FsZScsICd5U2NhbGUnLCAnelNjYWxlJywgJ2tleXMnLCAnaGVpZ2h0J10pO1xuXG4gIHZhciBzZXJpZXMgPSBzdGFjaygpLmtleXMoa2V5cykoZGF0YSk7XG4gIHZhciBmb3JtYXQgPSB4U2NhbGUudGlja0Zvcm1hdCA/IHhTY2FsZS50aWNrRm9ybWF0KCkgOiBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkO1xuICB9O1xuICB2YXIgYmFuZHdpZHRoID0geFNjYWxlLmJhbmR3aWR0aCgpO1xuICB2YXIgc3RlcCA9IHhTY2FsZS5zdGVwKCk7XG4gIHZhciBwYWRkaW5nSW5uZXIgPSB4U2NhbGUucGFkZGluZ0lubmVyKCk7XG4gIHZhciBwYWRkaW5nT3V0ZXIgPSB4U2NhbGUucGFkZGluZ091dGVyKCk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiBjeCgndngtYmFyLXN0YWNrJywgY2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBzZXJpZXMgJiYgc2VyaWVzLm1hcChmdW5jdGlvbiAocywgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ3Z4LWJhci1zdGFjay0nICsgaSB9LFxuICAgICAgICBzLm1hcChmdW5jdGlvbiAoZCwgaWkpIHtcbiAgICAgICAgICB2YXIgYmFySGVpZ2h0ID0geVNjYWxlKGRbMF0pIC0geVNjYWxlKGRbMV0pO1xuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEJhciwgX2V4dGVuZHMoe1xuICAgICAgICAgICAga2V5OiAnYmFyLWdyb3VwLWJhci0nICsgaSArICctJyArIGlpICsgJy0nICsgcy5rZXksXG4gICAgICAgICAgICB4OiB4U2NhbGUoeChkLmRhdGEpKSxcbiAgICAgICAgICAgIHk6IHlTY2FsZShkWzFdKSxcbiAgICAgICAgICAgIHdpZHRoOiBiYW5kd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgIGZpbGw6IHpTY2FsZShzLmtleSksXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGJhbmR3aWR0aDogYmFuZHdpZHRoLFxuICAgICAgICAgICAgICBwYWRkaW5nSW5uZXI6IHBhZGRpbmdJbm5lcixcbiAgICAgICAgICAgICAgcGFkZGluZ091dGVyOiBwYWRkaW5nT3V0ZXIsXG4gICAgICAgICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgICAgIGtleTogcy5rZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBkWzFdLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IGJhbmR3aWR0aCxcbiAgICAgICAgICAgICAgeDogeChkLmRhdGEpLFxuICAgICAgICAgICAgICB4Rm9ybWF0dGVkOiBmb3JtYXQoeChkLmRhdGEpKSxcbiAgICAgICAgICAgICAgZGF0YTogZC5kYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbkJhclN0YWNrLnByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHg6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHhTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgeVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB6U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGtleXM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlclxufTtcblxuZnVuY3Rpb24gQmFyU3RhY2tIb3Jpem9udGFsKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB4U2NhbGUgPSBfcmVmLnhTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgelNjYWxlID0gX3JlZi56U2NhbGUsXG4gICAgICBrZXlzID0gX3JlZi5rZXlzLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2RhdGEnLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3knLCAneFNjYWxlJywgJ3lTY2FsZScsICd6U2NhbGUnLCAna2V5cycsICdoZWlnaHQnXSk7XG5cbiAgdmFyIHNlcmllcyA9IHN0YWNrKCkua2V5cyhrZXlzKShkYXRhKTtcbiAgdmFyIGZvcm1hdCA9IHlTY2FsZS50aWNrRm9ybWF0ID8geVNjYWxlLnRpY2tGb3JtYXQoKSA6IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG4gIHZhciBiYW5kd2lkdGggPSB5U2NhbGUuYmFuZHdpZHRoKCk7XG4gIHZhciBzdGVwID0geVNjYWxlLnN0ZXAoKTtcbiAgdmFyIHBhZGRpbmdJbm5lciA9IHlTY2FsZS5wYWRkaW5nSW5uZXIoKTtcbiAgdmFyIHBhZGRpbmdPdXRlciA9IHlTY2FsZS5wYWRkaW5nT3V0ZXIoKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1iYXItc3RhY2staG9yaXpvbnRhbCcsIGNsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgc2VyaWVzICYmIHNlcmllcy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBHcm91cCxcbiAgICAgICAgeyBrZXk6ICd2eC1iYXItc3RhY2staG9yaXpvbnRhbC0nICsgaSB9LFxuICAgICAgICBzLm1hcChmdW5jdGlvbiAoZCwgaWkpIHtcbiAgICAgICAgICB2YXIgYmFyV2lkdGggPSB4U2NhbGUoZFsxXSkgLSB4U2NhbGUoZFswXSk7XG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBrZXk6ICdiYXItZ3JvdXAtYmFyLScgKyBpICsgJy0nICsgaWkgKyAnLScgKyBzLmtleSxcbiAgICAgICAgICAgIHg6IHhTY2FsZShkWzBdKSxcbiAgICAgICAgICAgIHk6IHlTY2FsZSh5KGQuZGF0YSkpLFxuICAgICAgICAgICAgd2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBiYW5kd2lkdGgsXG4gICAgICAgICAgICBmaWxsOiB6U2NhbGUocy5rZXkpLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBiYW5kd2lkdGg6IGJhbmR3aWR0aCxcbiAgICAgICAgICAgICAgcGFkZGluZ0lubmVyOiBwYWRkaW5nSW5uZXIsXG4gICAgICAgICAgICAgIHBhZGRpbmdPdXRlcjogcGFkZGluZ091dGVyLFxuICAgICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgICBrZXk6IHMua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogZFswXSxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBiYW5kd2lkdGgsXG4gICAgICAgICAgICAgIHdpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgICAgeTogeShkLmRhdGEpLFxuICAgICAgICAgICAgICB5Rm9ybWF0dGVkOiBmb3JtYXQoeShkLmRhdGEpKSxcbiAgICAgICAgICAgICAgZGF0YTogZC5kYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbkJhclN0YWNrSG9yaXpvbnRhbC5wcm9wVHlwZXMgPSB7XG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICB5OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHlTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgelNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBrZXlzOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXJcbn07XG5cbnZhciBTVEFDS19PUkRFUlMgPSB7XG4gIGFzY2VuZGluZzogc3RhY2tPcmRlckFzY2VuZGluZyxcbiAgZGVzY2VuZGluZzogc3RhY2tPcmRlckRlc2NlbmRpbmcsXG4gIGluc2lkZW91dDogc3RhY2tPcmRlckluc2lkZU91dCxcbiAgbm9uZTogc3RhY2tPcmRlck5vbmUsXG4gIHJldmVyc2U6IHN0YWNrT3JkZXJSZXZlcnNlXG59O1xuXG52YXIgU1RBQ0tfT1JERVJfTkFNRVMgPSBPYmplY3Qua2V5cyhTVEFDS19PUkRFUlMpO1xuXG5mdW5jdGlvbiBzdGFja09yZGVyKG9yZGVyKSB7XG4gIHJldHVybiBTVEFDS19PUkRFUlNbb3JkZXJdIHx8IFNUQUNLX09SREVSUy5ub25lO1xufVxuXG52YXIgU1RBQ0tfT0ZGU0VUUyA9IHtcbiAgZXhwYW5kOiBzdGFja09mZnNldEV4cGFuZCxcbiAgZGl2ZXJnaW5nOiBzdGFja09mZnNldERpdmVyZ2luZyxcbiAgbm9uZTogc3RhY2tPZmZzZXROb25lLFxuICBzaWxob3VldHRlOiBzdGFja09mZnNldFNpbGhvdWV0dGUsXG4gIHdpZ2dsZTogc3RhY2tPZmZzZXRXaWdnbGVcbn07XG5cbnZhciBTVEFDS19PRkZTRVRfTkFNRVMgPSBPYmplY3Qua2V5cyhTVEFDS19PRkZTRVRTKTtcblxuZnVuY3Rpb24gc3RhY2tPZmZzZXQob2Zmc2V0KSB7XG4gIHJldHVybiBTVEFDS19PRkZTRVRTW29mZnNldF0gfHwgU1RBQ0tfT0ZGU0VUUy5ub25lO1xufVxuXG5mdW5jdGlvbiBTdGFjayhfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB4MCA9IF9yZWYueDAsXG4gICAgICB4MSA9IF9yZWYueDEsXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB5MSA9IF9yZWYueTEsXG4gICAgICB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICBvcmRlciA9IF9yZWYub3JkZXIsXG4gICAgICBvZmZzZXQgPSBfcmVmLm9mZnNldCxcbiAgICAgIHJlbmRlciA9IF9yZWYucmVuZGVyLFxuICAgICAgX3JlZiRyZXZlcnNlID0gX3JlZi5yZXZlcnNlLFxuICAgICAgcmV2ZXJzZSA9IF9yZWYkcmV2ZXJzZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHJldmVyc2UsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICdrZXlzJywgJ2RhdGEnLCAnY3VydmUnLCAnZGVmaW5lZCcsICd4JywgJ3gwJywgJ3gxJywgJ3kwJywgJ3kxJywgJ3ZhbHVlJywgJ29yZGVyJywgJ29mZnNldCcsICdyZW5kZXInLCAncmV2ZXJzZSddKTtcblxuICB2YXIgc3RhY2skJDEgPSBzdGFjaygpO1xuICBpZiAoa2V5cykgc3RhY2skJDEua2V5cyhrZXlzKTtcbiAgaWYgKHZhbHVlKSBzdGFjayQkMS52YWx1ZSh2YWx1ZSk7XG4gIGlmIChvcmRlcikgc3RhY2skJDEub3JkZXIoc3RhY2tPcmRlcihvcmRlcikpO1xuICBpZiAob2Zmc2V0KSBzdGFjayQkMS5vZmZzZXQoc3RhY2tPZmZzZXQob2Zmc2V0KSk7XG5cbiAgdmFyIHBhdGgkJDEgPSBhcmVhKCk7XG4gIGlmICh4KSBwYXRoJCQxLngoeCk7XG4gIGlmICh4MCkgcGF0aCQkMS54MCh4MCk7XG4gIGlmICh4MSkgcGF0aCQkMS54MSh4MSk7XG4gIGlmICh5MCkgcGF0aCQkMS55MCh5MCk7XG4gIGlmICh5MSkgcGF0aCQkMS55MSh5MSk7XG4gIGlmIChjdXJ2ZSkgcGF0aCQkMS5jdXJ2ZShjdXJ2ZSk7XG4gIGlmIChkZWZpbmVkKSBwYXRoJCQxLmRlZmluZWQoZGVmaW5lZCk7XG5cbiAgdmFyIHNlcmllc0RhdGEgPSBzdGFjayQkMShkYXRhKTtcbiAgaWYgKHJldmVyc2UpIHNlcmllc0RhdGEucmV2ZXJzZSgpO1xuXG4gIGlmIChyZW5kZXIpIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICByZW5kZXIoeyBzZXJpZXNEYXRhOiBzZXJpZXNEYXRhLCBwYXRoOiBwYXRoJCQxIH0pXG4gICk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIHNlcmllc0RhdGEubWFwKGZ1bmN0aW9uIChzZXJpZXMsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgICBjbGFzc05hbWU6IGN4KCd2eC1zdGFjaycsIGNsYXNzTmFtZSksXG4gICAgICAgIGtleTogJ3N0YWNrLScgKyBpICsgJy0nICsgKHNlcmllcy5rZXkgfHwgJycpLFxuICAgICAgICBkOiBwYXRoJCQxKHNlcmllcylcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIHtcbiAgICAgICAgZGF0dW06IHNlcmllc1tpXSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICB9KSkpO1xuICAgIH0pXG4gICk7XG59XG5cbmZ1bmN0aW9uIHBhdGhIb3Jpem9udGFsRGlhZ29uYWwoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsaW5rID0gbGlua0hvcml6b250YWwoKTtcbiAgICBsaW5rLngoeCk7XG4gICAgbGluay55KHkpO1xuICAgIGxpbmsuc291cmNlKHNvdXJjZSk7XG4gICAgbGluay50YXJnZXQodGFyZ2V0KTtcbiAgICByZXR1cm4gbGluayhkYXRhKTtcbiAgfTtcbn1cblxuTGlua0hvcml6b250YWwucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtIb3Jpem9udGFsKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhIb3Jpem9udGFsRGlhZ29uYWwoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluay1ob3Jpem9udGFsJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhWZXJ0aWNhbERpYWdvbmFsKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbGluayA9IGxpbmtWZXJ0aWNhbCgpO1xuICAgIGxpbmsueCh4KTtcbiAgICBsaW5rLnkoeSk7XG4gICAgbGluay5zb3VyY2Uoc291cmNlKTtcbiAgICBsaW5rLnRhcmdldCh0YXJnZXQpO1xuICAgIHJldHVybiBsaW5rKGRhdGEpO1xuICB9O1xufVxuXG5MaW5rVmVydGljYWwucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtWZXJ0aWNhbChfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoVmVydGljYWxEaWFnb25hbCh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rLXZlcnRpY2FsJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhSYWRpYWxEaWFnb25hbChfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgYW5nbGUgPSBfcmVmLmFuZ2xlLFxuICAgICAgcmFkaXVzID0gX3JlZi5yYWRpdXM7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGxpbmsgPSBsaW5rUmFkaWFsKCk7XG4gICAgbGluay5hbmdsZShhbmdsZSk7XG4gICAgbGluay5yYWRpdXMocmFkaXVzKTtcbiAgICBsaW5rLnNvdXJjZShzb3VyY2UpO1xuICAgIGxpbmsudGFyZ2V0KHRhcmdldCk7XG4gICAgcmV0dXJuIGxpbmsoZGF0YSk7XG4gIH07XG59XG5cbkxpbmtSYWRpYWwucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIGFuZ2xlOiBQcm9wVHlwZXMuZnVuYyxcbiAgcmFkaXVzOiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtSYWRpYWwoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkYW5nbGUgPSBfcmVmMi5hbmdsZSxcbiAgICAgIGFuZ2xlID0gX3JlZjIkYW5nbGUgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJGFuZ2xlLFxuICAgICAgX3JlZjIkcmFkaXVzID0gX3JlZjIucmFkaXVzLFxuICAgICAgcmFkaXVzID0gX3JlZjIkcmFkaXVzID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiRyYWRpdXMsXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAnYW5nbGUnLCAncmFkaXVzJywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFJhZGlhbERpYWdvbmFsKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCBhbmdsZTogYW5nbGUsIHJhZGl1czogcmFkaXVzIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmstcmFkaXVzJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhIb3Jpem9udGFsQ3VydmUoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgcGVyY2VudCA9IF9yZWYucGVyY2VudDtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgZHggPSB0eCAtIHN4O1xuICAgIHZhciBkeSA9IHR5IC0gc3k7XG4gICAgdmFyIGl4ID0gcGVyY2VudCAqIChkeCArIGR5KTtcbiAgICB2YXIgaXkgPSBwZXJjZW50ICogKGR5IC0gZHgpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3gsIHN5KTtcbiAgICBwYXRoJCQxLmJlemllckN1cnZlVG8oc3ggKyBpeCwgc3kgKyBpeSwgdHggKyBpeSwgdHkgLSBpeCwgdHgsIHR5KTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtIb3Jpem9udGFsQ3VydmUucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtIb3Jpem9udGFsQ3VydmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuMiA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0JywgJ3BlcmNlbnQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aEhvcml6b250YWxDdXJ2ZSh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSwgcGVyY2VudDogcGVyY2VudCB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhWZXJ0aWNhbEN1cnZlKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHBlcmNlbnQgPSBfcmVmLnBlcmNlbnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc3ggPSB4KHNvdXJjZURhdGEpO1xuICAgIHZhciBzeSA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHR4ID0geCh0YXJnZXREYXRhKTtcbiAgICB2YXIgdHkgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIGR4ID0gdHggLSBzeDtcbiAgICB2YXIgZHkgPSB0eSAtIHN5O1xuICAgIHZhciBpeCA9IHBlcmNlbnQgKiAoZHggKyBkeSk7XG4gICAgdmFyIGl5ID0gcGVyY2VudCAqIChkeSAtIGR4KTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHN4LCBzeSk7XG4gICAgcGF0aCQkMS5iZXppZXJDdXJ2ZVRvKHN4ICsgaXgsIHN5ICsgaXksIHR4ICsgaXksIHR5IC0gaXgsIHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rVmVydGljYWxDdXJ2ZS5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlcixcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua1ZlcnRpY2FsQ3VydmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuMiA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0JywgJ3BlcmNlbnQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFZlcnRpY2FsQ3VydmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHksIHBlcmNlbnQ6IHBlcmNlbnQgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoUmFkaWFsQ3VydmUoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgcGVyY2VudCA9IF9yZWYucGVyY2VudDtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzYSA9IHgoc291cmNlRGF0YSkgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgc3IgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0YSA9IHgodGFyZ2V0RGF0YSkgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgdHIgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIHNjID0gTWF0aC5jb3Moc2EpO1xuICAgIHZhciBzcyA9IE1hdGguc2luKHNhKTtcbiAgICB2YXIgdGMgPSBNYXRoLmNvcyh0YSk7XG4gICAgdmFyIHRzID0gTWF0aC5zaW4odGEpO1xuXG4gICAgdmFyIHN4ID0gc3IgKiBzYztcbiAgICB2YXIgc3kgPSBzciAqIHNzO1xuICAgIHZhciB0eCA9IHRyICogdGM7XG4gICAgdmFyIHR5ID0gdHIgKiB0cztcblxuICAgIHZhciBkeCA9IHR4IC0gc3g7XG4gICAgdmFyIGR5ID0gdHkgLSBzeTtcbiAgICB2YXIgaXggPSBwZXJjZW50ICogKGR4ICsgZHkpO1xuICAgIHZhciBpeSA9IHBlcmNlbnQgKiAoZHkgLSBkeCk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEuYmV6aWVyQ3VydmVUbyhzeCArIGl4LCBzeSArIGl5LCB0eCArIGl5LCB0eSAtIGl4LCB0eCwgdHkpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua1JhZGlhbEN1cnZlLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwZXJjZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rUmFkaWFsQ3VydmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuMiA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0JywgJ3BlcmNlbnQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFJhZGlhbEN1cnZlKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5LCBwZXJjZW50OiBwZXJjZW50IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aEhvcml6b250YWxMaW5lKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEubGluZVRvKHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rSG9yaXpvbnRhbExpbmUucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtIb3Jpem9udGFsTGluZShfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoSG9yaXpvbnRhbExpbmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoVmVydGljYWxMaW5lKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEubGluZVRvKHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rVmVydGljYWxMaW5lLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuYyxcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rVmVydGljYWxMaW5lKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhWZXJ0aWNhbExpbmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoUmFkaWFsTGluZShfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc2EgPSB4KHNvdXJjZURhdGEpIC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHNyID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdGEgPSB4KHRhcmdldERhdGEpIC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHRyID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBzYyA9IE1hdGguY29zKHNhKTtcbiAgICB2YXIgc3MgPSBNYXRoLnNpbihzYSk7XG4gICAgdmFyIHRjID0gTWF0aC5jb3ModGEpO1xuICAgIHZhciB0cyA9IE1hdGguc2luKHRhKTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHNyICogc2MsIHNyICogc3MpO1xuICAgIHBhdGgkJDEubGluZVRvKHRyICogdGMsIHRyICogdHMpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua1JhZGlhbFN0ZXAucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtSYWRpYWxTdGVwKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhSYWRpYWxMaW5lKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aEhvcml6b250YWxTdGVwKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHBlcmNlbnQgPSBfcmVmLnBlcmNlbnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc3ggPSB4KHNvdXJjZURhdGEpO1xuICAgIHZhciBzeSA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHR4ID0geCh0YXJnZXREYXRhKTtcbiAgICB2YXIgdHkgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3gsIHN5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyhzeCArICh0eCAtIHN4KSAqIHBlcmNlbnQsIHN5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyhzeCArICh0eCAtIHN4KSAqIHBlcmNlbnQsIHR5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyh0eCwgdHkpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua0hvcml6b250YWxTdGVwLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwZXJjZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rSG9yaXpvbnRhbFN0ZXAoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkcGVyY2VudCA9IF9yZWYyLnBlcmNlbnQsXG4gICAgICBwZXJjZW50ID0gX3JlZjIkcGVyY2VudCA9PT0gdW5kZWZpbmVkID8gMC41IDogX3JlZjIkcGVyY2VudCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3BlcmNlbnQnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aEhvcml6b250YWxTdGVwKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5LCBwZXJjZW50OiBwZXJjZW50IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aFZlcnRpY2FsU3RlcChfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICBwZXJjZW50ID0gX3JlZi5wZXJjZW50O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzb3VyY2VEYXRhID0gc291cmNlKGRhdGEpO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0KGRhdGEpO1xuXG4gICAgdmFyIHN4ID0geChzb3VyY2VEYXRhKTtcbiAgICB2YXIgc3kgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0eCA9IHgodGFyZ2V0RGF0YSk7XG4gICAgdmFyIHR5ID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHN4LCBzeSk7XG4gICAgcGF0aCQkMS5saW5lVG8oc3gsIHN5ICsgKHR5IC0gc3kpICogcGVyY2VudCk7XG4gICAgcGF0aCQkMS5saW5lVG8odHgsIHN5ICsgKHR5IC0gc3kpICogcGVyY2VudCk7XG4gICAgcGF0aCQkMS5saW5lVG8odHgsIHR5KTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtWZXJ0aWNhbFN0ZXAucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtWZXJ0aWNhbFN0ZXAoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkcGVyY2VudCA9IF9yZWYyLnBlcmNlbnQsXG4gICAgICBwZXJjZW50ID0gX3JlZjIkcGVyY2VudCA9PT0gdW5kZWZpbmVkID8gMC41IDogX3JlZjIkcGVyY2VudCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3BlcmNlbnQnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFZlcnRpY2FsU3RlcCh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSwgcGVyY2VudDogcGVyY2VudCB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhSYWRpYWxTdGVwKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgc2EgPSBzeCAtIE1hdGguUEkgLyAyO1xuICAgIHZhciBzciA9IHN5O1xuICAgIHZhciB0YSA9IHR4IC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHRyID0gdHk7XG5cbiAgICB2YXIgc2MgPSBNYXRoLmNvcyhzYSk7XG4gICAgdmFyIHNzID0gTWF0aC5zaW4oc2EpO1xuICAgIHZhciB0YyA9IE1hdGguY29zKHRhKTtcbiAgICB2YXIgdHMgPSBNYXRoLnNpbih0YSk7XG4gICAgdmFyIHNmID0gTWF0aC5hYnModGEgLSBzYSkgPiBNYXRoLlBJID8gdGEgPD0gc2EgOiB0YSA+IHNhO1xuXG4gICAgcmV0dXJuICdcXG4gICAgICBNJyArIHNyICogc2MgKyAnLCcgKyBzciAqIHNzICsgJ1xcbiAgICAgIEEnICsgc3IgKyAnLCcgKyBzciArICcsMCwwLCcgKyAoc2YgPyAxIDogMCkgKyAnLCcgKyBzciAqIHRjICsgJywnICsgc3IgKiB0cyArICdcXG4gICAgICBMJyArIHRyICogdGMgKyAnLCcgKyB0ciAqIHRzICsgJ1xcbiAgICAnO1xuICB9O1xufVxuXG5MaW5rUmFkaWFsU3RlcCQxLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rUmFkaWFsU3RlcCQxKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhSYWRpYWxTdGVwKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZXhwb3J0IHsgQXJjLCBQaWUsIExpbmUsIExpbmVQYXRoLCBMaW5lUmFkaWFsLCBBcmVhLCBBcmVhQ2xvc2VkLCBBcmVhU3RhY2ssIEJhciwgQmFyR3JvdXAsIEJhckdyb3VwSG9yaXpvbnRhbCwgQmFyU3RhY2ssIEJhclN0YWNrSG9yaXpvbnRhbCwgU3RhY2ssIGNhbGxPclZhbHVlLCBzdGFja09mZnNldCwgU1RBQ0tfT0ZGU0VUUywgU1RBQ0tfT0ZGU0VUX05BTUVTLCBzdGFja09yZGVyLCBTVEFDS19PUkRFUlMsIFNUQUNLX09SREVSX05BTUVTLCBMaW5rSG9yaXpvbnRhbCwgcGF0aEhvcml6b250YWxEaWFnb25hbCwgTGlua1ZlcnRpY2FsLCBwYXRoVmVydGljYWxEaWFnb25hbCwgTGlua1JhZGlhbCwgcGF0aFJhZGlhbERpYWdvbmFsLCBMaW5rSG9yaXpvbnRhbEN1cnZlLCBwYXRoSG9yaXpvbnRhbEN1cnZlLCBMaW5rVmVydGljYWxDdXJ2ZSwgcGF0aFZlcnRpY2FsQ3VydmUsIExpbmtSYWRpYWxDdXJ2ZSwgcGF0aFJhZGlhbEN1cnZlLCBMaW5rSG9yaXpvbnRhbExpbmUsIHBhdGhIb3Jpem9udGFsTGluZSwgTGlua1ZlcnRpY2FsTGluZSwgcGF0aFZlcnRpY2FsTGluZSwgTGlua1JhZGlhbFN0ZXAgYXMgTGlua1JhZGlhbExpbmUsIHBhdGhSYWRpYWxMaW5lLCBMaW5rSG9yaXpvbnRhbFN0ZXAsIHBhdGhIb3Jpem9udGFsU3RlcCwgTGlua1ZlcnRpY2FsU3RlcCwgcGF0aFZlcnRpY2FsU3RlcCwgTGlua1JhZGlhbFN0ZXAkMSBhcyBMaW5rUmFkaWFsU3RlcCwgcGF0aFJhZGlhbFN0ZXAgfTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBDbGlwUGF0aCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydpZCcsICdjaGlsZHJlbiddKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2RlZnMnLFxuICAgIG51bGwsXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdjbGlwUGF0aCcsXG4gICAgICBfZXh0ZW5kcyh7IGlkOiBpZCB9LCByZXN0UHJvcHMpLFxuICAgICAgY2hpbGRyZW5cbiAgICApXG4gICk7XG59KTtcblxudmFyIENpcmNsZUNsaXBQYXRoID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICBjeCA9IF9yZWYuY3gsXG4gICAgICBjeSA9IF9yZWYuY3ksXG4gICAgICByID0gX3JlZi5yLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydpZCcsICdjeCcsICdjeScsICdyJ10pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBDbGlwUGF0aCxcbiAgICB7IGlkOiBpZCB9LFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2NpcmNsZScsIF9leHRlbmRzKHsgY3g6IGN4LCBjeTogY3ksIHI6IHIgfSwgcmVzdFByb3BzKSlcbiAgKTtcbn0pO1xuXG52YXIgUmVjdENsaXBQYXRoID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICBfcmVmJHggPSBfcmVmLngsXG4gICAgICB4ID0gX3JlZiR4ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR4LFxuICAgICAgX3JlZiR5ID0gX3JlZi55LFxuICAgICAgeSA9IF9yZWYkeSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkeSxcbiAgICAgIF9yZWYkd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgd2lkdGggPSBfcmVmJHdpZHRoID09PSB1bmRlZmluZWQgPyAxIDogX3JlZiR3aWR0aCxcbiAgICAgIF9yZWYkaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICBoZWlnaHQgPSBfcmVmJGhlaWdodCA9PT0gdW5kZWZpbmVkID8gMSA6IF9yZWYkaGVpZ2h0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydpZCcsICd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0J10pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBDbGlwUGF0aCxcbiAgICB7IGlkOiBpZCB9LFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3JlY3QnLCBfZXh0ZW5kcyh7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSwgcmVzdFByb3BzKSlcbiAgKTtcbn0pO1xuXG5leHBvcnQgeyBDbGlwUGF0aCwgQ2lyY2xlQ2xpcFBhdGgsIFJlY3RDbGlwUGF0aCB9O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IEFyZWEgfSBmcm9tICdAdngvc2hhcGUnO1xuaW1wb3J0IHsgQ2xpcFBhdGggfSBmcm9tICdAdngvY2xpcC1wYXRoJztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmZ1bmN0aW9uIFRocmVzaG9sZChfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIHhTY2FsZSA9IF9yZWYueFNjYWxlLFxuICAgICAgeVNjYWxlID0gX3JlZi55U2NhbGUsXG4gICAgICBjbGlwQWJvdmVUbyA9IF9yZWYuY2xpcEFib3ZlVG8sXG4gICAgICBjbGlwQmVsb3dUbyA9IF9yZWYuY2xpcEJlbG93VG8sXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkwID0gX3JlZi55MCxcbiAgICAgIHkxID0gX3JlZi55MSxcbiAgICAgIGFib3ZlQXJlYVByb3BzID0gX3JlZi5hYm92ZUFyZWFQcm9wcyxcbiAgICAgIGJlbG93QXJlYVByb3BzID0gX3JlZi5iZWxvd0FyZWFQcm9wcztcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC10aHJlc2hvbGQnLCBjbGFzc05hbWUpIH0sXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIEFyZWEsXG4gICAgICB7IGN1cnZlOiBjdXJ2ZSwgZGF0YTogZGF0YSwgeDogeCwgeTE6IHkxLCB4U2NhbGU6IHhTY2FsZSwgeVNjYWxlOiB5U2NhbGUgfSxcbiAgICAgIGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgcGF0aCA9IF9yZWYyLnBhdGg7XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ2cnLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIENsaXBQYXRoLFxuICAgICAgICAgICAgeyBpZDogJ3RocmVzaG9sZC1jbGlwLWJlbG93JyB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIHsgZDogcGF0aC55MChjbGlwQmVsb3dUbykoZGF0YSkgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBDbGlwUGF0aCxcbiAgICAgICAgICAgIHsgaWQ6ICd0aHJlc2hvbGQtY2xpcC1hYm92ZScgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCB7IGQ6IHBhdGgueTAoY2xpcEFib3ZlVG8pKGRhdGEpIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICksXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChBcmVhLCBfZXh0ZW5kcyh7XG4gICAgICBjdXJ2ZTogY3VydmUsXG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgeDogeCxcbiAgICAgIHkwOiB5MCxcbiAgICAgIHkxOiB5MSxcbiAgICAgIHhTY2FsZTogeFNjYWxlLFxuICAgICAgeVNjYWxlOiB5U2NhbGUsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgIGNsaXBQYXRoOiAndXJsKCN0aHJlc2hvbGQtY2xpcC1iZWxvdyknXG4gICAgfSwgYmVsb3dBcmVhUHJvcHMpKSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEFyZWEsIF9leHRlbmRzKHtcbiAgICAgIGN1cnZlOiBjdXJ2ZSxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICB4OiB4LFxuICAgICAgeTA6IHkwLFxuICAgICAgeTE6IHkxLFxuICAgICAgeFNjYWxlOiB4U2NhbGUsXG4gICAgICB5U2NhbGU6IHlTY2FsZSxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgY2xpcFBhdGg6ICd1cmwoI3RocmVzaG9sZC1jbGlwLWFib3ZlKSdcbiAgICB9LCBhYm92ZUFyZWFQcm9wcykpXG4gICk7XG59XG5cbmV4cG9ydCB7IFRocmVzaG9sZCB9O1xuIiwiZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnQGRhdGEtdWkvdGhlbWUnO1xuaW1wb3J0IHsgVGhyZXNob2xkIH0gZnJvbSAnQHZ4L3RocmVzaG9sZCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGludGVycG9sYXRvckxvb2t1cCBmcm9tICcuLi91dGlscy9pbnRlcnBvbGF0b3JMb29rdXAnO1xuaW1wb3J0IHsgaW50ZXJwb2xhdGlvblNoYXBlIH0gZnJvbSAnLi4vdXRpbHMvcHJvcFNoYXBlcyc7XG5pbXBvcnQgc2hhcmVkU2VyaWVzUHJvcHMgZnJvbSAnLi4vdXRpbHMvc2hhcmVkU2VyaWVzUHJvcHMnO1xuXG52YXIgcHJvcFR5cGVzID0gX2V4dGVuZHMoe30sIHNoYXJlZFNlcmllc1Byb3BzLCB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICAvLyBBcmVhU2VyaWVzIHR5cGVcbiAgaW50ZXJwb2xhdGlvbjogaW50ZXJwb2xhdGlvblNoYXBlXG59KTtcblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgaW50ZXJwb2xhdGlvbjogJ21vbm90b25lWCdcbn07XG52YXIgREVGQVVMVF9PUEFDSVRZID0gMC40O1xuXG52YXIgZ2V0WCA9IGZ1bmN0aW9uIGdldFgoZCkge1xuICByZXR1cm4gZC54O1xufTtcblxudmFyIGdldFkwID0gZnVuY3Rpb24gZ2V0WTAoZCkge1xuICByZXR1cm4gZC55MDtcbn07XG5cbnZhciBnZXRZMSA9IGZ1bmN0aW9uIGdldFkxKGQpIHtcbiAgcmV0dXJuIGQueTE7XG59O1xuXG52YXIgQXJlYURpZmZlcmVuY2VTZXJpZXMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRQdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKEFyZWFEaWZmZXJlbmNlU2VyaWVzLCBfUmVhY3QkUHVyZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQXJlYURpZmZlcmVuY2VTZXJpZXMoKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRQdXJlQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBBcmVhRGlmZmVyZW5jZVNlcmllcy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBkaXNhYmxlTW91c2VFdmVudHMgPSBfdGhpcyRwcm9wcy5kaXNhYmxlTW91c2VFdmVudHMsXG4gICAgICAgIGludGVycG9sYXRpb24gPSBfdGhpcyRwcm9wcy5pbnRlcnBvbGF0aW9uLFxuICAgICAgICB4U2NhbGUgPSBfdGhpcyRwcm9wcy54U2NhbGUsXG4gICAgICAgIHlTY2FsZSA9IF90aGlzJHByb3BzLnlTY2FsZSxcbiAgICAgICAgb25DbGljayA9IF90aGlzJHByb3BzLm9uQ2xpY2ssXG4gICAgICAgIG9uTW91c2VNb3ZlID0gX3RoaXMkcHJvcHMub25Nb3VzZU1vdmUsXG4gICAgICAgIG9uTW91c2VMZWF2ZSA9IF90aGlzJHByb3BzLm9uTW91c2VMZWF2ZSxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgbWFyZ2luID0gX3RoaXMkcHJvcHMubWFyZ2luO1xuICAgIGlmICgheFNjYWxlIHx8ICF5U2NhbGUpIHJldHVybiBudWxsO1xuICAgIHZhciBjaGlsZEFycmF5ID0gQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbik7XG4gICAgdmFyIGNoaWxkMSA9IGNoaWxkQXJyYXlbMF0sXG4gICAgICAgIGNoaWxkMiA9IGNoaWxkQXJyYXlbMV07XG5cbiAgICBpZiAoY2hpbGRBcnJheS5sZW5ndGggIT09IDIgfHwgY2hpbGQxLnR5cGUuZGlzcGxheU5hbWUgIT09ICdBcmVhU2VyaWVzJyB8fCBjaGlsZDIudHlwZS5kaXNwbGF5TmFtZSAhPT0gJ0FyZWFTZXJpZXMnKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0FyZWFEaWZmZXJlbmNlU2VyaWVzIGV4cGVjdHMgZXhhY3RseSB0d28gQXJlYVNlcmllcyBjaGlsZHJlbicpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIF9jaGlsZDEkcHJvcHMgPSBjaGlsZDEucHJvcHMsXG4gICAgICAgIGRhdGExID0gX2NoaWxkMSRwcm9wcy5kYXRhLFxuICAgICAgICBmaWxsMSA9IF9jaGlsZDEkcHJvcHMuZmlsbCxcbiAgICAgICAgb3BhY2l0eTEgPSBfY2hpbGQxJHByb3BzLmZpbGxPcGFjaXR5O1xuICAgIHZhciBfY2hpbGQyJHByb3BzID0gY2hpbGQyLnByb3BzLFxuICAgICAgICBkYXRhMiA9IF9jaGlsZDIkcHJvcHMuZGF0YSxcbiAgICAgICAgZmlsbDIgPSBfY2hpbGQyJHByb3BzLmZpbGwsXG4gICAgICAgIG9wYWNpdHkyID0gX2NoaWxkMiRwcm9wcy5maWxsT3BhY2l0eTtcblxuICAgIGlmIChkYXRhMS5sZW5ndGggIT09IGRhdGEyLmxlbmd0aCkge1xuICAgICAgY29uc29sZS53YXJuKCdBcmVhRGlmZmVyZW5jZVNlcmllcyBjaGlsZHJlbiBzaG91bGQgaGF2ZSB0aGUgc2FtZSBkYXRhIGxlbmd0aCcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGN1cnZlID0gaW50ZXJwb2xhdG9yTG9va3VwW2ludGVycG9sYXRpb25dIHx8IGludGVycG9sYXRvckxvb2t1cC5tb25vdG9uZVg7XG4gICAgdmFyIHlFeHRlbnQgPSB5U2NhbGUucmFuZ2UoKTtcbiAgICB2YXIgbWVyZ2VkRGF0YSA9IGRhdGExLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogZC54LFxuICAgICAgICB5MDogZC55LFxuICAgICAgICB5MTogZGF0YTJbaV0ueVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChUaHJlc2hvbGQsIHtcbiAgICAgIGRhdGE6IG1lcmdlZERhdGEsXG4gICAgICB4OiBnZXRYLFxuICAgICAgeTA6IGdldFkwLFxuICAgICAgeTE6IGdldFkxLFxuICAgICAgeFNjYWxlOiB4U2NhbGUsXG4gICAgICB5U2NhbGU6IHlTY2FsZSxcbiAgICAgIGNsaXBBYm92ZVRvOiBNYXRoLm1pbi5hcHBseShNYXRoLCB5RXh0ZW50KSxcbiAgICAgIGNsaXBCZWxvd1RvOiBNYXRoLm1heC5hcHBseShNYXRoLCB5RXh0ZW50KSxcbiAgICAgIGN1cnZlOiBjdXJ2ZSxcbiAgICAgIGFib3ZlQXJlYVByb3BzOiB7XG4gICAgICAgIGZpbGw6IGZpbGwxIHx8IGNvbG9yLmNhdGVnb3JpZXNbMF0sXG4gICAgICAgIGZpbGxPcGFjaXR5OiBvcGFjaXR5MSB8fCBERUZBVUxUX09QQUNJVFlcbiAgICAgIH0sXG4gICAgICBiZWxvd0FyZWFQcm9wczoge1xuICAgICAgICBmaWxsOiBmaWxsMiB8fCBjb2xvci5jYXRlZ29yaWVzWzBdLFxuICAgICAgICBmaWxsT3BhY2l0eTogb3BhY2l0eTIgfHwgREVGQVVMVF9PUEFDSVRZXG4gICAgICB9XG4gICAgfSksIGNoaWxkQXJyYXkubWFwKGZ1bmN0aW9uIChDaGlsZCkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChDaGlsZCwge1xuICAgICAgICB4U2NhbGU6IHhTY2FsZSxcbiAgICAgICAgeVNjYWxlOiB5U2NhbGUsXG4gICAgICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgICAgIG9uTW91c2VNb3ZlOiBvbk1vdXNlTW92ZSxcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmUsXG4gICAgICAgIGludGVycG9sYXRpb246IGludGVycG9sYXRpb24sXG4gICAgICAgIGRpc2FibGVNb3VzZUV2ZW50czogQ2hpbGQucHJvcHMuZGlzYWJsZU1vdXNlRXZlbnRzIHx8IGRpc2FibGVNb3VzZUV2ZW50cyxcbiAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgbWFyZ2luOiBtYXJnaW5cbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gQXJlYURpZmZlcmVuY2VTZXJpZXM7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpO1xuXG5leHBvcnQgeyBBcmVhRGlmZmVyZW5jZVNlcmllcyBhcyBkZWZhdWx0IH07XG5BcmVhRGlmZmVyZW5jZVNlcmllcy5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5BcmVhRGlmZmVyZW5jZVNlcmllcy5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5BcmVhRGlmZmVyZW5jZVNlcmllcy5kaXNwbGF5TmFtZSA9ICdBcmVhRGlmZmVyZW5jZVNlcmllcyc7IiwiaW1wb3J0IHsgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQXJlYURpZmZlcmVuY2VTZXJpZXMgZnJvbSAnLi4vc2VyaWVzL0FyZWFEaWZmZXJlbmNlU2VyaWVzJztcbmltcG9ydCB7IGlzU2VyaWVzLCBpc0RlZmluZWQsIGNvbXBvbmVudE5hbWUgfSBmcm9tICcuL2NoYXJ0VXRpbHMnOyAvLyB0aGlzIGZ1bmN0aW9uIGNvbGxlY3RzIGFsbCBkYXRhIGZyb20gY2hpbGQgc2VyaWVzIHRvIGRlZmluZXMgYSB2b3Jvbm9pIG92ZXJsYXlcbi8vIGJlY2F1c2UgeCx5IGNvb3JkaW5hdGVzIGFyZSByZXF1aXJlZCB0byBkZWZpbmUgYSB2b3Jvbm9pLCBpdCBmaWx0ZXJzIGFueSBwb2ludHNcbi8vIHdpdGggdW5kZWZpbmVkIHggb3IgeSB2YWx1ZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29sbGVjdFZvcm9ub2lEYXRhKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGdldFggPSBfcmVmLmdldFgsXG4gICAgICBnZXRZID0gX3JlZi5nZXRZO1xuICByZXR1cm4gQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbikucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIENoaWxkKSB7XG4gICAgdmFyIG5hbWUgPSBjb21wb25lbnROYW1lKENoaWxkKTtcblxuICAgIGlmIChpc1NlcmllcyhuYW1lKSAmJiAhQ2hpbGQucHJvcHMuZGlzYWJsZU1vdXNlRXZlbnRzKSB7XG4gICAgICBpZiAobmFtZSA9PT0gQXJlYURpZmZlcmVuY2VTZXJpZXMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoY29sbGVjdFZvcm9ub2lEYXRhKHtcbiAgICAgICAgICBjaGlsZHJlbjogQ2hpbGQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgZ2V0WDogZ2V0WCxcbiAgICAgICAgICBnZXRZOiBnZXRZXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoQ2hpbGQucHJvcHMuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGlzRGVmaW5lZChnZXRYKGQpKSAmJiBpc0RlZmluZWQoZ2V0WShkKSk7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgW10pO1xufSIsImltcG9ydCB7IFBvaW50IH0gZnJvbSAnQHZ4L3BvaW50JztcblxuZnVuY3Rpb24gbG9jYWxQb2ludChub2RlLCBldmVudCkge1xuICAvLyBjYWxsZWQgd2l0aCBubyBhcmdzXG4gIGlmICghbm9kZSkgcmV0dXJuO1xuXG4gIC8vIGNhbGxlZCB3aXRoIGxvY2FsUG9pbnQoZXZlbnQpXG4gIGlmIChub2RlLnRhcmdldCkge1xuICAgIGV2ZW50ID0gbm9kZTtcblxuICAgIC8vIHNldCBub2RlIHRvIHRhcmdldHMgb3duZXIgc3ZnXG4gICAgbm9kZSA9IGV2ZW50LnRhcmdldC5vd25lclNWR0VsZW1lbnQ7XG5cbiAgICAvLyBmaW5kIHRoZSBvdXRlcm1vc3Qgc3ZnXG4gICAgd2hpbGUgKG5vZGUub3duZXJTVkdFbGVtZW50KSB7XG4gICAgICBub2RlID0gbm9kZS5vd25lclNWR0VsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gZGVmYXVsdCB0byBtb3VzZSBldmVudFxuICB2YXIgX2V2ZW50ID0gZXZlbnQsXG4gICAgICBjbGllbnRYID0gX2V2ZW50LmNsaWVudFgsXG4gICAgICBjbGllbnRZID0gX2V2ZW50LmNsaWVudFk7XG5cbiAgLy8gc3VwcG9ydCB0b3VjaCBldmVudFxuXG4gIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgIGNsaWVudFggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xuICAgIGNsaWVudFkgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZO1xuICB9XG5cbiAgLy8gY2FsY3VsYXRlIGNvb3JkaW5hdGVzIGZyb20gc3ZnXG4gIGlmIChub2RlLmNyZWF0ZVNWR1BvaW50KSB7XG4gICAgdmFyIHBvaW50ID0gbm9kZS5jcmVhdGVTVkdQb2ludCgpO1xuICAgIHBvaW50LnggPSBjbGllbnRYO1xuICAgIHBvaW50LnkgPSBjbGllbnRZO1xuICAgIHBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKG5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICByZXR1cm4gbmV3IFBvaW50KHtcbiAgICAgIHg6IHBvaW50LngsXG4gICAgICB5OiBwb2ludC55XG4gICAgfSk7XG4gIH1cblxuICAvLyBmYWxsYmFjayB0byBjYWxjdWxhdGluZyBwb3NpdGlvbiBmcm9tIG5vbi1zdmcgZG9tIG5vZGVcbiAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gbmV3IFBvaW50KHtcbiAgICB4OiBjbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LFxuICAgIHk6IGNsaWVudFkgLSByZWN0LnRvcCAtIG5vZGUuY2xpZW50VG9wXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0b3VjaFBvaW50KG5vZGUsIGV2ZW50KSB7XG4gIGlmICghbm9kZSkgcmV0dXJuO1xuICB2YXIgc3ZnID0gbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgbm9kZTtcbiAgaWYgKHN2Zy5jcmVhdGVTVkdQb2ludCkge1xuICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgIHBvaW50LnggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xuICAgIHBvaW50LnkgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZO1xuICAgIHBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKG5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICByZXR1cm4gbmV3IFBvaW50KHtcbiAgICAgIHg6IHBvaW50LngsXG4gICAgICB5OiBwb2ludC55XG4gICAgfSk7XG4gIH1cbiAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gbmV3IFBvaW50KHtcbiAgICB4OiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LFxuICAgIHk6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkgLSByZWN0LnRvcCAtIG5vZGUuY2xpZW50VG9wXG4gIH0pO1xufVxuXG5leHBvcnQgeyBsb2NhbFBvaW50LCB0b3VjaFBvaW50IH07XG4iLCJpbXBvcnQgeyBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGxvY2FsUG9pbnQgfSBmcm9tICdAdngvZXZlbnQnO1xuaW1wb3J0IGZpbmRDbG9zZXN0RGF0dW0gZnJvbSAnLi9maW5kQ2xvc2VzdERhdHVtJztcbmltcG9ydCB7IGNvbXBvbmVudE5hbWUsIGlzU2VyaWVzIH0gZnJvbSAnLi9jaGFydFV0aWxzJztcbnZhciBERUZBVUxUX01BWF9ESVNUQU5DRV9QWCA9IDEwMDA7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaW5kQ2xvc2VzdERhdHVtcyhfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICB4U2NhbGUgPSBfcmVmLnhTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgX3JlZiRtYXJnaW4gPSBfcmVmLm1hcmdpbixcbiAgICAgIG1hcmdpbiA9IF9yZWYkbWFyZ2luID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkbWFyZ2luLFxuICAgICAgZ2V0WCA9IF9yZWYuZ2V0WCxcbiAgICAgIGdldFkgPSBfcmVmLmdldFksXG4gICAgICBldmVudCA9IF9yZWYuZXZlbnQsXG4gICAgICBfcmVmJG1heFhEaXN0YW5jZVB4ID0gX3JlZi5tYXhYRGlzdGFuY2VQeCxcbiAgICAgIG1heFhEaXN0YW5jZVB4ID0gX3JlZiRtYXhYRGlzdGFuY2VQeCA9PT0gdm9pZCAwID8gREVGQVVMVF9NQVhfRElTVEFOQ0VfUFggOiBfcmVmJG1heFhEaXN0YW5jZVB4O1xuICBpZiAoIWV2ZW50IHx8ICFldmVudC50YXJnZXQgfHwgIWV2ZW50LnRhcmdldC5vd25lclNWR0VsZW1lbnQpIHJldHVybiBudWxsO1xuICB2YXIgc2VyaWVzID0ge307XG4gIHZhciBnRWxlbWVudCA9IGV2ZW50LnRhcmdldC5vd25lclNWR0VsZW1lbnQ7XG5cbiAgdmFyIF9sb2NhbFBvaW50ID0gbG9jYWxQb2ludChnRWxlbWVudCwgZXZlbnQpLFxuICAgICAgc3ZnTW91c2VYID0gX2xvY2FsUG9pbnQueCxcbiAgICAgIHN2Z01vdXNlWSA9IF9sb2NhbFBvaW50Lnk7XG5cbiAgdmFyIG1vdXNlWCA9IHN2Z01vdXNlWCAtIChtYXJnaW4ubGVmdCB8fCAwKTtcbiAgdmFyIG1vdXNlWSA9IHN2Z01vdXNlWSAtIChtYXJnaW4udG9wIHx8IDApO1xuICB2YXIgY2xvc2VzdERhdHVtO1xuICB2YXIgbWluRGVsdGFYID0gSW5maW5pdHk7XG4gIHZhciBtaW5EZWx0YVkgPSBJbmZpbml0eTtcbiAgdmFyIGZsYXRTZXJpZXNDaGlsZHJlbiA9IFtdO1xuICBDaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoQ2hpbGQpIHtcbiAgICB2YXIgbmFtZSA9IGNvbXBvbmVudE5hbWUoQ2hpbGQpO1xuXG4gICAgaWYgKG5hbWUgPT09ICdBcmVhRGlmZmVyZW5jZVNlcmllcycpIHtcbiAgICAgIENoaWxkcmVuLmZvckVhY2goQ2hpbGQucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChOZXN0ZWRDaGlsZCkge1xuICAgICAgICBmbGF0U2VyaWVzQ2hpbGRyZW4ucHVzaChOZXN0ZWRDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzU2VyaWVzKG5hbWUpKSB7XG4gICAgICBmbGF0U2VyaWVzQ2hpbGRyZW4ucHVzaChDaGlsZCk7XG4gICAgfVxuICB9KTsgLy8gY29sbGVjdCBkYXRhIGZyb20gYWxsIHNlcmllcyB0aGF0IGhhdmUgYW4geCB2YWx1ZSBuZWFyIHRoaXMgcG9pbnRcblxuICBmbGF0U2VyaWVzQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoQ2hpbGQsIGNoaWxkSW5kZXgpIHtcbiAgICBpZiAoIUNoaWxkLnByb3BzLmRpc2FibGVNb3VzZUV2ZW50cykge1xuICAgICAgdmFyIF9DaGlsZCRwcm9wcyA9IENoaWxkLnByb3BzLFxuICAgICAgICAgIGRhdGEgPSBfQ2hpbGQkcHJvcHMuZGF0YSxcbiAgICAgICAgICBzZXJpZXNLZXkgPSBfQ2hpbGQkcHJvcHMuc2VyaWVzS2V5OyAvLyBAVE9ETyBkYXRhIHNob3VsZCBiZSBzb3J0ZWQsIGNvbWUgdXAgd2l0aCBhIHdheSB0byBlbmZvcmNlK2NhY2hlIGluc3RlYWQgb2YgcmVseWluZyBvbiB1c2VyXG5cbiAgICAgIHZhciBkYXR1bSA9IGZpbmRDbG9zZXN0RGF0dW0oe1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBnZXRYOiBnZXRYLFxuICAgICAgICB4U2NhbGU6IHhTY2FsZSxcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBtYXJnaW5MZWZ0OiBtYXJnaW4ubGVmdFxuICAgICAgfSk7XG4gICAgICB2YXIgZGVsdGFYID0gTWF0aC5hYnMoeFNjYWxlKGdldFgoZGF0dW0gfHwge30pKSAtIG1vdXNlWCk7XG5cbiAgICAgIGlmIChkYXR1bSAmJiBkZWx0YVggPD0gbWF4WERpc3RhbmNlUHgpIHtcbiAgICAgICAgdmFyIGtleSA9IHNlcmllc0tleSB8fCBjaGlsZEluZGV4OyAvLyBmYWxsIGJhY2sgdG8gY2hpbGQgaW5kZXhcblxuICAgICAgICBzZXJpZXNba2V5XSA9IGRhdHVtO1xuICAgICAgICB2YXIgZGVsdGFZID0gTWF0aC5hYnMoeVNjYWxlKGdldFkoZGF0dW0pKSAtIG1vdXNlWSk7XG4gICAgICAgIGNsb3Nlc3REYXR1bSA9IGRlbHRhWSA8IG1pbkRlbHRhWSAmJiBkZWx0YVggPD0gbWluRGVsdGFYID8gZGF0dW0gOiBjbG9zZXN0RGF0dW07XG4gICAgICAgIG1pbkRlbHRhWCA9IGNsb3Nlc3REYXR1bSA9PT0gZGF0dW0gPyBkZWx0YVggOiBtaW5EZWx0YVg7XG4gICAgICAgIG1pbkRlbHRhWSA9IGNsb3Nlc3REYXR1bSA9PT0gZGF0dW0gPyBkZWx0YVkgOiBtaW5EZWx0YVk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzZXJpZXM6IHNlcmllcyxcbiAgICBjbG9zZXN0RGF0dW06IGNsb3Nlc3REYXR1bVxuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlT2JqZWN0RW50cmllcyhhLCBiKSB7XG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBhW2tdID09PSBiW2tdO1xuICB9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiB4KGQpIHtcbiAgcmV0dXJuIGRbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5KGQpIHtcbiAgcmV0dXJuIGRbMV07XG59XG4iLCJmdW5jdGlvbiBSZWRCbGFja1RyZWUoKSB7XG4gIHRoaXMuXyA9IG51bGw7IC8vIHJvb3Qgbm9kZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVkQmxhY2tOb2RlKG5vZGUpIHtcbiAgbm9kZS5VID0gLy8gcGFyZW50IG5vZGVcbiAgbm9kZS5DID0gLy8gY29sb3IgLSB0cnVlIGZvciByZWQsIGZhbHNlIGZvciBibGFja1xuICBub2RlLkwgPSAvLyBsZWZ0IG5vZGVcbiAgbm9kZS5SID0gLy8gcmlnaHQgbm9kZVxuICBub2RlLlAgPSAvLyBwcmV2aW91cyBub2RlXG4gIG5vZGUuTiA9IG51bGw7IC8vIG5leHQgbm9kZVxufVxuXG5SZWRCbGFja1RyZWUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUmVkQmxhY2tUcmVlLFxuXG4gIGluc2VydDogZnVuY3Rpb24oYWZ0ZXIsIG5vZGUpIHtcbiAgICB2YXIgcGFyZW50LCBncmFuZHBhLCB1bmNsZTtcblxuICAgIGlmIChhZnRlcikge1xuICAgICAgbm9kZS5QID0gYWZ0ZXI7XG4gICAgICBub2RlLk4gPSBhZnRlci5OO1xuICAgICAgaWYgKGFmdGVyLk4pIGFmdGVyLk4uUCA9IG5vZGU7XG4gICAgICBhZnRlci5OID0gbm9kZTtcbiAgICAgIGlmIChhZnRlci5SKSB7XG4gICAgICAgIGFmdGVyID0gYWZ0ZXIuUjtcbiAgICAgICAgd2hpbGUgKGFmdGVyLkwpIGFmdGVyID0gYWZ0ZXIuTDtcbiAgICAgICAgYWZ0ZXIuTCA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZnRlci5SID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IGFmdGVyO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fKSB7XG4gICAgICBhZnRlciA9IFJlZEJsYWNrRmlyc3QodGhpcy5fKTtcbiAgICAgIG5vZGUuUCA9IG51bGw7XG4gICAgICBub2RlLk4gPSBhZnRlcjtcbiAgICAgIGFmdGVyLlAgPSBhZnRlci5MID0gbm9kZTtcbiAgICAgIHBhcmVudCA9IGFmdGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLlAgPSBub2RlLk4gPSBudWxsO1xuICAgICAgdGhpcy5fID0gbm9kZTtcbiAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgfVxuICAgIG5vZGUuTCA9IG5vZGUuUiA9IG51bGw7XG4gICAgbm9kZS5VID0gcGFyZW50O1xuICAgIG5vZGUuQyA9IHRydWU7XG5cbiAgICBhZnRlciA9IG5vZGU7XG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuQykge1xuICAgICAgZ3JhbmRwYSA9IHBhcmVudC5VO1xuICAgICAgaWYgKHBhcmVudCA9PT0gZ3JhbmRwYS5MKSB7XG4gICAgICAgIHVuY2xlID0gZ3JhbmRwYS5SO1xuICAgICAgICBpZiAodW5jbGUgJiYgdW5jbGUuQykge1xuICAgICAgICAgIHBhcmVudC5DID0gdW5jbGUuQyA9IGZhbHNlO1xuICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgYWZ0ZXIgPSBncmFuZHBhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhZnRlciA9PT0gcGFyZW50LlIpIHtcbiAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICAgICAgICBwYXJlbnQgPSBhZnRlci5VO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuQyA9IGZhbHNlO1xuICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBncmFuZHBhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5jbGUgPSBncmFuZHBhLkw7XG4gICAgICAgIGlmICh1bmNsZSAmJiB1bmNsZS5DKSB7XG4gICAgICAgICAgcGFyZW50LkMgPSB1bmNsZS5DID0gZmFsc2U7XG4gICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICBhZnRlciA9IGdyYW5kcGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFmdGVyID09PSBwYXJlbnQuTCkge1xuICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICAgICAgICBwYXJlbnQgPSBhZnRlci5VO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuQyA9IGZhbHNlO1xuICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIGdyYW5kcGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBhZnRlci5VO1xuICAgIH1cbiAgICB0aGlzLl8uQyA9IGZhbHNlO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlLk4pIG5vZGUuTi5QID0gbm9kZS5QO1xuICAgIGlmIChub2RlLlApIG5vZGUuUC5OID0gbm9kZS5OO1xuICAgIG5vZGUuTiA9IG5vZGUuUCA9IG51bGw7XG5cbiAgICB2YXIgcGFyZW50ID0gbm9kZS5VLFxuICAgICAgICBzaWJsaW5nLFxuICAgICAgICBsZWZ0ID0gbm9kZS5MLFxuICAgICAgICByaWdodCA9IG5vZGUuUixcbiAgICAgICAgbmV4dCxcbiAgICAgICAgcmVkO1xuXG4gICAgaWYgKCFsZWZ0KSBuZXh0ID0gcmlnaHQ7XG4gICAgZWxzZSBpZiAoIXJpZ2h0KSBuZXh0ID0gbGVmdDtcbiAgICBlbHNlIG5leHQgPSBSZWRCbGFja0ZpcnN0KHJpZ2h0KTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuTCA9PT0gbm9kZSkgcGFyZW50LkwgPSBuZXh0O1xuICAgICAgZWxzZSBwYXJlbnQuUiA9IG5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuXyA9IG5leHQ7XG4gICAgfVxuXG4gICAgaWYgKGxlZnQgJiYgcmlnaHQpIHtcbiAgICAgIHJlZCA9IG5leHQuQztcbiAgICAgIG5leHQuQyA9IG5vZGUuQztcbiAgICAgIG5leHQuTCA9IGxlZnQ7XG4gICAgICBsZWZ0LlUgPSBuZXh0O1xuICAgICAgaWYgKG5leHQgIT09IHJpZ2h0KSB7XG4gICAgICAgIHBhcmVudCA9IG5leHQuVTtcbiAgICAgICAgbmV4dC5VID0gbm9kZS5VO1xuICAgICAgICBub2RlID0gbmV4dC5SO1xuICAgICAgICBwYXJlbnQuTCA9IG5vZGU7XG4gICAgICAgIG5leHQuUiA9IHJpZ2h0O1xuICAgICAgICByaWdodC5VID0gbmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQuVSA9IHBhcmVudDtcbiAgICAgICAgcGFyZW50ID0gbmV4dDtcbiAgICAgICAgbm9kZSA9IG5leHQuUjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVkID0gbm9kZS5DO1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUpIG5vZGUuVSA9IHBhcmVudDtcbiAgICBpZiAocmVkKSByZXR1cm47XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5DKSB7IG5vZGUuQyA9IGZhbHNlOyByZXR1cm47IH1cblxuICAgIGRvIHtcbiAgICAgIGlmIChub2RlID09PSB0aGlzLl8pIGJyZWFrO1xuICAgICAgaWYgKG5vZGUgPT09IHBhcmVudC5MKSB7XG4gICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcbiAgICAgICAgaWYgKHNpYmxpbmcuQykge1xuICAgICAgICAgIHNpYmxpbmcuQyA9IGZhbHNlO1xuICAgICAgICAgIHBhcmVudC5DID0gdHJ1ZTtcbiAgICAgICAgICBSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzaWJsaW5nLkwgJiYgc2libGluZy5MLkMpXG4gICAgICAgICAgICB8fCAoc2libGluZy5SICYmIHNpYmxpbmcuUi5DKSkge1xuICAgICAgICAgIGlmICghc2libGluZy5SIHx8ICFzaWJsaW5nLlIuQykge1xuICAgICAgICAgICAgc2libGluZy5MLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHNpYmxpbmcpO1xuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWJsaW5nLkMgPSBwYXJlbnQuQztcbiAgICAgICAgICBwYXJlbnQuQyA9IHNpYmxpbmcuUi5DID0gZmFsc2U7XG4gICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuXztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICBpZiAoc2libGluZy5DKSB7XG4gICAgICAgICAgc2libGluZy5DID0gZmFsc2U7XG4gICAgICAgICAgcGFyZW50LkMgPSB0cnVlO1xuICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzaWJsaW5nLkwgJiYgc2libGluZy5MLkMpXG4gICAgICAgICAgfHwgKHNpYmxpbmcuUiAmJiBzaWJsaW5nLlIuQykpIHtcbiAgICAgICAgICBpZiAoIXNpYmxpbmcuTCB8fCAhc2libGluZy5MLkMpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuUi5DID0gZmFsc2U7XG4gICAgICAgICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHNpYmxpbmcpO1xuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWJsaW5nLkMgPSBwYXJlbnQuQztcbiAgICAgICAgICBwYXJlbnQuQyA9IHNpYmxpbmcuTC5DID0gZmFsc2U7XG4gICAgICAgICAgUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgIG5vZGUgPSB0aGlzLl87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICBub2RlID0gcGFyZW50O1xuICAgICAgcGFyZW50ID0gcGFyZW50LlU7XG4gICAgfSB3aGlsZSAoIW5vZGUuQyk7XG5cbiAgICBpZiAobm9kZSkgbm9kZS5DID0gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFJlZEJsYWNrUm90YXRlTGVmdCh0cmVlLCBub2RlKSB7XG4gIHZhciBwID0gbm9kZSxcbiAgICAgIHEgPSBub2RlLlIsXG4gICAgICBwYXJlbnQgPSBwLlU7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuTCA9PT0gcCkgcGFyZW50LkwgPSBxO1xuICAgIGVsc2UgcGFyZW50LlIgPSBxO1xuICB9IGVsc2Uge1xuICAgIHRyZWUuXyA9IHE7XG4gIH1cblxuICBxLlUgPSBwYXJlbnQ7XG4gIHAuVSA9IHE7XG4gIHAuUiA9IHEuTDtcbiAgaWYgKHAuUikgcC5SLlUgPSBwO1xuICBxLkwgPSBwO1xufVxuXG5mdW5jdGlvbiBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRyZWUsIG5vZGUpIHtcbiAgdmFyIHAgPSBub2RlLFxuICAgICAgcSA9IG5vZGUuTCxcbiAgICAgIHBhcmVudCA9IHAuVTtcblxuICBpZiAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5MID09PSBwKSBwYXJlbnQuTCA9IHE7XG4gICAgZWxzZSBwYXJlbnQuUiA9IHE7XG4gIH0gZWxzZSB7XG4gICAgdHJlZS5fID0gcTtcbiAgfVxuXG4gIHEuVSA9IHBhcmVudDtcbiAgcC5VID0gcTtcbiAgcC5MID0gcS5SO1xuICBpZiAocC5MKSBwLkwuVSA9IHA7XG4gIHEuUiA9IHA7XG59XG5cbmZ1bmN0aW9uIFJlZEJsYWNrRmlyc3Qobm9kZSkge1xuICB3aGlsZSAobm9kZS5MKSBub2RlID0gbm9kZS5MO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVkQmxhY2tUcmVlO1xuIiwiaW1wb3J0IHtjZWxscywgZWRnZXMsIGVwc2lsb259IGZyb20gXCIuL0RpYWdyYW1cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVkZ2UobGVmdCwgcmlnaHQsIHYwLCB2MSkge1xuICB2YXIgZWRnZSA9IFtudWxsLCBudWxsXSxcbiAgICAgIGluZGV4ID0gZWRnZXMucHVzaChlZGdlKSAtIDE7XG4gIGVkZ2UubGVmdCA9IGxlZnQ7XG4gIGVkZ2UucmlnaHQgPSByaWdodDtcbiAgaWYgKHYwKSBzZXRFZGdlRW5kKGVkZ2UsIGxlZnQsIHJpZ2h0LCB2MCk7XG4gIGlmICh2MSkgc2V0RWRnZUVuZChlZGdlLCByaWdodCwgbGVmdCwgdjEpO1xuICBjZWxsc1tsZWZ0LmluZGV4XS5oYWxmZWRnZXMucHVzaChpbmRleCk7XG4gIGNlbGxzW3JpZ2h0LmluZGV4XS5oYWxmZWRnZXMucHVzaChpbmRleCk7XG4gIHJldHVybiBlZGdlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQm9yZGVyRWRnZShsZWZ0LCB2MCwgdjEpIHtcbiAgdmFyIGVkZ2UgPSBbdjAsIHYxXTtcbiAgZWRnZS5sZWZ0ID0gbGVmdDtcbiAgcmV0dXJuIGVkZ2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRFZGdlRW5kKGVkZ2UsIGxlZnQsIHJpZ2h0LCB2ZXJ0ZXgpIHtcbiAgaWYgKCFlZGdlWzBdICYmICFlZGdlWzFdKSB7XG4gICAgZWRnZVswXSA9IHZlcnRleDtcbiAgICBlZGdlLmxlZnQgPSBsZWZ0O1xuICAgIGVkZ2UucmlnaHQgPSByaWdodDtcbiAgfSBlbHNlIGlmIChlZGdlLmxlZnQgPT09IHJpZ2h0KSB7XG4gICAgZWRnZVsxXSA9IHZlcnRleDtcbiAgfSBlbHNlIHtcbiAgICBlZGdlWzBdID0gdmVydGV4O1xuICB9XG59XG5cbi8vIExpYW5n4oCTQmFyc2t5IGxpbmUgY2xpcHBpbmcuXG5mdW5jdGlvbiBjbGlwRWRnZShlZGdlLCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgYSA9IGVkZ2VbMF0sXG4gICAgICBiID0gZWRnZVsxXSxcbiAgICAgIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIHQwID0gMCxcbiAgICAgIHQxID0gMSxcbiAgICAgIGR4ID0gYnggLSBheCxcbiAgICAgIGR5ID0gYnkgLSBheSxcbiAgICAgIHI7XG5cbiAgciA9IHgwIC0gYXg7XG4gIGlmICghZHggJiYgciA+IDApIHJldHVybjtcbiAgciAvPSBkeDtcbiAgaWYgKGR4IDwgMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfVxuXG4gIHIgPSB4MSAtIGF4O1xuICBpZiAoIWR4ICYmIHIgPCAwKSByZXR1cm47XG4gIHIgLz0gZHg7XG4gIGlmIChkeCA8IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH1cblxuICByID0geTAgLSBheTtcbiAgaWYgKCFkeSAmJiByID4gMCkgcmV0dXJuO1xuICByIC89IGR5O1xuICBpZiAoZHkgPCAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9XG5cbiAgciA9IHkxIC0gYXk7XG4gIGlmICghZHkgJiYgciA8IDApIHJldHVybjtcbiAgciAvPSBkeTtcbiAgaWYgKGR5IDwgMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfVxuXG4gIGlmICghKHQwID4gMCkgJiYgISh0MSA8IDEpKSByZXR1cm4gdHJ1ZTsgLy8gVE9ETyBCZXR0ZXIgY2hlY2s/XG5cbiAgaWYgKHQwID4gMCkgZWRnZVswXSA9IFtheCArIHQwICogZHgsIGF5ICsgdDAgKiBkeV07XG4gIGlmICh0MSA8IDEpIGVkZ2VbMV0gPSBbYXggKyB0MSAqIGR4LCBheSArIHQxICogZHldO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29ubmVjdEVkZ2UoZWRnZSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIHYxID0gZWRnZVsxXTtcbiAgaWYgKHYxKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgdjAgPSBlZGdlWzBdLFxuICAgICAgbGVmdCA9IGVkZ2UubGVmdCxcbiAgICAgIHJpZ2h0ID0gZWRnZS5yaWdodCxcbiAgICAgIGx4ID0gbGVmdFswXSxcbiAgICAgIGx5ID0gbGVmdFsxXSxcbiAgICAgIHJ4ID0gcmlnaHRbMF0sXG4gICAgICByeSA9IHJpZ2h0WzFdLFxuICAgICAgZnggPSAobHggKyByeCkgLyAyLFxuICAgICAgZnkgPSAobHkgKyByeSkgLyAyLFxuICAgICAgZm0sXG4gICAgICBmYjtcblxuICBpZiAocnkgPT09IGx5KSB7XG4gICAgaWYgKGZ4IDwgeDAgfHwgZnggPj0geDEpIHJldHVybjtcbiAgICBpZiAobHggPiByeCkge1xuICAgICAgaWYgKCF2MCkgdjAgPSBbZngsIHkwXTtcbiAgICAgIGVsc2UgaWYgKHYwWzFdID49IHkxKSByZXR1cm47XG4gICAgICB2MSA9IFtmeCwgeTFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXYwKSB2MCA9IFtmeCwgeTFdO1xuICAgICAgZWxzZSBpZiAodjBbMV0gPCB5MCkgcmV0dXJuO1xuICAgICAgdjEgPSBbZngsIHkwXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm0gPSAobHggLSByeCkgLyAocnkgLSBseSk7XG4gICAgZmIgPSBmeSAtIGZtICogZng7XG4gICAgaWYgKGZtIDwgLTEgfHwgZm0gPiAxKSB7XG4gICAgICBpZiAobHggPiByeCkge1xuICAgICAgICBpZiAoIXYwKSB2MCA9IFsoeTAgLSBmYikgLyBmbSwgeTBdO1xuICAgICAgICBlbHNlIGlmICh2MFsxXSA+PSB5MSkgcmV0dXJuO1xuICAgICAgICB2MSA9IFsoeTEgLSBmYikgLyBmbSwgeTFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF2MCkgdjAgPSBbKHkxIC0gZmIpIC8gZm0sIHkxXTtcbiAgICAgICAgZWxzZSBpZiAodjBbMV0gPCB5MCkgcmV0dXJuO1xuICAgICAgICB2MSA9IFsoeTAgLSBmYikgLyBmbSwgeTBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobHkgPCByeSkge1xuICAgICAgICBpZiAoIXYwKSB2MCA9IFt4MCwgZm0gKiB4MCArIGZiXTtcbiAgICAgICAgZWxzZSBpZiAodjBbMF0gPj0geDEpIHJldHVybjtcbiAgICAgICAgdjEgPSBbeDEsIGZtICogeDEgKyBmYl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXYwKSB2MCA9IFt4MSwgZm0gKiB4MSArIGZiXTtcbiAgICAgICAgZWxzZSBpZiAodjBbMF0gPCB4MCkgcmV0dXJuO1xuICAgICAgICB2MSA9IFt4MCwgZm0gKiB4MCArIGZiXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlZGdlWzBdID0gdjA7XG4gIGVkZ2VbMV0gPSB2MTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGlwRWRnZXMoeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIGkgPSBlZGdlcy5sZW5ndGgsXG4gICAgICBlZGdlO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoIWNvbm5lY3RFZGdlKGVkZ2UgPSBlZGdlc1tpXSwgeDAsIHkwLCB4MSwgeTEpXG4gICAgICAgIHx8ICFjbGlwRWRnZShlZGdlLCB4MCwgeTAsIHgxLCB5MSlcbiAgICAgICAgfHwgIShNYXRoLmFicyhlZGdlWzBdWzBdIC0gZWRnZVsxXVswXSkgPiBlcHNpbG9uXG4gICAgICAgICAgICB8fCBNYXRoLmFicyhlZGdlWzBdWzFdIC0gZWRnZVsxXVsxXSkgPiBlcHNpbG9uKSkge1xuICAgICAgZGVsZXRlIGVkZ2VzW2ldO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtjcmVhdGVCb3JkZXJFZGdlfSBmcm9tIFwiLi9FZGdlXCI7XG5pbXBvcnQge2NlbGxzLCBlZGdlcywgZXBzaWxvbn0gZnJvbSBcIi4vRGlhZ3JhbVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2VsbChzaXRlKSB7XG4gIHJldHVybiBjZWxsc1tzaXRlLmluZGV4XSA9IHtcbiAgICBzaXRlOiBzaXRlLFxuICAgIGhhbGZlZGdlczogW11cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2VsbEhhbGZlZGdlQW5nbGUoY2VsbCwgZWRnZSkge1xuICB2YXIgc2l0ZSA9IGNlbGwuc2l0ZSxcbiAgICAgIHZhID0gZWRnZS5sZWZ0LFxuICAgICAgdmIgPSBlZGdlLnJpZ2h0O1xuICBpZiAoc2l0ZSA9PT0gdmIpIHZiID0gdmEsIHZhID0gc2l0ZTtcbiAgaWYgKHZiKSByZXR1cm4gTWF0aC5hdGFuMih2YlsxXSAtIHZhWzFdLCB2YlswXSAtIHZhWzBdKTtcbiAgaWYgKHNpdGUgPT09IHZhKSB2YSA9IGVkZ2VbMV0sIHZiID0gZWRnZVswXTtcbiAgZWxzZSB2YSA9IGVkZ2VbMF0sIHZiID0gZWRnZVsxXTtcbiAgcmV0dXJuIE1hdGguYXRhbjIodmFbMF0gLSB2YlswXSwgdmJbMV0gLSB2YVsxXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjZWxsSGFsZmVkZ2VTdGFydChjZWxsLCBlZGdlKSB7XG4gIHJldHVybiBlZGdlWysoZWRnZS5sZWZ0ICE9PSBjZWxsLnNpdGUpXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNlbGxIYWxmZWRnZUVuZChjZWxsLCBlZGdlKSB7XG4gIHJldHVybiBlZGdlWysoZWRnZS5sZWZ0ID09PSBjZWxsLnNpdGUpXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRDZWxsSGFsZmVkZ2VzKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGNlbGxzLmxlbmd0aCwgY2VsbCwgaGFsZmVkZ2VzLCBqLCBtOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKChjZWxsID0gY2VsbHNbaV0pICYmIChtID0gKGhhbGZlZGdlcyA9IGNlbGwuaGFsZmVkZ2VzKS5sZW5ndGgpKSB7XG4gICAgICB2YXIgaW5kZXggPSBuZXcgQXJyYXkobSksXG4gICAgICAgICAgYXJyYXkgPSBuZXcgQXJyYXkobSk7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSBpbmRleFtqXSA9IGosIGFycmF5W2pdID0gY2VsbEhhbGZlZGdlQW5nbGUoY2VsbCwgZWRnZXNbaGFsZmVkZ2VzW2pdXSk7XG4gICAgICBpbmRleC5zb3J0KGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIGFycmF5W2pdIC0gYXJyYXlbaV07IH0pO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgYXJyYXlbal0gPSBoYWxmZWRnZXNbaW5kZXhbal1dO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgaGFsZmVkZ2VzW2pdID0gYXJyYXlbal07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGlwQ2VsbHMoeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIG5DZWxscyA9IGNlbGxzLmxlbmd0aCxcbiAgICAgIGlDZWxsLFxuICAgICAgY2VsbCxcbiAgICAgIHNpdGUsXG4gICAgICBpSGFsZmVkZ2UsXG4gICAgICBoYWxmZWRnZXMsXG4gICAgICBuSGFsZmVkZ2VzLFxuICAgICAgc3RhcnQsXG4gICAgICBzdGFydFgsXG4gICAgICBzdGFydFksXG4gICAgICBlbmQsXG4gICAgICBlbmRYLFxuICAgICAgZW5kWSxcbiAgICAgIGNvdmVyID0gdHJ1ZTtcblxuICBmb3IgKGlDZWxsID0gMDsgaUNlbGwgPCBuQ2VsbHM7ICsraUNlbGwpIHtcbiAgICBpZiAoY2VsbCA9IGNlbGxzW2lDZWxsXSkge1xuICAgICAgc2l0ZSA9IGNlbGwuc2l0ZTtcbiAgICAgIGhhbGZlZGdlcyA9IGNlbGwuaGFsZmVkZ2VzO1xuICAgICAgaUhhbGZlZGdlID0gaGFsZmVkZ2VzLmxlbmd0aDtcblxuICAgICAgLy8gUmVtb3ZlIGFueSBkYW5nbGluZyBjbGlwcGVkIGVkZ2VzLlxuICAgICAgd2hpbGUgKGlIYWxmZWRnZS0tKSB7XG4gICAgICAgIGlmICghZWRnZXNbaGFsZmVkZ2VzW2lIYWxmZWRnZV1dKSB7XG4gICAgICAgICAgaGFsZmVkZ2VzLnNwbGljZShpSGFsZmVkZ2UsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEluc2VydCBhbnkgYm9yZGVyIGVkZ2VzIGFzIG5lY2Vzc2FyeS5cbiAgICAgIGlIYWxmZWRnZSA9IDAsIG5IYWxmZWRnZXMgPSBoYWxmZWRnZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGlIYWxmZWRnZSA8IG5IYWxmZWRnZXMpIHtcbiAgICAgICAgZW5kID0gY2VsbEhhbGZlZGdlRW5kKGNlbGwsIGVkZ2VzW2hhbGZlZGdlc1tpSGFsZmVkZ2VdXSksIGVuZFggPSBlbmRbMF0sIGVuZFkgPSBlbmRbMV07XG4gICAgICAgIHN0YXJ0ID0gY2VsbEhhbGZlZGdlU3RhcnQoY2VsbCwgZWRnZXNbaGFsZmVkZ2VzWysraUhhbGZlZGdlICUgbkhhbGZlZGdlc11dKSwgc3RhcnRYID0gc3RhcnRbMF0sIHN0YXJ0WSA9IHN0YXJ0WzFdO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZW5kWCAtIHN0YXJ0WCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKGVuZFkgLSBzdGFydFkpID4gZXBzaWxvbikge1xuICAgICAgICAgIGhhbGZlZGdlcy5zcGxpY2UoaUhhbGZlZGdlLCAwLCBlZGdlcy5wdXNoKGNyZWF0ZUJvcmRlckVkZ2Uoc2l0ZSwgZW5kLFxuICAgICAgICAgICAgICBNYXRoLmFicyhlbmRYIC0geDApIDwgZXBzaWxvbiAmJiB5MSAtIGVuZFkgPiBlcHNpbG9uID8gW3gwLCBNYXRoLmFicyhzdGFydFggLSB4MCkgPCBlcHNpbG9uID8gc3RhcnRZIDogeTFdXG4gICAgICAgICAgICAgIDogTWF0aC5hYnMoZW5kWSAtIHkxKSA8IGVwc2lsb24gJiYgeDEgLSBlbmRYID4gZXBzaWxvbiA/IFtNYXRoLmFicyhzdGFydFkgLSB5MSkgPCBlcHNpbG9uID8gc3RhcnRYIDogeDEsIHkxXVxuICAgICAgICAgICAgICA6IE1hdGguYWJzKGVuZFggLSB4MSkgPCBlcHNpbG9uICYmIGVuZFkgLSB5MCA+IGVwc2lsb24gPyBbeDEsIE1hdGguYWJzKHN0YXJ0WCAtIHgxKSA8IGVwc2lsb24gPyBzdGFydFkgOiB5MF1cbiAgICAgICAgICAgICAgOiBNYXRoLmFicyhlbmRZIC0geTApIDwgZXBzaWxvbiAmJiBlbmRYIC0geDAgPiBlcHNpbG9uID8gW01hdGguYWJzKHN0YXJ0WSAtIHkwKSA8IGVwc2lsb24gPyBzdGFydFggOiB4MCwgeTBdXG4gICAgICAgICAgICAgIDogbnVsbCkpIC0gMSk7XG4gICAgICAgICAgKytuSGFsZmVkZ2VzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuSGFsZmVkZ2VzKSBjb3ZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlIHdlcmVu4oCZdCBhbnkgZWRnZXMsIGhhdmUgdGhlIGNsb3Nlc3Qgc2l0ZSBjb3ZlciB0aGUgZXh0ZW50LlxuICAvLyBJdCBkb2VzbuKAmXQgbWF0dGVyIHdoaWNoIGNvcm5lciBvZiB0aGUgZXh0ZW50IHdlIG1lYXN1cmUhXG4gIGlmIChjb3Zlcikge1xuICAgIHZhciBkeCwgZHksIGQyLCBkYyA9IEluZmluaXR5O1xuXG4gICAgZm9yIChpQ2VsbCA9IDAsIGNvdmVyID0gbnVsbDsgaUNlbGwgPCBuQ2VsbHM7ICsraUNlbGwpIHtcbiAgICAgIGlmIChjZWxsID0gY2VsbHNbaUNlbGxdKSB7XG4gICAgICAgIHNpdGUgPSBjZWxsLnNpdGU7XG4gICAgICAgIGR4ID0gc2l0ZVswXSAtIHgwO1xuICAgICAgICBkeSA9IHNpdGVbMV0gLSB5MDtcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgaWYgKGQyIDwgZGMpIGRjID0gZDIsIGNvdmVyID0gY2VsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY292ZXIpIHtcbiAgICAgIHZhciB2MDAgPSBbeDAsIHkwXSwgdjAxID0gW3gwLCB5MV0sIHYxMSA9IFt4MSwgeTFdLCB2MTAgPSBbeDEsIHkwXTtcbiAgICAgIGNvdmVyLmhhbGZlZGdlcy5wdXNoKFxuICAgICAgICBlZGdlcy5wdXNoKGNyZWF0ZUJvcmRlckVkZ2Uoc2l0ZSA9IGNvdmVyLnNpdGUsIHYwMCwgdjAxKSkgLSAxLFxuICAgICAgICBlZGdlcy5wdXNoKGNyZWF0ZUJvcmRlckVkZ2Uoc2l0ZSwgdjAxLCB2MTEpKSAtIDEsXG4gICAgICAgIGVkZ2VzLnB1c2goY3JlYXRlQm9yZGVyRWRnZShzaXRlLCB2MTEsIHYxMCkpIC0gMSxcbiAgICAgICAgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUsIHYxMCwgdjAwKSkgLSAxXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIExhc3RseSBkZWxldGUgYW55IGNlbGxzIHdpdGggbm8gZWRnZXM7IHRoZXNlIHdlcmUgZW50aXJlbHkgY2xpcHBlZC5cbiAgZm9yIChpQ2VsbCA9IDA7IGlDZWxsIDwgbkNlbGxzOyArK2lDZWxsKSB7XG4gICAgaWYgKGNlbGwgPSBjZWxsc1tpQ2VsbF0pIHtcbiAgICAgIGlmICghY2VsbC5oYWxmZWRnZXMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSBjZWxsc1tpQ2VsbF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQge1JlZEJsYWNrTm9kZX0gZnJvbSBcIi4vUmVkQmxhY2tUcmVlXCI7XG5pbXBvcnQge2NpcmNsZXMsIGVwc2lsb24yfSBmcm9tIFwiLi9EaWFncmFtXCI7XG5cbnZhciBjaXJjbGVQb29sID0gW107XG5cbmV4cG9ydCB2YXIgZmlyc3RDaXJjbGU7XG5cbmZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgUmVkQmxhY2tOb2RlKHRoaXMpO1xuICB0aGlzLnggPVxuICB0aGlzLnkgPVxuICB0aGlzLmFyYyA9XG4gIHRoaXMuc2l0ZSA9XG4gIHRoaXMuY3kgPSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoQ2lyY2xlKGFyYykge1xuICB2YXIgbEFyYyA9IGFyYy5QLFxuICAgICAgckFyYyA9IGFyYy5OO1xuXG4gIGlmICghbEFyYyB8fCAhckFyYykgcmV0dXJuO1xuXG4gIHZhciBsU2l0ZSA9IGxBcmMuc2l0ZSxcbiAgICAgIGNTaXRlID0gYXJjLnNpdGUsXG4gICAgICByU2l0ZSA9IHJBcmMuc2l0ZTtcblxuICBpZiAobFNpdGUgPT09IHJTaXRlKSByZXR1cm47XG5cbiAgdmFyIGJ4ID0gY1NpdGVbMF0sXG4gICAgICBieSA9IGNTaXRlWzFdLFxuICAgICAgYXggPSBsU2l0ZVswXSAtIGJ4LFxuICAgICAgYXkgPSBsU2l0ZVsxXSAtIGJ5LFxuICAgICAgY3ggPSByU2l0ZVswXSAtIGJ4LFxuICAgICAgY3kgPSByU2l0ZVsxXSAtIGJ5O1xuXG4gIHZhciBkID0gMiAqIChheCAqIGN5IC0gYXkgKiBjeCk7XG4gIGlmIChkID49IC1lcHNpbG9uMikgcmV0dXJuO1xuXG4gIHZhciBoYSA9IGF4ICogYXggKyBheSAqIGF5LFxuICAgICAgaGMgPSBjeCAqIGN4ICsgY3kgKiBjeSxcbiAgICAgIHggPSAoY3kgKiBoYSAtIGF5ICogaGMpIC8gZCxcbiAgICAgIHkgPSAoYXggKiBoYyAtIGN4ICogaGEpIC8gZDtcblxuICB2YXIgY2lyY2xlID0gY2lyY2xlUG9vbC5wb3AoKSB8fCBuZXcgQ2lyY2xlO1xuICBjaXJjbGUuYXJjID0gYXJjO1xuICBjaXJjbGUuc2l0ZSA9IGNTaXRlO1xuICBjaXJjbGUueCA9IHggKyBieDtcbiAgY2lyY2xlLnkgPSAoY2lyY2xlLmN5ID0geSArIGJ5KSArIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTsgLy8geSBib3R0b21cblxuICBhcmMuY2lyY2xlID0gY2lyY2xlO1xuXG4gIHZhciBiZWZvcmUgPSBudWxsLFxuICAgICAgbm9kZSA9IGNpcmNsZXMuXztcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChjaXJjbGUueSA8IG5vZGUueSB8fCAoY2lyY2xlLnkgPT09IG5vZGUueSAmJiBjaXJjbGUueCA8PSBub2RlLngpKSB7XG4gICAgICBpZiAobm9kZS5MKSBub2RlID0gbm9kZS5MO1xuICAgICAgZWxzZSB7IGJlZm9yZSA9IG5vZGUuUDsgYnJlYWs7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5vZGUuUikgbm9kZSA9IG5vZGUuUjtcbiAgICAgIGVsc2UgeyBiZWZvcmUgPSBub2RlOyBicmVhazsgfVxuICAgIH1cbiAgfVxuXG4gIGNpcmNsZXMuaW5zZXJ0KGJlZm9yZSwgY2lyY2xlKTtcbiAgaWYgKCFiZWZvcmUpIGZpcnN0Q2lyY2xlID0gY2lyY2xlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoQ2lyY2xlKGFyYykge1xuICB2YXIgY2lyY2xlID0gYXJjLmNpcmNsZTtcbiAgaWYgKGNpcmNsZSkge1xuICAgIGlmICghY2lyY2xlLlApIGZpcnN0Q2lyY2xlID0gY2lyY2xlLk47XG4gICAgY2lyY2xlcy5yZW1vdmUoY2lyY2xlKTtcbiAgICBjaXJjbGVQb29sLnB1c2goY2lyY2xlKTtcbiAgICBSZWRCbGFja05vZGUoY2lyY2xlKTtcbiAgICBhcmMuY2lyY2xlID0gbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IHtSZWRCbGFja05vZGV9IGZyb20gXCIuL1JlZEJsYWNrVHJlZVwiO1xuaW1wb3J0IHtjcmVhdGVDZWxsfSBmcm9tIFwiLi9DZWxsXCI7XG5pbXBvcnQge2F0dGFjaENpcmNsZSwgZGV0YWNoQ2lyY2xlfSBmcm9tIFwiLi9DaXJjbGVcIjtcbmltcG9ydCB7Y3JlYXRlRWRnZSwgc2V0RWRnZUVuZH0gZnJvbSBcIi4vRWRnZVwiO1xuaW1wb3J0IHtiZWFjaGVzLCBlcHNpbG9ufSBmcm9tIFwiLi9EaWFncmFtXCI7XG5cbnZhciBiZWFjaFBvb2wgPSBbXTtcblxuZnVuY3Rpb24gQmVhY2goKSB7XG4gIFJlZEJsYWNrTm9kZSh0aGlzKTtcbiAgdGhpcy5lZGdlID1cbiAgdGhpcy5zaXRlID1cbiAgdGhpcy5jaXJjbGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCZWFjaChzaXRlKSB7XG4gIHZhciBiZWFjaCA9IGJlYWNoUG9vbC5wb3AoKSB8fCBuZXcgQmVhY2g7XG4gIGJlYWNoLnNpdGUgPSBzaXRlO1xuICByZXR1cm4gYmVhY2g7XG59XG5cbmZ1bmN0aW9uIGRldGFjaEJlYWNoKGJlYWNoKSB7XG4gIGRldGFjaENpcmNsZShiZWFjaCk7XG4gIGJlYWNoZXMucmVtb3ZlKGJlYWNoKTtcbiAgYmVhY2hQb29sLnB1c2goYmVhY2gpO1xuICBSZWRCbGFja05vZGUoYmVhY2gpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQmVhY2goYmVhY2gpIHtcbiAgdmFyIGNpcmNsZSA9IGJlYWNoLmNpcmNsZSxcbiAgICAgIHggPSBjaXJjbGUueCxcbiAgICAgIHkgPSBjaXJjbGUuY3ksXG4gICAgICB2ZXJ0ZXggPSBbeCwgeV0sXG4gICAgICBwcmV2aW91cyA9IGJlYWNoLlAsXG4gICAgICBuZXh0ID0gYmVhY2guTixcbiAgICAgIGRpc2FwcGVhcmluZyA9IFtiZWFjaF07XG5cbiAgZGV0YWNoQmVhY2goYmVhY2gpO1xuXG4gIHZhciBsQXJjID0gcHJldmlvdXM7XG4gIHdoaWxlIChsQXJjLmNpcmNsZVxuICAgICAgJiYgTWF0aC5hYnMoeCAtIGxBcmMuY2lyY2xlLngpIDwgZXBzaWxvblxuICAgICAgJiYgTWF0aC5hYnMoeSAtIGxBcmMuY2lyY2xlLmN5KSA8IGVwc2lsb24pIHtcbiAgICBwcmV2aW91cyA9IGxBcmMuUDtcbiAgICBkaXNhcHBlYXJpbmcudW5zaGlmdChsQXJjKTtcbiAgICBkZXRhY2hCZWFjaChsQXJjKTtcbiAgICBsQXJjID0gcHJldmlvdXM7XG4gIH1cblxuICBkaXNhcHBlYXJpbmcudW5zaGlmdChsQXJjKTtcbiAgZGV0YWNoQ2lyY2xlKGxBcmMpO1xuXG4gIHZhciByQXJjID0gbmV4dDtcbiAgd2hpbGUgKHJBcmMuY2lyY2xlXG4gICAgICAmJiBNYXRoLmFicyh4IC0gckFyYy5jaXJjbGUueCkgPCBlcHNpbG9uXG4gICAgICAmJiBNYXRoLmFicyh5IC0gckFyYy5jaXJjbGUuY3kpIDwgZXBzaWxvbikge1xuICAgIG5leHQgPSByQXJjLk47XG4gICAgZGlzYXBwZWFyaW5nLnB1c2gockFyYyk7XG4gICAgZGV0YWNoQmVhY2gockFyYyk7XG4gICAgckFyYyA9IG5leHQ7XG4gIH1cblxuICBkaXNhcHBlYXJpbmcucHVzaChyQXJjKTtcbiAgZGV0YWNoQ2lyY2xlKHJBcmMpO1xuXG4gIHZhciBuQXJjcyA9IGRpc2FwcGVhcmluZy5sZW5ndGgsXG4gICAgICBpQXJjO1xuICBmb3IgKGlBcmMgPSAxOyBpQXJjIDwgbkFyY3M7ICsraUFyYykge1xuICAgIHJBcmMgPSBkaXNhcHBlYXJpbmdbaUFyY107XG4gICAgbEFyYyA9IGRpc2FwcGVhcmluZ1tpQXJjIC0gMV07XG4gICAgc2V0RWRnZUVuZChyQXJjLmVkZ2UsIGxBcmMuc2l0ZSwgckFyYy5zaXRlLCB2ZXJ0ZXgpO1xuICB9XG5cbiAgbEFyYyA9IGRpc2FwcGVhcmluZ1swXTtcbiAgckFyYyA9IGRpc2FwcGVhcmluZ1tuQXJjcyAtIDFdO1xuICByQXJjLmVkZ2UgPSBjcmVhdGVFZGdlKGxBcmMuc2l0ZSwgckFyYy5zaXRlLCBudWxsLCB2ZXJ0ZXgpO1xuXG4gIGF0dGFjaENpcmNsZShsQXJjKTtcbiAgYXR0YWNoQ2lyY2xlKHJBcmMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQmVhY2goc2l0ZSkge1xuICB2YXIgeCA9IHNpdGVbMF0sXG4gICAgICBkaXJlY3RyaXggPSBzaXRlWzFdLFxuICAgICAgbEFyYyxcbiAgICAgIHJBcmMsXG4gICAgICBkeGwsXG4gICAgICBkeHIsXG4gICAgICBub2RlID0gYmVhY2hlcy5fO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgZHhsID0gbGVmdEJyZWFrUG9pbnQobm9kZSwgZGlyZWN0cml4KSAtIHg7XG4gICAgaWYgKGR4bCA+IGVwc2lsb24pIG5vZGUgPSBub2RlLkw7IGVsc2Uge1xuICAgICAgZHhyID0geCAtIHJpZ2h0QnJlYWtQb2ludChub2RlLCBkaXJlY3RyaXgpO1xuICAgICAgaWYgKGR4ciA+IGVwc2lsb24pIHtcbiAgICAgICAgaWYgKCFub2RlLlIpIHtcbiAgICAgICAgICBsQXJjID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5SO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGR4bCA+IC1lcHNpbG9uKSB7XG4gICAgICAgICAgbEFyYyA9IG5vZGUuUDtcbiAgICAgICAgICByQXJjID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChkeHIgPiAtZXBzaWxvbikge1xuICAgICAgICAgIGxBcmMgPSBub2RlO1xuICAgICAgICAgIHJBcmMgPSBub2RlLk47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbEFyYyA9IHJBcmMgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUNlbGwoc2l0ZSk7XG4gIHZhciBuZXdBcmMgPSBjcmVhdGVCZWFjaChzaXRlKTtcbiAgYmVhY2hlcy5pbnNlcnQobEFyYywgbmV3QXJjKTtcblxuICBpZiAoIWxBcmMgJiYgIXJBcmMpIHJldHVybjtcblxuICBpZiAobEFyYyA9PT0gckFyYykge1xuICAgIGRldGFjaENpcmNsZShsQXJjKTtcbiAgICByQXJjID0gY3JlYXRlQmVhY2gobEFyYy5zaXRlKTtcbiAgICBiZWFjaGVzLmluc2VydChuZXdBcmMsIHJBcmMpO1xuICAgIG5ld0FyYy5lZGdlID0gckFyYy5lZGdlID0gY3JlYXRlRWRnZShsQXJjLnNpdGUsIG5ld0FyYy5zaXRlKTtcbiAgICBhdHRhY2hDaXJjbGUobEFyYyk7XG4gICAgYXR0YWNoQ2lyY2xlKHJBcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghckFyYykgeyAvLyAmJiBsQXJjXG4gICAgbmV3QXJjLmVkZ2UgPSBjcmVhdGVFZGdlKGxBcmMuc2l0ZSwgbmV3QXJjLnNpdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVsc2UgbEFyYyAhPT0gckFyY1xuICBkZXRhY2hDaXJjbGUobEFyYyk7XG4gIGRldGFjaENpcmNsZShyQXJjKTtcblxuICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsXG4gICAgICBheCA9IGxTaXRlWzBdLFxuICAgICAgYXkgPSBsU2l0ZVsxXSxcbiAgICAgIGJ4ID0gc2l0ZVswXSAtIGF4LFxuICAgICAgYnkgPSBzaXRlWzFdIC0gYXksXG4gICAgICByU2l0ZSA9IHJBcmMuc2l0ZSxcbiAgICAgIGN4ID0gclNpdGVbMF0gLSBheCxcbiAgICAgIGN5ID0gclNpdGVbMV0gLSBheSxcbiAgICAgIGQgPSAyICogKGJ4ICogY3kgLSBieSAqIGN4KSxcbiAgICAgIGhiID0gYnggKiBieCArIGJ5ICogYnksXG4gICAgICBoYyA9IGN4ICogY3ggKyBjeSAqIGN5LFxuICAgICAgdmVydGV4ID0gWyhjeSAqIGhiIC0gYnkgKiBoYykgLyBkICsgYXgsIChieCAqIGhjIC0gY3ggKiBoYikgLyBkICsgYXldO1xuXG4gIHNldEVkZ2VFbmQockFyYy5lZGdlLCBsU2l0ZSwgclNpdGUsIHZlcnRleCk7XG4gIG5ld0FyYy5lZGdlID0gY3JlYXRlRWRnZShsU2l0ZSwgc2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgckFyYy5lZGdlID0gY3JlYXRlRWRnZShzaXRlLCByU2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgYXR0YWNoQ2lyY2xlKGxBcmMpO1xuICBhdHRhY2hDaXJjbGUockFyYyk7XG59XG5cbmZ1bmN0aW9uIGxlZnRCcmVha1BvaW50KGFyYywgZGlyZWN0cml4KSB7XG4gIHZhciBzaXRlID0gYXJjLnNpdGUsXG4gICAgICByZm9jeCA9IHNpdGVbMF0sXG4gICAgICByZm9jeSA9IHNpdGVbMV0sXG4gICAgICBwYnkyID0gcmZvY3kgLSBkaXJlY3RyaXg7XG5cbiAgaWYgKCFwYnkyKSByZXR1cm4gcmZvY3g7XG5cbiAgdmFyIGxBcmMgPSBhcmMuUDtcbiAgaWYgKCFsQXJjKSByZXR1cm4gLUluZmluaXR5O1xuXG4gIHNpdGUgPSBsQXJjLnNpdGU7XG4gIHZhciBsZm9jeCA9IHNpdGVbMF0sXG4gICAgICBsZm9jeSA9IHNpdGVbMV0sXG4gICAgICBwbGJ5MiA9IGxmb2N5IC0gZGlyZWN0cml4O1xuXG4gIGlmICghcGxieTIpIHJldHVybiBsZm9jeDtcblxuICB2YXIgaGwgPSBsZm9jeCAtIHJmb2N4LFxuICAgICAgYWJ5MiA9IDEgLyBwYnkyIC0gMSAvIHBsYnkyLFxuICAgICAgYiA9IGhsIC8gcGxieTI7XG5cbiAgaWYgKGFieTIpIHJldHVybiAoLWIgKyBNYXRoLnNxcnQoYiAqIGIgLSAyICogYWJ5MiAqIChobCAqIGhsIC8gKC0yICogcGxieTIpIC0gbGZvY3kgKyBwbGJ5MiAvIDIgKyByZm9jeSAtIHBieTIgLyAyKSkpIC8gYWJ5MiArIHJmb2N4O1xuXG4gIHJldHVybiAocmZvY3ggKyBsZm9jeCkgLyAyO1xufVxuXG5mdW5jdGlvbiByaWdodEJyZWFrUG9pbnQoYXJjLCBkaXJlY3RyaXgpIHtcbiAgdmFyIHJBcmMgPSBhcmMuTjtcbiAgaWYgKHJBcmMpIHJldHVybiBsZWZ0QnJlYWtQb2ludChyQXJjLCBkaXJlY3RyaXgpO1xuICB2YXIgc2l0ZSA9IGFyYy5zaXRlO1xuICByZXR1cm4gc2l0ZVsxXSA9PT0gZGlyZWN0cml4ID8gc2l0ZVswXSA6IEluZmluaXR5O1xufVxuIiwiaW1wb3J0IHthZGRCZWFjaCwgcmVtb3ZlQmVhY2h9IGZyb20gXCIuL0JlYWNoXCI7XG5pbXBvcnQge3NvcnRDZWxsSGFsZmVkZ2VzLCBjZWxsSGFsZmVkZ2VTdGFydCwgY2xpcENlbGxzfSBmcm9tIFwiLi9DZWxsXCI7XG5pbXBvcnQge2ZpcnN0Q2lyY2xlfSBmcm9tIFwiLi9DaXJjbGVcIjtcbmltcG9ydCB7Y2xpcEVkZ2VzfSBmcm9tIFwiLi9FZGdlXCI7XG5pbXBvcnQgUmVkQmxhY2tUcmVlIGZyb20gXCIuL1JlZEJsYWNrVHJlZVwiO1xuXG5leHBvcnQgdmFyIGVwc2lsb24gPSAxZS02O1xuZXhwb3J0IHZhciBlcHNpbG9uMiA9IDFlLTEyO1xuZXhwb3J0IHZhciBiZWFjaGVzO1xuZXhwb3J0IHZhciBjZWxscztcbmV4cG9ydCB2YXIgY2lyY2xlcztcbmV4cG9ydCB2YXIgZWRnZXM7XG5cbmZ1bmN0aW9uIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSB7XG4gIHJldHVybiAoYVswXSAtIGNbMF0pICogKGJbMV0gLSBhWzFdKSAtIChhWzBdIC0gYlswXSkgKiAoY1sxXSAtIGFbMV0pO1xufVxuXG5mdW5jdGlvbiBsZXhpY29ncmFwaGljKGEsIGIpIHtcbiAgcmV0dXJuIGJbMV0gLSBhWzFdXG4gICAgICB8fCBiWzBdIC0gYVswXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGlhZ3JhbShzaXRlcywgZXh0ZW50KSB7XG4gIHZhciBzaXRlID0gc2l0ZXMuc29ydChsZXhpY29ncmFwaGljKS5wb3AoKSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgY2lyY2xlO1xuXG4gIGVkZ2VzID0gW107XG4gIGNlbGxzID0gbmV3IEFycmF5KHNpdGVzLmxlbmd0aCk7XG4gIGJlYWNoZXMgPSBuZXcgUmVkQmxhY2tUcmVlO1xuICBjaXJjbGVzID0gbmV3IFJlZEJsYWNrVHJlZTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNpcmNsZSA9IGZpcnN0Q2lyY2xlO1xuICAgIGlmIChzaXRlICYmICghY2lyY2xlIHx8IHNpdGVbMV0gPCBjaXJjbGUueSB8fCAoc2l0ZVsxXSA9PT0gY2lyY2xlLnkgJiYgc2l0ZVswXSA8IGNpcmNsZS54KSkpIHtcbiAgICAgIGlmIChzaXRlWzBdICE9PSB4IHx8IHNpdGVbMV0gIT09IHkpIHtcbiAgICAgICAgYWRkQmVhY2goc2l0ZSk7XG4gICAgICAgIHggPSBzaXRlWzBdLCB5ID0gc2l0ZVsxXTtcbiAgICAgIH1cbiAgICAgIHNpdGUgPSBzaXRlcy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKGNpcmNsZSkge1xuICAgICAgcmVtb3ZlQmVhY2goY2lyY2xlLmFyYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNvcnRDZWxsSGFsZmVkZ2VzKCk7XG5cbiAgaWYgKGV4dGVudCkge1xuICAgIHZhciB4MCA9ICtleHRlbnRbMF1bMF0sXG4gICAgICAgIHkwID0gK2V4dGVudFswXVsxXSxcbiAgICAgICAgeDEgPSArZXh0ZW50WzFdWzBdLFxuICAgICAgICB5MSA9ICtleHRlbnRbMV1bMV07XG4gICAgY2xpcEVkZ2VzKHgwLCB5MCwgeDEsIHkxKTtcbiAgICBjbGlwQ2VsbHMoeDAsIHkwLCB4MSwgeTEpO1xuICB9XG5cbiAgdGhpcy5lZGdlcyA9IGVkZ2VzO1xuICB0aGlzLmNlbGxzID0gY2VsbHM7XG5cbiAgYmVhY2hlcyA9XG4gIGNpcmNsZXMgPVxuICBlZGdlcyA9XG4gIGNlbGxzID0gbnVsbDtcbn1cblxuRGlhZ3JhbS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaWFncmFtLFxuXG4gIHBvbHlnb25zOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzO1xuXG4gICAgcmV0dXJuIHRoaXMuY2VsbHMubWFwKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgIHZhciBwb2x5Z29uID0gY2VsbC5oYWxmZWRnZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGNlbGxIYWxmZWRnZVN0YXJ0KGNlbGwsIGVkZ2VzW2ldKTsgfSk7XG4gICAgICBwb2x5Z29uLmRhdGEgPSBjZWxsLnNpdGUuZGF0YTtcbiAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgIH0pO1xuICB9LFxuXG4gIHRyaWFuZ2xlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyaWFuZ2xlcyA9IFtdLFxuICAgICAgICBlZGdlcyA9IHRoaXMuZWRnZXM7XG5cbiAgICB0aGlzLmNlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCwgaSkge1xuICAgICAgaWYgKCEobSA9IChoYWxmZWRnZXMgPSBjZWxsLmhhbGZlZGdlcykubGVuZ3RoKSkgcmV0dXJuO1xuICAgICAgdmFyIHNpdGUgPSBjZWxsLnNpdGUsXG4gICAgICAgICAgaGFsZmVkZ2VzLFxuICAgICAgICAgIGogPSAtMSxcbiAgICAgICAgICBtLFxuICAgICAgICAgIHMwLFxuICAgICAgICAgIGUxID0gZWRnZXNbaGFsZmVkZ2VzW20gLSAxXV0sXG4gICAgICAgICAgczEgPSBlMS5sZWZ0ID09PSBzaXRlID8gZTEucmlnaHQgOiBlMS5sZWZ0O1xuXG4gICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgICBlMSA9IGVkZ2VzW2hhbGZlZGdlc1tqXV07XG4gICAgICAgIHMxID0gZTEubGVmdCA9PT0gc2l0ZSA/IGUxLnJpZ2h0IDogZTEubGVmdDtcbiAgICAgICAgaWYgKHMwICYmIHMxICYmIGkgPCBzMC5pbmRleCAmJiBpIDwgczEuaW5kZXggJiYgdHJpYW5nbGVBcmVhKHNpdGUsIHMwLCBzMSkgPCAwKSB7XG4gICAgICAgICAgdHJpYW5nbGVzLnB1c2goW3NpdGUuZGF0YSwgczAuZGF0YSwgczEuZGF0YV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xuICB9LFxuXG4gIGxpbmtzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlcy5maWx0ZXIoZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UucmlnaHQ7XG4gICAgfSkubWFwKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogZWRnZS5sZWZ0LmRhdGEsXG4gICAgICAgIHRhcmdldDogZWRnZS5yaWdodC5kYXRhXG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuXG4gIGZpbmQ6IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuICAgIHZhciB0aGF0ID0gdGhpcywgaTAsIGkxID0gdGhhdC5fZm91bmQgfHwgMCwgbiA9IHRoYXQuY2VsbHMubGVuZ3RoLCBjZWxsO1xuXG4gICAgLy8gVXNlIHRoZSBwcmV2aW91c2x5LWZvdW5kIGNlbGwsIG9yIHN0YXJ0IHdpdGggYW4gYXJiaXRyYXJ5IG9uZS5cbiAgICB3aGlsZSAoIShjZWxsID0gdGhhdC5jZWxsc1tpMV0pKSBpZiAoKytpMSA+PSBuKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgZHggPSB4IC0gY2VsbC5zaXRlWzBdLCBkeSA9IHkgLSBjZWxsLnNpdGVbMV0sIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICAvLyBUcmF2ZXJzZSB0aGUgaGFsZi1lZGdlcyB0byBmaW5kIGEgY2xvc2VyIGNlbGwsIGlmIGFueS5cbiAgICBkbyB7XG4gICAgICBjZWxsID0gdGhhdC5jZWxsc1tpMCA9IGkxXSwgaTEgPSBudWxsO1xuICAgICAgY2VsbC5oYWxmZWRnZXMuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBlZGdlID0gdGhhdC5lZGdlc1tlXSwgdiA9IGVkZ2UubGVmdDtcbiAgICAgICAgaWYgKCh2ID09PSBjZWxsLnNpdGUgfHwgIXYpICYmICEodiA9IGVkZ2UucmlnaHQpKSByZXR1cm47XG4gICAgICAgIHZhciB2eCA9IHggLSB2WzBdLCB2eSA9IHkgLSB2WzFdLCB2MiA9IHZ4ICogdnggKyB2eSAqIHZ5O1xuICAgICAgICBpZiAodjIgPCBkMikgZDIgPSB2MiwgaTEgPSB2LmluZGV4O1xuICAgICAgfSk7XG4gICAgfSB3aGlsZSAoaTEgIT09IG51bGwpO1xuXG4gICAgdGhhdC5fZm91bmQgPSBpMDtcblxuICAgIHJldHVybiByYWRpdXMgPT0gbnVsbCB8fCBkMiA8PSByYWRpdXMgKiByYWRpdXMgPyBjZWxsLnNpdGUgOiBudWxsO1xuICB9XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcbmltcG9ydCB7eCBhcyBwb2ludFgsIHkgYXMgcG9pbnRZfSBmcm9tIFwiLi9wb2ludFwiO1xuaW1wb3J0IERpYWdyYW0sIHtlcHNpbG9ufSBmcm9tIFwiLi9EaWFncmFtXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgeCA9IHBvaW50WCxcbiAgICAgIHkgPSBwb2ludFksXG4gICAgICBleHRlbnQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHZvcm9ub2koZGF0YSkge1xuICAgIHJldHVybiBuZXcgRGlhZ3JhbShkYXRhLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgICB2YXIgcyA9IFtNYXRoLnJvdW5kKHgoZCwgaSwgZGF0YSkgLyBlcHNpbG9uKSAqIGVwc2lsb24sIE1hdGgucm91bmQoeShkLCBpLCBkYXRhKSAvIGVwc2lsb24pICogZXBzaWxvbl07XG4gICAgICBzLmluZGV4ID0gaTtcbiAgICAgIHMuZGF0YSA9IGQ7XG4gICAgICByZXR1cm4gcztcbiAgICB9KSwgZXh0ZW50KTtcbiAgfVxuXG4gIHZvcm9ub2kucG9seWdvbnMgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIHZvcm9ub2koZGF0YSkucG9seWdvbnMoKTtcbiAgfTtcblxuICB2b3Jvbm9pLmxpbmtzID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiB2b3Jvbm9pKGRhdGEpLmxpbmtzKCk7XG4gIH07XG5cbiAgdm9yb25vaS50cmlhbmdsZXMgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIHZvcm9ub2koZGF0YSkudHJpYW5nbGVzKCk7XG4gIH07XG5cbiAgdm9yb25vaS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgdm9yb25vaSkgOiB4O1xuICB9O1xuXG4gIHZvcm9ub2kueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHZvcm9ub2kpIDogeTtcbiAgfTtcblxuICB2b3Jvbm9pLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSBfID09IG51bGwgPyBudWxsIDogW1srX1swXVswXSwgK19bMF1bMV1dLCBbK19bMV1bMF0sICtfWzFdWzFdXV0sIHZvcm9ub2kpIDogZXh0ZW50ICYmIFtbZXh0ZW50WzBdWzBdLCBleHRlbnRbMF1bMV1dLCBbZXh0ZW50WzFdWzBdLCBleHRlbnRbMV1bMV1dXTtcbiAgfTtcblxuICB2b3Jvbm9pLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXh0ZW50ID0gXyA9PSBudWxsID8gbnVsbCA6IFtbMCwgMF0sIFsrX1swXSwgK19bMV1dXSwgdm9yb25vaSkgOiBleHRlbnQgJiYgW2V4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSwgZXh0ZW50WzFdWzFdIC0gZXh0ZW50WzBdWzFdXTtcbiAgfTtcblxuICByZXR1cm4gdm9yb25vaTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyB2b3Jvbm9pfSBmcm9tIFwiLi92b3Jvbm9pXCI7XG4iLCJpbXBvcnQgeyB2b3Jvbm9pIH0gZnJvbSAnZDMtdm9yb25vaSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcblxuLy8gcmV0dXJucyBhIGQzIHZvcm9ub2kgKmxheW91dCosIGZvciBhIHZvcm9ub2kgKmRpYWdyYW0qIGNhbGwgYGxheW91dChkYXRhKWBcblxudmFyIHZvcm9ub2kkMSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgX3JlZiR3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICB3aWR0aCA9IF9yZWYkd2lkdGggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHdpZHRoLFxuICAgICAgX3JlZiRoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgIGhlaWdodCA9IF9yZWYkaGVpZ2h0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRoZWlnaHQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICB2YXIgdm9yb25vaSQkMSA9IHZvcm9ub2koKTtcblxuICBpZiAoeCkgdm9yb25vaSQkMS54KHgpO1xuICBpZiAoeSkgdm9yb25vaSQkMS55KHkpO1xuXG4gIHZvcm9ub2kkJDEuZXh0ZW50KFtbLTEsIC0xXSwgW3dpZHRoICsgMSwgaGVpZ2h0ICsgMV1dKTtcblxuICByZXR1cm4gdm9yb25vaSQkMTtcbn0pO1xuXG5mdW5jdGlvbiBjYWxsT3JWYWx1ZShtYXliZUZuLCBkYXRhKSB7XG4gIGlmICh0eXBlb2YgbWF5YmVGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUZuKGRhdGEpO1xuICB9XG4gIHJldHVybiBtYXliZUZuO1xufVxuXG5mdW5jdGlvbiBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhyZXN0UHJvcHMpLnJlZHVjZShmdW5jdGlvbiAocmV0LCBjdXIpIHtcbiAgICByZXRbY3VyXSA9IGNhbGxPclZhbHVlKHJlc3RQcm9wc1tjdXJdLCBkYXRhKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LCB7fSk7XG59XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIHBvbHlnb246IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5hcnJheSlcbn07XG5cbmZ1bmN0aW9uIFZvcm9ub2lQb2x5Z29uKF9yZWYpIHtcbiAgdmFyIHBvbHlnb24gPSBfcmVmLnBvbHlnb24sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsncG9seWdvbicsICdjbGFzc05hbWUnXSk7XG5cbiAgaWYgKCFwb2x5Z29uKSByZXR1cm4gbnVsbDtcbiAgdmFyIGRhdGEgPSBwb2x5Z29uLmRhdGE7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY3goJ3Z4LXZvcm9ub2ktcG9seWdvbicsIGNsYXNzTmFtZSksXG4gICAgZDogJ00nICsgcG9seWdvbi5qb2luKCdMJykgKyAnWidcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuVm9yb25vaVBvbHlnb24ucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuXG5leHBvcnQgeyB2b3Jvbm9pJDEgYXMgdm9yb25vaSwgVm9yb25vaVBvbHlnb24gfTtcbiIsImZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKiBlc2xpbnQgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5OiAwLCByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlczogMCAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBHcm91cCB9IGZyb20gJ0B2eC9ncm91cCc7XG5pbXBvcnQgeyBWb3Jvbm9pUG9seWdvbiwgdm9yb25vaSBhcyB2b3Jvbm9pTGF5b3V0IH0gZnJvbSAnQHZ4L3Zvcm9ub2knO1xudmFyIHByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9iamVjdCkuaXNSZXF1aXJlZCxcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTW91c2VNb3ZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZURvd246IFByb3BUeXBlcy5mdW5jLFxuICBzaG93Vm9yb25vaTogUHJvcFR5cGVzLmJvb2wsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICB4OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59O1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgb25DbGljazogbnVsbCxcbiAgb25Nb3VzZU1vdmU6IG51bGwsXG4gIG9uTW91c2VMZWF2ZTogbnVsbCxcbiAgb25Nb3VzZURvd246IG51bGwsXG4gIHNob3dWb3Jvbm9pOiBmYWxzZVxufTtcblxudmFyIFZvcm9ub2kgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRQdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFZvcm9ub2ksIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcblxuICBWb3Jvbm9pLmdldFZvcm9ub2kgPSBmdW5jdGlvbiBnZXRWb3Jvbm9pKHByb3BzKSB7XG4gICAgdmFyIHggPSBwcm9wcy54LFxuICAgICAgICB5ID0gcHJvcHMueSxcbiAgICAgICAgZGF0YSA9IHByb3BzLmRhdGEsXG4gICAgICAgIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodDtcbiAgICByZXR1cm4gdm9yb25vaUxheW91dCh7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfSkoZGF0YSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gVm9yb25vaShwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JFB1cmVDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHZvcm9ub2k6IFZvcm9ub2kuZ2V0Vm9yb25vaShwcm9wcylcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBWb3Jvbm9pLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAoWydkYXRhJywgJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnXS5zb21lKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLnByb3BzW3Byb3BdICE9PSBuZXh0UHJvcHNbcHJvcF07XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L2Rlc3RydWN0dXJpbmctYXNzaWdubWVudFxuICAgICkpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB2b3Jvbm9pOiBWb3Jvbm9pLmdldFZvcm9ub2kobmV4dFByb3BzKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgb25Nb3VzZUxlYXZlID0gX3RoaXMkcHJvcHMub25Nb3VzZUxlYXZlLFxuICAgICAgICBvbk1vdXNlTW92ZSA9IF90aGlzJHByb3BzLm9uTW91c2VNb3ZlLFxuICAgICAgICBvbkNsaWNrID0gX3RoaXMkcHJvcHMub25DbGljayxcbiAgICAgICAgc2hvd1Zvcm9ub2kgPSBfdGhpcyRwcm9wcy5zaG93Vm9yb25vaSxcbiAgICAgICAgb25Nb3VzZURvd24gPSBfdGhpcyRwcm9wcy5vbk1vdXNlRG93bjtcbiAgICB2YXIgdm9yb25vaSA9IHRoaXMuc3RhdGUudm9yb25vaTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChHcm91cCwgbnVsbCwgdm9yb25vaS5wb2x5Z29ucygpLm1hcChmdW5jdGlvbiAocG9seWdvbiwgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVm9yb25vaVBvbHlnb24sIHtcbiAgICAgICAga2V5OiBcInZvcm9ub2ktXCIgKyBwb2x5Z29uLmxlbmd0aCArIFwiLVwiICsgaSxcbiAgICAgICAgcG9seWdvbjogcG9seWdvbixcbiAgICAgICAgZmlsbDogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICBzdHJva2U6IHNob3dWb3Jvbm9pID8gJyNkZGQnIDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIG9uQ2xpY2s6IG9uQ2xpY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIG9uQ2xpY2soe1xuICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgIGRhdHVtOiBwb2x5Z29uLmRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VNb3ZlOiBvbk1vdXNlTW92ZSAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgb25Nb3VzZU1vdmUoe1xuICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgIGRhdHVtOiBwb2x5Z29uLmRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VMZWF2ZTogb25Nb3VzZUxlYXZlICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gb25Nb3VzZUxlYXZlO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRG93bjogb25Nb3VzZURvd24gJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBvbk1vdXNlRG93bjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBWb3Jvbm9pO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KTtcblxuVm9yb25vaS5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5Wb3Jvbm9pLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblZvcm9ub2kuZGlzcGxheU5hbWUgPSAnVm9yb25vaSc7XG5leHBvcnQgZGVmYXVsdCBWb3Jvbm9pOyIsImltcG9ydCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29tcG9uZW50TmFtZSwgaXNTZXJpZXMgfSBmcm9tICcuL2NoYXJ0VXRpbHMnO1xuaW1wb3J0IEFyZWFEaWZmZXJlbmNlU2VyaWVzIGZyb20gJy4uL3Nlcmllcy9BcmVhRGlmZmVyZW5jZVNlcmllcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb2xsZWN0RGF0YUZyb21DaGlsZFNlcmllcyhjaGlsZHJlbikge1xuICB2YXIgYWxsRGF0YSA9IFtdO1xuICBDaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoQ2hpbGQpIHtcbiAgICBpZiAoQ2hpbGQgJiYgQ2hpbGQucHJvcHMpIHtcbiAgICAgIHZhciBkYXRhID0gQ2hpbGQucHJvcHMuZGF0YTtcbiAgICAgIHZhciBuYW1lID0gY29tcG9uZW50TmFtZShDaGlsZCk7XG5cbiAgICAgIGlmIChuYW1lID09PSBBcmVhRGlmZmVyZW5jZVNlcmllcy5kaXNwbGF5TmFtZSkge1xuICAgICAgICBhbGxEYXRhID0gYWxsRGF0YS5jb25jYXQoY29sbGVjdERhdGFGcm9tQ2hpbGRTZXJpZXMoQ2hpbGQucHJvcHMuY2hpbGRyZW4pKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSAmJiBpc1NlcmllcyhuYW1lKSkge1xuICAgICAgICBhbGxEYXRhID0gYWxsRGF0YS5jb25jYXQoQ2hpbGQucHJvcHMuZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFsbERhdGE7XG59IiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuaW1wb3J0IHsgREVGQVVMVF9DSEFSVF9NQVJHSU4gfSBmcm9tICcuL2NoYXJ0VXRpbHMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q2hhcnREaW1lbnNpb25zKF9yZWYpIHtcbiAgdmFyIG1hcmdpbiA9IF9yZWYubWFyZ2luLFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgdmFyIGNvbXBsZXRlTWFyZ2luID0gX2V4dGVuZHMoe30sIERFRkFVTFRfQ0hBUlRfTUFSR0lOLCBtYXJnaW4pO1xuXG4gIHJldHVybiB7XG4gICAgbWFyZ2luOiBjb21wbGV0ZU1hcmdpbixcbiAgICBpbm5lckhlaWdodDogTWF0aC5tYXgoMCwgaGVpZ2h0IC0gY29tcGxldGVNYXJnaW4udG9wIC0gY29tcGxldGVNYXJnaW4uYm90dG9tKSxcbiAgICBpbm5lcldpZHRoOiBNYXRoLm1heCgwLCB3aWR0aCAtIGNvbXBsZXRlTWFyZ2luLmxlZnQgLSBjb21wbGV0ZU1hcmdpbi5yaWdodClcbiAgfTtcbn0iLCJleHBvcnQgZnVuY3Rpb24gaW5pdFJhbmdlKGRvbWFpbiwgcmFuZ2UpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHRoaXMucmFuZ2UoZG9tYWluKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhpcy5yYW5nZShyYW5nZSkuZG9tYWluKGRvbWFpbik7IGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdEludGVycG9sYXRvcihkb21haW4sIGludGVycG9sYXRvcikge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IGJyZWFrO1xuICAgIGNhc2UgMTogdGhpcy5pbnRlcnBvbGF0b3IoZG9tYWluKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhpcy5pbnRlcnBvbGF0b3IoaW50ZXJwb2xhdG9yKS5kb21haW4oZG9tYWluKTsgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJ2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGU7XG5cbmV4cG9ydCB2YXIgbWFwID0gYXJyYXkubWFwO1xuZXhwb3J0IHZhciBzbGljZSA9IGFycmF5LnNsaWNlO1xuIiwiaW1wb3J0IHttYXB9IGZyb20gXCJkMy1jb2xsZWN0aW9uXCI7XG5pbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IHZhciBpbXBsaWNpdCA9IHtuYW1lOiBcImltcGxpY2l0XCJ9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRpbmFsKCkge1xuICB2YXIgaW5kZXggPSBtYXAoKSxcbiAgICAgIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHVua25vd24gPSBpbXBsaWNpdDtcblxuICBmdW5jdGlvbiBzY2FsZShkKSB7XG4gICAgdmFyIGtleSA9IGQgKyBcIlwiLCBpID0gaW5kZXguZ2V0KGtleSk7XG4gICAgaWYgKCFpKSB7XG4gICAgICBpZiAodW5rbm93biAhPT0gaW1wbGljaXQpIHJldHVybiB1bmtub3duO1xuICAgICAgaW5kZXguc2V0KGtleSwgaSA9IGRvbWFpbi5wdXNoKGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlWyhpIC0gMSkgJSByYW5nZS5sZW5ndGhdO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdLCBpbmRleCA9IG1hcCgpO1xuICAgIHZhciBpID0gLTEsIG4gPSBfLmxlbmd0aCwgZCwga2V5O1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWluZGV4LmhhcyhrZXkgPSAoZCA9IF9baV0pICsgXCJcIikpIGluZGV4LnNldChrZXksIGRvbWFpbi5wdXNoKGQpKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvcmRpbmFsKGRvbWFpbiwgcmFuZ2UpLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cbiIsImltcG9ydCB7cmFuZ2UgYXMgc2VxdWVuY2V9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCBvcmRpbmFsIGZyb20gXCIuL29yZGluYWxcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmFuZCgpIHtcbiAgdmFyIHNjYWxlID0gb3JkaW5hbCgpLnVua25vd24odW5kZWZpbmVkKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIG9yZGluYWxSYW5nZSA9IHNjYWxlLnJhbmdlLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICBzdGVwLFxuICAgICAgYmFuZHdpZHRoLFxuICAgICAgcm91bmQgPSBmYWxzZSxcbiAgICAgIHBhZGRpbmdJbm5lciA9IDAsXG4gICAgICBwYWRkaW5nT3V0ZXIgPSAwLFxuICAgICAgYWxpZ24gPSAwLjU7XG5cbiAgZGVsZXRlIHNjYWxlLnVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgbiA9IGRvbWFpbigpLmxlbmd0aCxcbiAgICAgICAgcmV2ZXJzZSA9IHJhbmdlWzFdIDwgcmFuZ2VbMF0sXG4gICAgICAgIHN0YXJ0ID0gcmFuZ2VbcmV2ZXJzZSAtIDBdLFxuICAgICAgICBzdG9wID0gcmFuZ2VbMSAtIHJldmVyc2VdO1xuICAgIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDEsIG4gLSBwYWRkaW5nSW5uZXIgKyBwYWRkaW5nT3V0ZXIgKiAyKTtcbiAgICBpZiAocm91bmQpIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgIHN0YXJ0ICs9IChzdG9wIC0gc3RhcnQgLSBzdGVwICogKG4gLSBwYWRkaW5nSW5uZXIpKSAqIGFsaWduO1xuICAgIGJhbmR3aWR0aCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XG4gICAgaWYgKHJvdW5kKSBzdGFydCA9IE1hdGgucm91bmQoc3RhcnQpLCBiYW5kd2lkdGggPSBNYXRoLnJvdW5kKGJhbmR3aWR0aCk7XG4gICAgdmFyIHZhbHVlcyA9IHNlcXVlbmNlKG4pLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBzdGFydCArIHN0ZXAgKiBpOyB9KTtcbiAgICByZXR1cm4gb3JkaW5hbFJhbmdlKHJldmVyc2UgPyB2YWx1ZXMucmV2ZXJzZSgpIDogdmFsdWVzKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IFsrX1swXSwgK19bMV1dLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiByYW5nZSA9IFsrX1swXSwgK19bMV1dLCByb3VuZCA9IHRydWUsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5iYW5kd2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmFuZHdpZHRoO1xuICB9O1xuXG4gIHNjYWxlLnN0ZXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3RlcDtcbiAgfTtcblxuICBzY2FsZS5yb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEhXywgcmVzY2FsZSgpKSA6IHJvdW5kO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5taW4oMSwgcGFkZGluZ091dGVyID0gK18pLCByZXNjYWxlKCkpIDogcGFkZGluZ0lubmVyO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBNYXRoLm1pbigxLCBfKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ091dGVyID0gK18sIHJlc2NhbGUoKSkgOiBwYWRkaW5nT3V0ZXI7XG4gIH07XG5cbiAgc2NhbGUuYWxpZ24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxpZ24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBhbGlnbjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmQoZG9tYWluKCksIHJhbmdlKVxuICAgICAgICAucm91bmQocm91bmQpXG4gICAgICAgIC5wYWRkaW5nSW5uZXIocGFkZGluZ0lubmVyKVxuICAgICAgICAucGFkZGluZ091dGVyKHBhZGRpbmdPdXRlcilcbiAgICAgICAgLmFsaWduKGFsaWduKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHJlc2NhbGUoKSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRpc2goc2NhbGUpIHtcbiAgdmFyIGNvcHkgPSBzY2FsZS5jb3B5O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nSW5uZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwb2ludGlzaChjb3B5KCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50KCkge1xuICByZXR1cm4gcG9pbnRpc2goYmFuZC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhZGRpbmdJbm5lcigxKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuICt4O1xufVxuIiwiaW1wb3J0IHtiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZSBhcyBpbnRlcnBvbGF0ZVZhbHVlLCBpbnRlcnBvbGF0ZU51bWJlciwgaW50ZXJwb2xhdGVSb3VuZH0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge21hcCwgc2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbnZhciB1bml0ID0gWzAsIDFdO1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKGEsIGIpIHtcbiAgcmV0dXJuIChiIC09IChhID0gK2EpKVxuICAgICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiAoeCAtIGEpIC8gYjsgfVxuICAgICAgOiBjb25zdGFudChpc05hTihiKSA/IE5hTiA6IDAuNSk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wZXIoZG9tYWluKSB7XG4gIHZhciBhID0gZG9tYWluWzBdLCBiID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXSwgdDtcbiAgaWYgKGEgPiBiKSB0ID0gYSwgYSA9IGIsIGIgPSB0O1xuICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5tYXgoYSwgTWF0aC5taW4oYiwgeCkpOyB9O1xufVxuXG4vLyBub3JtYWxpemUoYSwgYikoeCkgdGFrZXMgYSBkb21haW4gdmFsdWUgeCBpbiBbYSxiXSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwYXJhbWV0ZXIgdCBpbiBbMCwxXS5cbi8vIGludGVycG9sYXRlKGEsIGIpKHQpIHRha2VzIGEgcGFyYW1ldGVyIHQgaW4gWzAsMV0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmFuZ2UgdmFsdWUgeCBpbiBbYSxiXS5cbmZ1bmN0aW9uIGJpbWFwKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlKSB7XG4gIHZhciBkMCA9IGRvbWFpblswXSwgZDEgPSBkb21haW5bMV0sIHIwID0gcmFuZ2VbMF0sIHIxID0gcmFuZ2VbMV07XG4gIGlmIChkMSA8IGQwKSBkMCA9IG5vcm1hbGl6ZShkMSwgZDApLCByMCA9IGludGVycG9sYXRlKHIxLCByMCk7XG4gIGVsc2UgZDAgPSBub3JtYWxpemUoZDAsIGQxKSwgcjAgPSBpbnRlcnBvbGF0ZShyMCwgcjEpO1xuICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gcjAoZDAoeCkpOyB9O1xufVxuXG5mdW5jdGlvbiBwb2x5bWFwKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlKSB7XG4gIHZhciBqID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKSAtIDEsXG4gICAgICBkID0gbmV3IEFycmF5KGopLFxuICAgICAgciA9IG5ldyBBcnJheShqKSxcbiAgICAgIGkgPSAtMTtcblxuICAvLyBSZXZlcnNlIGRlc2NlbmRpbmcgZG9tYWlucy5cbiAgaWYgKGRvbWFpbltqXSA8IGRvbWFpblswXSkge1xuICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpLnJldmVyc2UoKTtcbiAgICByYW5nZSA9IHJhbmdlLnNsaWNlKCkucmV2ZXJzZSgpO1xuICB9XG5cbiAgd2hpbGUgKCsraSA8IGopIHtcbiAgICBkW2ldID0gbm9ybWFsaXplKGRvbWFpbltpXSwgZG9tYWluW2kgKyAxXSk7XG4gICAgcltpXSA9IGludGVycG9sYXRlKHJhbmdlW2ldLCByYW5nZVtpICsgMV0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgaSA9IGJpc2VjdChkb21haW4sIHgsIDEsIGopIC0gMTtcbiAgICByZXR1cm4gcltpXShkW2ldKHgpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFxuICAgICAgLmRvbWFpbihzb3VyY2UuZG9tYWluKCkpXG4gICAgICAucmFuZ2Uoc291cmNlLnJhbmdlKCkpXG4gICAgICAuaW50ZXJwb2xhdGUoc291cmNlLmludGVycG9sYXRlKCkpXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpXG4gICAgICAudW5rbm93bihzb3VyY2UudW5rbm93bigpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybWVyKCkge1xuICB2YXIgZG9tYWluID0gdW5pdCxcbiAgICAgIHJhbmdlID0gdW5pdCxcbiAgICAgIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVWYWx1ZSxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHVudHJhbnNmb3JtLFxuICAgICAgdW5rbm93bixcbiAgICAgIGNsYW1wID0gaWRlbnRpdHksXG4gICAgICBwaWVjZXdpc2UsXG4gICAgICBvdXRwdXQsXG4gICAgICBpbnB1dDtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHBpZWNld2lzZSA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgPiAyID8gcG9seW1hcCA6IGJpbWFwO1xuICAgIG91dHB1dCA9IGlucHV0ID0gbnVsbDtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogKG91dHB1dCB8fCAob3V0cHV0ID0gcGllY2V3aXNlKGRvbWFpbi5tYXAodHJhbnNmb3JtKSwgcmFuZ2UsIGludGVycG9sYXRlKSkpKHRyYW5zZm9ybShjbGFtcCh4KSkpO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBjbGFtcCh1bnRyYW5zZm9ybSgoaW5wdXQgfHwgKGlucHV0ID0gcGllY2V3aXNlKHJhbmdlLCBkb21haW4ubWFwKHRyYW5zZm9ybSksIGludGVycG9sYXRlTnVtYmVyKSkpKHkpKSk7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcC5jYWxsKF8sIG51bWJlciksIGNsYW1wID09PSBpZGVudGl0eSB8fCAoY2xhbXAgPSBjbGFtcGVyKGRvbWFpbikpLCByZXNjYWxlKCkpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiByYW5nZSA9IHNsaWNlLmNhbGwoXyksIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVSb3VuZCwgcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gXyA/IGNsYW1wZXIoZG9tYWluKSA6IGlkZW50aXR5LCBzY2FsZSkgOiBjbGFtcCAhPT0gaWRlbnRpdHk7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCByZXNjYWxlKCkpIDogaW50ZXJwb2xhdGU7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24odCwgdSkge1xuICAgIHRyYW5zZm9ybSA9IHQsIHVudHJhbnNmb3JtID0gdTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250aW51b3VzKHRyYW5zZm9ybSwgdW50cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKCkodHJhbnNmb3JtLCB1bnRyYW5zZm9ybSk7XG59XG4iLCJpbXBvcnQge3RpY2tTdGVwfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Zm9ybWF0LCBmb3JtYXRQcmVmaXgsIGZvcm1hdFNwZWNpZmllciwgcHJlY2lzaW9uRml4ZWQsIHByZWNpc2lvblByZWZpeCwgcHJlY2lzaW9uUm91bmR9IGZyb20gXCJkMy1mb3JtYXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhcnQsIHN0b3AsIGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgdmFyIHN0ZXAgPSB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpLFxuICAgICAgcHJlY2lzaW9uO1xuICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyID09IG51bGwgPyBcIixmXCIgOiBzcGVjaWZpZXIpO1xuICBzd2l0Y2ggKHNwZWNpZmllci50eXBlKSB7XG4gICAgY2FzZSBcInNcIjoge1xuICAgICAgdmFyIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSk7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25QcmVmaXgoc3RlcCwgdmFsdWUpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICAgIHJldHVybiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNhc2UgXCJcIjpcbiAgICBjYXNlIFwiZVwiOlxuICAgIGNhc2UgXCJnXCI6XG4gICAgY2FzZSBcInBcIjpcbiAgICBjYXNlIFwiclwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25Sb3VuZChzdGVwLCBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcImVcIik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImZcIjpcbiAgICBjYXNlIFwiJVwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25GaXhlZChzdGVwKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiJVwiKSAqIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChzcGVjaWZpZXIpO1xufVxuIiwiaW1wb3J0IHt0aWNrcywgdGlja0luY3JlbWVudH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQgY29udGludW91cywge2NvcHksIGlkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuaW1wb3J0IHRpY2tGb3JtYXQgZnJvbSBcIi4vdGlja0Zvcm1hdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyaXNoKHNjYWxlKSB7XG4gIHZhciBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIHRpY2tzKGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gdGlja0Zvcm1hdChkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50LCBzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuXG4gICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgaTAgPSAwLFxuICAgICAgICBpMSA9IGQubGVuZ3RoIC0gMSxcbiAgICAgICAgc3RhcnQgPSBkW2kwXSxcbiAgICAgICAgc3RvcCA9IGRbaTFdLFxuICAgICAgICBzdGVwO1xuXG4gICAgaWYgKHN0b3AgPCBzdGFydCkge1xuICAgICAgc3RlcCA9IHN0YXJ0LCBzdGFydCA9IHN0b3AsIHN0b3AgPSBzdGVwO1xuICAgICAgc3RlcCA9IGkwLCBpMCA9IGkxLCBpMSA9IHN0ZXA7XG4gICAgfVxuXG4gICAgc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcblxuICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgc3RhcnQgPSBNYXRoLmZsb29yKHN0YXJ0IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgc3RvcCA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICB9IGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICBzdGFydCA9IE1hdGguY2VpbChzdGFydCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIHN0b3AgPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuICAgIH1cblxuICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgZFtpMF0gPSBNYXRoLmZsb29yKHN0YXJ0IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgZFtpMV0gPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgIGRvbWFpbihkKTtcbiAgICB9IGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICBkW2kwXSA9IE1hdGguY2VpbChzdGFydCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIGRbaTFdID0gTWF0aC5mbG9vcihzdG9wICogc3RlcCkgLyBzdGVwO1xuICAgICAgZG9tYWluKGQpO1xuICAgIH1cblxuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpbmVhcigpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cyhpZGVudGl0eSwgaWRlbnRpdHkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgbGluZWFyKCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cbiIsImltcG9ydCB7bWFwfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhclwiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaWRlbnRpdHkoZG9tYWluKSB7XG4gIHZhciB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiB4O1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gc2NhbGU7XG5cbiAgc2NhbGUuZG9tYWluID0gc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gbWFwLmNhbGwoXywgbnVtYmVyKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5KGRvbWFpbikudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICBkb21haW4gPSBhcmd1bWVudHMubGVuZ3RoID8gbWFwLmNhbGwoZG9tYWluLCBudW1iZXIpIDogWzAsIDFdO1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZG9tYWluLCBpbnRlcnZhbCkge1xuICBkb21haW4gPSBkb21haW4uc2xpY2UoKTtcblxuICB2YXIgaTAgPSAwLFxuICAgICAgaTEgPSBkb21haW4ubGVuZ3RoIC0gMSxcbiAgICAgIHgwID0gZG9tYWluW2kwXSxcbiAgICAgIHgxID0gZG9tYWluW2kxXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHgxIDwgeDApIHtcbiAgICB0ID0gaTAsIGkwID0gaTEsIGkxID0gdDtcbiAgICB0ID0geDAsIHgwID0geDEsIHgxID0gdDtcbiAgfVxuXG4gIGRvbWFpbltpMF0gPSBpbnRlcnZhbC5mbG9vcih4MCk7XG4gIGRvbWFpbltpMV0gPSBpbnRlcnZhbC5jZWlsKHgxKTtcbiAgcmV0dXJuIGRvbWFpbjtcbn1cbiIsImltcG9ydCB7dGlja3N9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtmb3JtYXR9IGZyb20gXCJkMy1mb3JtYXRcIjtcbmltcG9ydCBuaWNlIGZyb20gXCIuL25pY2VcIjtcbmltcG9ydCB7Y29weSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUxvZyh4KSB7XG4gIHJldHVybiBNYXRoLmxvZyh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRXhwKHgpIHtcbiAgcmV0dXJuIE1hdGguZXhwKHgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Mb2duKHgpIHtcbiAgcmV0dXJuIC1NYXRoLmxvZygteCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUV4cG4oeCkge1xuICByZXR1cm4gLU1hdGguZXhwKC14KTtcbn1cblxuZnVuY3Rpb24gcG93MTAoeCkge1xuICByZXR1cm4gaXNGaW5pdGUoeCkgPyArKFwiMWVcIiArIHgpIDogeCA8IDAgPyAwIDogeDtcbn1cblxuZnVuY3Rpb24gcG93cChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSAxMCA/IHBvdzEwXG4gICAgICA6IGJhc2UgPT09IE1hdGguRSA/IE1hdGguZXhwXG4gICAgICA6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucG93KGJhc2UsIHgpOyB9O1xufVxuXG5mdW5jdGlvbiBsb2dwKGJhc2UpIHtcbiAgcmV0dXJuIGJhc2UgPT09IE1hdGguRSA/IE1hdGgubG9nXG4gICAgICA6IGJhc2UgPT09IDEwICYmIE1hdGgubG9nMTBcbiAgICAgIHx8IGJhc2UgPT09IDIgJiYgTWF0aC5sb2cyXG4gICAgICB8fCAoYmFzZSA9IE1hdGgubG9nKGJhc2UpLCBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLmxvZyh4KSAvIGJhc2U7IH0pO1xufVxuXG5mdW5jdGlvbiByZWZsZWN0KGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gLWYoLXgpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nZ2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIHNjYWxlID0gdHJhbnNmb3JtKHRyYW5zZm9ybUxvZywgdHJhbnNmb3JtRXhwKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIGJhc2UgPSAxMCxcbiAgICAgIGxvZ3MsXG4gICAgICBwb3dzO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgbG9ncyA9IGxvZ3AoYmFzZSksIHBvd3MgPSBwb3dwKGJhc2UpO1xuICAgIGlmIChkb21haW4oKVswXSA8IDApIHtcbiAgICAgIGxvZ3MgPSByZWZsZWN0KGxvZ3MpLCBwb3dzID0gcmVmbGVjdChwb3dzKTtcbiAgICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2duLCB0cmFuc2Zvcm1FeHBuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtKHRyYW5zZm9ybUxvZywgdHJhbnNmb3JtRXhwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChiYXNlID0gK18sIHJlc2NhbGUoKSkgOiBiYXNlO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgdSA9IGRbMF0sXG4gICAgICAgIHYgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHI7XG5cbiAgICBpZiAociA9IHYgPCB1KSBpID0gdSwgdSA9IHYsIHYgPSBpO1xuXG4gICAgdmFyIGkgPSBsb2dzKHUpLFxuICAgICAgICBqID0gbG9ncyh2KSxcbiAgICAgICAgcCxcbiAgICAgICAgayxcbiAgICAgICAgdCxcbiAgICAgICAgbiA9IGNvdW50ID09IG51bGwgPyAxMCA6ICtjb3VudCxcbiAgICAgICAgeiA9IFtdO1xuXG4gICAgaWYgKCEoYmFzZSAlIDEpICYmIGogLSBpIDwgbikge1xuICAgICAgaSA9IE1hdGgucm91bmQoaSkgLSAxLCBqID0gTWF0aC5yb3VuZChqKSArIDE7XG4gICAgICBpZiAodSA+IDApIGZvciAoOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGZvciAoayA9IDEsIHAgPSBwb3dzKGkpOyBrIDwgYmFzZTsgKytrKSB7XG4gICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcbiAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBmb3IgKDsgaSA8IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSBiYXNlIC0gMSwgcCA9IHBvd3MoaSk7IGsgPj0gMTsgLS1rKSB7XG4gICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcbiAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IHRpY2tzKGksIGosIE1hdGgubWluKGogLSBpLCBuKSkubWFwKHBvd3MpO1xuICAgIH1cblxuICAgIHJldHVybiByID8gei5yZXZlcnNlKCkgOiB6O1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgaWYgKHNwZWNpZmllciA9PSBudWxsKSBzcGVjaWZpZXIgPSBiYXNlID09PSAxMCA/IFwiLjBlXCIgOiBcIixcIjtcbiAgICBpZiAodHlwZW9mIHNwZWNpZmllciAhPT0gXCJmdW5jdGlvblwiKSBzcGVjaWZpZXIgPSBmb3JtYXQoc3BlY2lmaWVyKTtcbiAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSByZXR1cm4gc3BlY2lmaWVyO1xuICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuICAgIHZhciBrID0gTWF0aC5tYXgoMSwgYmFzZSAqIGNvdW50IC8gc2NhbGUudGlja3MoKS5sZW5ndGgpOyAvLyBUT0RPIGZhc3QgZXN0aW1hdGU/XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHZhciBpID0gZCAvIHBvd3MoTWF0aC5yb3VuZChsb2dzKGQpKSk7XG4gICAgICBpZiAoaSAqIGJhc2UgPCBiYXNlIC0gMC41KSBpICo9IGJhc2U7XG4gICAgICByZXR1cm4gaSA8PSBrID8gc3BlY2lmaWVyKGQpIDogXCJcIjtcbiAgICB9O1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZG9tYWluKG5pY2UoZG9tYWluKCksIHtcbiAgICAgIGZsb29yOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguZmxvb3IobG9ncyh4KSkpOyB9LFxuICAgICAgY2VpbDogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmNlaWwobG9ncyh4KSkpOyB9XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9nKCkge1xuICB2YXIgc2NhbGUgPSBsb2dnaXNoKHRyYW5zZm9ybWVyKCkpLmRvbWFpbihbMSwgMTBdKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGxvZygpKS5iYXNlKHNjYWxlLmJhc2UoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cbiIsImltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCB7Y29weSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN5bWxvZyhjKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGgubG9nMXAoTWF0aC5hYnMoeCAvIGMpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3ltZXhwKGMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHgpICogTWF0aC5leHBtMShNYXRoLmFicyh4KSkgKiBjO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ltbG9naXNoKHRyYW5zZm9ybSkge1xuICB2YXIgYyA9IDEsIHNjYWxlID0gdHJhbnNmb3JtKHRyYW5zZm9ybVN5bWxvZyhjKSwgdHJhbnNmb3JtU3ltZXhwKGMpKTtcblxuICBzY2FsZS5jb25zdGFudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyYW5zZm9ybSh0cmFuc2Zvcm1TeW1sb2coYyA9ICtfKSwgdHJhbnNmb3JtU3ltZXhwKGMpKSA6IGM7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgc3ltbG9nKCkpLmNvbnN0YW50KHNjYWxlLmNvbnN0YW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQge2NvcHksIGlkZW50aXR5LCB0cmFuc2Zvcm1lcn0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtUG93KGV4cG9uZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggPCAwID8gLU1hdGgucG93KC14LCBleHBvbmVudCkgOiBNYXRoLnBvdyh4LCBleHBvbmVudCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxcnQoeCkge1xuICByZXR1cm4geCA8IDAgPyAtTWF0aC5zcXJ0KC14KSA6IE1hdGguc3FydCh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3F1YXJlKHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLXggKiB4IDogeCAqIHg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3dpc2godHJhbnNmb3JtKSB7XG4gIHZhciBzY2FsZSA9IHRyYW5zZm9ybShpZGVudGl0eSwgaWRlbnRpdHkpLFxuICAgICAgZXhwb25lbnQgPSAxO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgcmV0dXJuIGV4cG9uZW50ID09PSAxID8gdHJhbnNmb3JtKGlkZW50aXR5LCBpZGVudGl0eSlcbiAgICAgICAgOiBleHBvbmVudCA9PT0gMC41ID8gdHJhbnNmb3JtKHRyYW5zZm9ybVNxcnQsIHRyYW5zZm9ybVNxdWFyZSlcbiAgICAgICAgOiB0cmFuc2Zvcm0odHJhbnNmb3JtUG93KGV4cG9uZW50KSwgdHJhbnNmb3JtUG93KDEgLyBleHBvbmVudCkpO1xuICB9XG5cbiAgc2NhbGUuZXhwb25lbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXhwb25lbnQgPSArXywgcmVzY2FsZSgpKSA6IGV4cG9uZW50O1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwb3coKSB7XG4gIHZhciBzY2FsZSA9IHBvd2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHBvdygpKS5leHBvbmVudChzY2FsZS5leHBvbmVudCgpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3FydCgpIHtcbiAgcmV0dXJuIHBvdy5hcHBseShudWxsLCBhcmd1bWVudHMpLmV4cG9uZW50KDAuNSk7XG59XG4iLCJpbXBvcnQge2FzY2VuZGluZywgYmlzZWN0LCBxdWFudGlsZSBhcyB0aHJlc2hvbGR9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YW50aWxlKCkge1xuICB2YXIgZG9tYWluID0gW10sXG4gICAgICByYW5nZSA9IFtdLFxuICAgICAgdGhyZXNob2xkcyA9IFtdLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gMCwgbiA9IE1hdGgubWF4KDEsIHJhbmdlLmxlbmd0aCk7XG4gICAgdGhyZXNob2xkcyA9IG5ldyBBcnJheShuIC0gMSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRocmVzaG9sZHNbaSAtIDFdID0gdGhyZXNob2xkKGRvbWFpbiwgaSAvIG4pO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiByYW5nZVtiaXNlY3QodGhyZXNob2xkcywgeCldO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gaSA8IDAgPyBbTmFOLCBOYU5dIDogW1xuICAgICAgaSA+IDAgPyB0aHJlc2hvbGRzW2kgLSAxXSA6IGRvbWFpblswXSxcbiAgICAgIGkgPCB0aHJlc2hvbGRzLmxlbmd0aCA/IHRocmVzaG9sZHNbaV0gOiBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdXG4gICAgXTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgZG9tYWluID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBfLmxlbmd0aCwgZDsgaSA8IG47ICsraSkgaWYgKGQgPSBfW2ldLCBkICE9IG51bGwgJiYgIWlzTmFOKGQgPSArZCkpIGRvbWFpbi5wdXNoKGQpO1xuICAgIGRvbWFpbi5zb3J0KGFzY2VuZGluZyk7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IHNsaWNlLmNhbGwoXyksIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUucXVhbnRpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZHMuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHF1YW50aWxlKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGl6ZSgpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMSxcbiAgICAgIG4gPSAxLFxuICAgICAgZG9tYWluID0gWzAuNV0sXG4gICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4IDw9IHggPyByYW5nZVtiaXNlY3QoZG9tYWluLCB4LCAwLCBuKV0gOiB1bmtub3duO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIGRvbWFpbiA9IG5ldyBBcnJheShuKTtcbiAgICB3aGlsZSAoKytpIDwgbikgZG9tYWluW2ldID0gKChpICsgMSkgKiB4MSAtIChpIC0gbikgKiB4MCkgLyAobiArIDEpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9ICtfWzBdLCB4MSA9ICtfWzFdLCByZXNjYWxlKCkpIDogW3gwLCB4MV07XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IChyYW5nZSA9IHNsaWNlLmNhbGwoXykpLmxlbmd0aCAtIDEsIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXVxuICAgICAgICA6IGkgPCAxID8gW3gwLCBkb21haW5bMF1dXG4gICAgICAgIDogaSA+PSBuID8gW2RvbWFpbltuIC0gMV0sIHgxXVxuICAgICAgICA6IFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnRocmVzaG9sZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGl6ZSgpXG4gICAgICAgIC5kb21haW4oW3gwLCB4MV0pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShsaW5lYXJpc2goc2NhbGUpLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRocmVzaG9sZCgpIHtcbiAgdmFyIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICB1bmtub3duLFxuICAgICAgbiA9IDE7XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4IDw9IHggPyByYW5nZVtiaXNlY3QoZG9tYWluLCB4LCAwLCBuKV0gOiB1bmtub3duO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IHNsaWNlLmNhbGwoXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGggLSAxKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gW2RvbWFpbltpIC0gMV0sIGRvbWFpbltpXV07XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZCgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2Jpc2VjdG9yLCB0aWNrU3RlcH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge3RpbWVZZWFyLCB0aW1lTW9udGgsIHRpbWVXZWVrLCB0aW1lRGF5LCB0aW1lSG91ciwgdGltZU1pbnV0ZSwgdGltZVNlY29uZCwgdGltZU1pbGxpc2Vjb25kfSBmcm9tIFwiZDMtdGltZVwiO1xuaW1wb3J0IHt0aW1lRm9ybWF0fSBmcm9tIFwiZDMtdGltZS1mb3JtYXRcIjtcbmltcG9ydCB7bWFwfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IGNvbnRpbnVvdXMsIHtjb3B5LCBpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCBuaWNlIGZyb20gXCIuL25pY2VcIjtcblxudmFyIGR1cmF0aW9uU2Vjb25kID0gMTAwMCxcbiAgICBkdXJhdGlvbk1pbnV0ZSA9IGR1cmF0aW9uU2Vjb25kICogNjAsXG4gICAgZHVyYXRpb25Ib3VyID0gZHVyYXRpb25NaW51dGUgKiA2MCxcbiAgICBkdXJhdGlvbkRheSA9IGR1cmF0aW9uSG91ciAqIDI0LFxuICAgIGR1cmF0aW9uV2VlayA9IGR1cmF0aW9uRGF5ICogNyxcbiAgICBkdXJhdGlvbk1vbnRoID0gZHVyYXRpb25EYXkgKiAzMCxcbiAgICBkdXJhdGlvblllYXIgPSBkdXJhdGlvbkRheSAqIDM2NTtcblxuZnVuY3Rpb24gZGF0ZSh0KSB7XG4gIHJldHVybiBuZXcgRGF0ZSh0KTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKHQpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBEYXRlID8gK3QgOiArbmV3IERhdGUoK3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsZW5kYXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBmb3JtYXQpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cyhpZGVudGl0eSwgaWRlbnRpdHkpLFxuICAgICAgaW52ZXJ0ID0gc2NhbGUuaW52ZXJ0LFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHZhciBmb3JtYXRNaWxsaXNlY29uZCA9IGZvcm1hdChcIi4lTFwiKSxcbiAgICAgIGZvcm1hdFNlY29uZCA9IGZvcm1hdChcIjolU1wiKSxcbiAgICAgIGZvcm1hdE1pbnV0ZSA9IGZvcm1hdChcIiVJOiVNXCIpLFxuICAgICAgZm9ybWF0SG91ciA9IGZvcm1hdChcIiVJICVwXCIpLFxuICAgICAgZm9ybWF0RGF5ID0gZm9ybWF0KFwiJWEgJWRcIiksXG4gICAgICBmb3JtYXRXZWVrID0gZm9ybWF0KFwiJWIgJWRcIiksXG4gICAgICBmb3JtYXRNb250aCA9IGZvcm1hdChcIiVCXCIpLFxuICAgICAgZm9ybWF0WWVhciA9IGZvcm1hdChcIiVZXCIpO1xuXG4gIHZhciB0aWNrSW50ZXJ2YWxzID0gW1xuICAgIFtzZWNvbmQsICAxLCAgICAgIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAgNSwgIDUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgMTUsIDE1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDMwLCAzMCAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbbWludXRlLCAgMSwgICAgICBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgIDUsICA1ICogZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsIDE1LCAxNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAzMCwgMzAgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgWyAgaG91ciwgIDEsICAgICAgZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsICAzLCAgMyAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgNiwgIDYgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgMTIsIDEyICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgICBkYXksICAxLCAgICAgIGR1cmF0aW9uRGF5ICAgXSxcbiAgICBbICAgZGF5LCAgMiwgIDIgKiBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgd2VlaywgIDEsICAgICAgZHVyYXRpb25XZWVrICBdLFxuICAgIFsgbW9udGgsICAxLCAgICAgIGR1cmF0aW9uTW9udGggXSxcbiAgICBbIG1vbnRoLCAgMywgIDMgKiBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyAgeWVhciwgIDEsICAgICAgZHVyYXRpb25ZZWFyICBdXG4gIF07XG5cbiAgZnVuY3Rpb24gdGlja0Zvcm1hdChkYXRlKSB7XG4gICAgcmV0dXJuIChzZWNvbmQoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWlsbGlzZWNvbmRcbiAgICAgICAgOiBtaW51dGUoZGF0ZSkgPCBkYXRlID8gZm9ybWF0U2Vjb25kXG4gICAgICAgIDogaG91cihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkYXkoZGF0ZSkgPCBkYXRlID8gZm9ybWF0SG91clxuICAgICAgICA6IG1vbnRoKGRhdGUpIDwgZGF0ZSA/ICh3ZWVrKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdERheSA6IGZvcm1hdFdlZWspXG4gICAgICAgIDogeWVhcihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNb250aFxuICAgICAgICA6IGZvcm1hdFllYXIpKGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGlja0ludGVydmFsKGludGVydmFsLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChpbnRlcnZhbCA9PSBudWxsKSBpbnRlcnZhbCA9IDEwO1xuXG4gICAgLy8gSWYgYSBkZXNpcmVkIHRpY2sgY291bnQgaXMgc3BlY2lmaWVkLCBwaWNrIGEgcmVhc29uYWJsZSB0aWNrIGludGVydmFsXG4gICAgLy8gYmFzZWQgb24gdGhlIGV4dGVudCBvZiB0aGUgZG9tYWluIGFuZCBhIHJvdWdoIGVzdGltYXRlIG9mIHRpY2sgc2l6ZS5cbiAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpbnRlcnZhbCBpcyBhbHJlYWR5IGEgdGltZSBpbnRlcnZhbCBhbmQgdXNlIGl0LlxuICAgIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gaW50ZXJ2YWwsXG4gICAgICAgICAgaSA9IGJpc2VjdG9yKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGlbMl07IH0pLnJpZ2h0KHRpY2tJbnRlcnZhbHMsIHRhcmdldCk7XG4gICAgICBpZiAoaSA9PT0gdGlja0ludGVydmFscy5sZW5ndGgpIHtcbiAgICAgICAgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0IC8gZHVyYXRpb25ZZWFyLCBzdG9wIC8gZHVyYXRpb25ZZWFyLCBpbnRlcnZhbCk7XG4gICAgICAgIGludGVydmFsID0geWVhcjtcbiAgICAgIH0gZWxzZSBpZiAoaSkge1xuICAgICAgICBpID0gdGlja0ludGVydmFsc1t0YXJnZXQgLyB0aWNrSW50ZXJ2YWxzW2kgLSAxXVsyXSA8IHRpY2tJbnRlcnZhbHNbaV1bMl0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xuICAgICAgICBzdGVwID0gaVsxXTtcbiAgICAgICAgaW50ZXJ2YWwgPSBpWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlcCA9IE1hdGgubWF4KHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBpbnRlcnZhbCksIDEpO1xuICAgICAgICBpbnRlcnZhbCA9IG1pbGxpc2Vjb25kO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGVwID09IG51bGwgPyBpbnRlcnZhbCA6IGludGVydmFsLmV2ZXJ5KHN0ZXApO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShpbnZlcnQoeSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGRvbWFpbihtYXAuY2FsbChfLCBudW1iZXIpKSA6IGRvbWFpbigpLm1hcChkYXRlKTtcbiAgfTtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGludGVydmFsLCBzdGVwKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgdDAgPSBkWzBdLFxuICAgICAgICB0MSA9IGRbZC5sZW5ndGggLSAxXSxcbiAgICAgICAgciA9IHQxIDwgdDAsXG4gICAgICAgIHQ7XG4gICAgaWYgKHIpIHQgPSB0MCwgdDAgPSB0MSwgdDEgPSB0O1xuICAgIHQgPSB0aWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIHQwLCB0MSwgc3RlcCk7XG4gICAgdCA9IHQgPyB0LnJhbmdlKHQwLCB0MSArIDEpIDogW107IC8vIGluY2x1c2l2ZSBzdG9wXG4gICAgcmV0dXJuIHIgPyB0LnJldmVyc2UoKSA6IHQ7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gc3BlY2lmaWVyID09IG51bGwgPyB0aWNrRm9ybWF0IDogZm9ybWF0KHNwZWNpZmllcik7XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGludGVydmFsLCBzdGVwKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gKGludGVydmFsID0gdGlja0ludGVydmFsKGludGVydmFsLCBkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIHN0ZXApKVxuICAgICAgICA/IGRvbWFpbihuaWNlKGQsIGludGVydmFsKSlcbiAgICAgICAgOiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGNhbGVuZGFyKHllYXIsIG1vbnRoLCB3ZWVrLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgZm9ybWF0KSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShjYWxlbmRhcih0aW1lWWVhciwgdGltZU1vbnRoLCB0aW1lV2VlaywgdGltZURheSwgdGltZUhvdXIsIHRpbWVNaW51dGUsIHRpbWVTZWNvbmQsIHRpbWVNaWxsaXNlY29uZCwgdGltZUZvcm1hdCkuZG9tYWluKFtuZXcgRGF0ZSgyMDAwLCAwLCAxKSwgbmV3IERhdGUoMjAwMCwgMCwgMildKSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7Y2FsZW5kYXJ9IGZyb20gXCIuL3RpbWVcIjtcbmltcG9ydCB7dXRjRm9ybWF0fSBmcm9tIFwiZDMtdGltZS1mb3JtYXRcIjtcbmltcG9ydCB7dXRjWWVhciwgdXRjTW9udGgsIHV0Y1dlZWssIHV0Y0RheSwgdXRjSG91ciwgdXRjTWludXRlLCB1dGNTZWNvbmQsIHV0Y01pbGxpc2Vjb25kfSBmcm9tIFwiZDMtdGltZVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoY2FsZW5kYXIodXRjWWVhciwgdXRjTW9udGgsIHV0Y1dlZWssIHV0Y0RheSwgdXRjSG91ciwgdXRjTWludXRlLCB1dGNTZWNvbmQsIHV0Y01pbGxpc2Vjb25kLCB1dGNGb3JtYXQpLmRvbWFpbihbRGF0ZS5VVEMoMjAwMCwgMCwgMSksIERhdGUuVVRDKDIwMDAsIDAsIDIpXSksIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2lkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRJbnRlcnBvbGF0b3J9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCB7bG9nZ2lzaH0gZnJvbSBcIi4vbG9nXCI7XG5pbXBvcnQge3N5bWxvZ2lzaH0gZnJvbSBcIi4vc3ltbG9nXCI7XG5pbXBvcnQge3Bvd2lzaH0gZnJvbSBcIi4vcG93XCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKCkge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAxLFxuICAgICAgdDAsXG4gICAgICB0MSxcbiAgICAgIGsxMCxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIGludGVycG9sYXRvciA9IGlkZW50aXR5LFxuICAgICAgY2xhbXAgPSBmYWxzZSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IGludGVycG9sYXRvcihrMTAgPT09IDAgPyAwLjUgOiAoeCA9ICh0cmFuc2Zvcm0oeCkgLSB0MCkgKiBrMTAsIGNsYW1wID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeCkpIDogeCkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQwID0gdHJhbnNmb3JtKHgwID0gK19bMF0pLCB0MSA9IHRyYW5zZm9ybSh4MSA9ICtfWzFdKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDEgLyAodDEgLSB0MCksIHNjYWxlKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCBzY2FsZSkgOiBjbGFtcDtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB0MCA9IHQoeDApLCB0MSA9IHQoeDEpLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMSAvICh0MSAtIHQwKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLmludGVycG9sYXRvcihzb3VyY2UuaW50ZXJwb2xhdG9yKCkpXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpXG4gICAgICAudW5rbm93bihzb3VyY2UudW5rbm93bigpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2VxdWVudGlhbCgpIHtcbiAgdmFyIHNjYWxlID0gbGluZWFyaXNoKHRyYW5zZm9ybWVyKCkoaWRlbnRpdHkpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWwoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsTG9nKCkge1xuICB2YXIgc2NhbGUgPSBsb2dnaXNoKHRyYW5zZm9ybWVyKCkpLmRvbWFpbihbMSwgMTBdKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWxMb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbFN5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgc2VxdWVudGlhbFN5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbnRpYWxQb3coKSB7XG4gIHZhciBzY2FsZSA9IHBvd2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWxQb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsU3FydCgpIHtcbiAgcmV0dXJuIHNlcXVlbnRpYWxQb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuIiwiaW1wb3J0IHthc2NlbmRpbmcsIGJpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2lkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRJbnRlcnBvbGF0b3J9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2VxdWVudGlhbFF1YW50aWxlKCkge1xuICB2YXIgZG9tYWluID0gW10sXG4gICAgICBpbnRlcnBvbGF0b3IgPSBpZGVudGl0eTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgaWYgKCFpc05hTih4ID0gK3gpKSByZXR1cm4gaW50ZXJwb2xhdG9yKChiaXNlY3QoZG9tYWluLCB4KSAtIDEpIC8gKGRvbWFpbi5sZW5ndGggLSAxKSk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgZG9tYWluID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBfLmxlbmd0aCwgZDsgaSA8IG47ICsraSkgaWYgKGQgPSBfW2ldLCBkICE9IG51bGwgJiYgIWlzTmFOKGQgPSArZCkpIGRvbWFpbi5wdXNoKGQpO1xuICAgIGRvbWFpbi5zb3J0KGFzY2VuZGluZyk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZXF1ZW50aWFsUXVhbnRpbGUoaW50ZXJwb2xhdG9yKS5kb21haW4oZG9tYWluKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7aWRlbnRpdHl9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdEludGVycG9sYXRvcn0gZnJvbSBcIi4vaW5pdFwiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhclwiO1xuaW1wb3J0IHtsb2dnaXNofSBmcm9tIFwiLi9sb2dcIjtcbmltcG9ydCB7Y29weX0gZnJvbSBcIi4vc2VxdWVudGlhbFwiO1xuaW1wb3J0IHtzeW1sb2dpc2h9IGZyb20gXCIuL3N5bWxvZ1wiO1xuaW1wb3J0IHtwb3dpc2h9IGZyb20gXCIuL3Bvd1wiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMC41LFxuICAgICAgeDIgPSAxLFxuICAgICAgdDAsXG4gICAgICB0MSxcbiAgICAgIHQyLFxuICAgICAgazEwLFxuICAgICAgazIxLFxuICAgICAgaW50ZXJwb2xhdG9yID0gaWRlbnRpdHksXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBjbGFtcCA9IGZhbHNlLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogKHggPSAwLjUgKyAoKHggPSArdHJhbnNmb3JtKHgpKSAtIHQxKSAqICh4IDwgdDEgPyBrMTAgOiBrMjEpLCBpbnRlcnBvbGF0b3IoY2xhbXAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB4KSkgOiB4KSk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodDAgPSB0cmFuc2Zvcm0oeDAgPSArX1swXSksIHQxID0gdHJhbnNmb3JtKHgxID0gK19bMV0pLCB0MiA9IHRyYW5zZm9ybSh4MiA9ICtfWzJdKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDAuNSAvICh0MSAtIHQwKSwgazIxID0gdDEgPT09IHQyID8gMCA6IDAuNSAvICh0MiAtIHQxKSwgc2NhbGUpIDogW3gwLCB4MSwgeDJdO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCBzY2FsZSkgOiBjbGFtcDtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB0MCA9IHQoeDApLCB0MSA9IHQoeDEpLCB0MiA9IHQoeDIpLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMC41IC8gKHQxIC0gdDApLCBrMjEgPSB0MSA9PT0gdDIgPyAwIDogMC41IC8gKHQyIC0gdDEpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGl2ZXJnaW5nKCkge1xuICB2YXIgc2NhbGUgPSBsaW5lYXJpc2godHJhbnNmb3JtZXIoKShpZGVudGl0eSkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2ZXJnaW5nTG9nKCkge1xuICB2YXIgc2NhbGUgPSBsb2dnaXNoKHRyYW5zZm9ybWVyKCkpLmRvbWFpbihbMC4xLCAxLCAxMF0pO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nTG9nKCkpLmJhc2Uoc2NhbGUuYmFzZSgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ1N5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nU3ltbG9nKCkpLmNvbnN0YW50KHNjYWxlLmNvbnN0YW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2ZXJnaW5nUG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBkaXZlcmdpbmdQb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZlcmdpbmdTcXJ0KCkge1xuICByZXR1cm4gZGl2ZXJnaW5nUG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cbiIsImV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVCYW5kLFxuICBwb2ludCBhcyBzY2FsZVBvaW50XG59IGZyb20gXCIuL2JhbmRcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZUlkZW50aXR5XG59IGZyb20gXCIuL2lkZW50aXR5XCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVMaW5lYXJcbn0gZnJvbSBcIi4vbGluZWFyXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVMb2dcbn0gZnJvbSBcIi4vbG9nXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVTeW1sb2dcbn0gZnJvbSBcIi4vc3ltbG9nXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVPcmRpbmFsLFxuICBpbXBsaWNpdCBhcyBzY2FsZUltcGxpY2l0XG59IGZyb20gXCIuL29yZGluYWxcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVBvdyxcbiAgc3FydCBhcyBzY2FsZVNxcnRcbn0gZnJvbSBcIi4vcG93XCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVRdWFudGlsZVxufSBmcm9tIFwiLi9xdWFudGlsZVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlUXVhbnRpemVcbn0gZnJvbSBcIi4vcXVhbnRpemVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVRocmVzaG9sZFxufSBmcm9tIFwiLi90aHJlc2hvbGRcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVRpbWVcbn0gZnJvbSBcIi4vdGltZVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlVXRjXG59IGZyb20gXCIuL3V0Y1RpbWVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVNlcXVlbnRpYWwsXG4gIHNlcXVlbnRpYWxMb2cgYXMgc2NhbGVTZXF1ZW50aWFsTG9nLFxuICBzZXF1ZW50aWFsUG93IGFzIHNjYWxlU2VxdWVudGlhbFBvdyxcbiAgc2VxdWVudGlhbFNxcnQgYXMgc2NhbGVTZXF1ZW50aWFsU3FydCxcbiAgc2VxdWVudGlhbFN5bWxvZyBhcyBzY2FsZVNlcXVlbnRpYWxTeW1sb2dcbn0gZnJvbSBcIi4vc2VxdWVudGlhbFwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlU2VxdWVudGlhbFF1YW50aWxlXG59IGZyb20gXCIuL3NlcXVlbnRpYWxRdWFudGlsZVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlRGl2ZXJnaW5nLFxuICBkaXZlcmdpbmdMb2cgYXMgc2NhbGVEaXZlcmdpbmdMb2csXG4gIGRpdmVyZ2luZ1BvdyBhcyBzY2FsZURpdmVyZ2luZ1BvdyxcbiAgZGl2ZXJnaW5nU3FydCBhcyBzY2FsZURpdmVyZ2luZ1NxcnQsXG4gIGRpdmVyZ2luZ1N5bWxvZyBhcyBzY2FsZURpdmVyZ2luZ1N5bWxvZ1xufSBmcm9tIFwiLi9kaXZlcmdpbmdcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB0aWNrRm9ybWF0XG59IGZyb20gXCIuL3RpY2tGb3JtYXRcIjtcbiIsImltcG9ydCB7IHNjYWxlQmFuZCwgc2NhbGVQb2ludCwgc2NhbGVMaW5lYXIsIHNjYWxlVGltZSwgc2NhbGVVdGMsIHNjYWxlTG9nLCBzY2FsZVBvdywgc2NhbGVPcmRpbmFsLCBzY2FsZVF1YW50aXplLCBzY2FsZVF1YW50aWxlLCBzY2FsZVRocmVzaG9sZCB9IGZyb20gJ2QzLXNjYWxlJztcblxudmFyIGJhbmQgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIHBhZGRpbmcgPSBfcmVmLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nSW5uZXIgPSBfcmVmLnBhZGRpbmdJbm5lcixcbiAgICAgIHBhZGRpbmdPdXRlciA9IF9yZWYucGFkZGluZ091dGVyLFxuICAgICAgYWxpZ24gPSBfcmVmLmFsaWduLFxuICAgICAgdGlja0Zvcm1hdCA9IF9yZWYudGlja0Zvcm1hdDtcblxuICB2YXIgc2NhbGUgPSBzY2FsZUJhbmQoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAocGFkZGluZykgc2NhbGUucGFkZGluZyhwYWRkaW5nKTtcbiAgaWYgKHBhZGRpbmdJbm5lcikgc2NhbGUucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcik7XG4gIGlmIChwYWRkaW5nT3V0ZXIpIHNjYWxlLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpO1xuICBpZiAoYWxpZ24pIHNjYWxlLmFsaWduKGFsaWduKTtcbiAgaWYgKHRpY2tGb3JtYXQpIHNjYWxlLnRpY2tGb3JtYXQgPSB0aWNrRm9ybWF0O1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgcG9pbnQgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIHBhZGRpbmcgPSBfcmVmLnBhZGRpbmcsXG4gICAgICBhbGlnbiA9IF9yZWYuYWxpZ24sXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZTtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVBvaW50KCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChyYW5nZVJvdW5kKSBzY2FsZS5yYW5nZVJvdW5kKHJhbmdlUm91bmQpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgaWYgKG5pY2UpIHNjYWxlLm5pY2UoKTtcbiAgaWYgKHBhZGRpbmcpIHNjYWxlLnBhZGRpbmcocGFkZGluZyk7XG4gIGlmIChhbGlnbikgc2NhbGUuYWxpZ24oYWxpZ24pO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgbGluZWFyID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZSxcbiAgICAgIF9yZWYkY2xhbXAgPSBfcmVmLmNsYW1wLFxuICAgICAgY2xhbXAgPSBfcmVmJGNsYW1wID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkY2xhbXA7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVMaW5lYXIoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAoY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgdGltZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgcmFuZ2VSb3VuZCA9IF9yZWYucmFuZ2VSb3VuZCxcbiAgICAgIGRvbWFpbiA9IF9yZWYuZG9tYWluLFxuICAgICAgX3JlZiRuaWNlID0gX3JlZi5uaWNlLFxuICAgICAgbmljZSA9IF9yZWYkbmljZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG5pY2UsXG4gICAgICBfcmVmJGNsYW1wID0gX3JlZi5jbGFtcCxcbiAgICAgIGNsYW1wID0gX3JlZiRjbGFtcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGNsYW1wO1xuXG4gIHZhciBzY2FsZSA9IHNjYWxlVGltZSgpO1xuXG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UocmFuZ2UpO1xuICBpZiAocmFuZ2VSb3VuZCkgc2NhbGUucmFuZ2VSb3VuZChyYW5nZVJvdW5kKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIGlmIChuaWNlKSBzY2FsZS5uaWNlKCk7XG4gIGlmIChjbGFtcCkgc2NhbGUuY2xhbXAodHJ1ZSk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciB1dGMgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIF9yZWYkbmljZSA9IF9yZWYubmljZSxcbiAgICAgIG5pY2UgPSBfcmVmJG5pY2UgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRuaWNlLFxuICAgICAgX3JlZiRjbGFtcCA9IF9yZWYuY2xhbXAsXG4gICAgICBjbGFtcCA9IF9yZWYkY2xhbXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRjbGFtcDtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVV0YygpO1xuXG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UocmFuZ2UpO1xuICBpZiAocmFuZ2VSb3VuZCkgc2NhbGUucmFuZ2VSb3VuZChyYW5nZVJvdW5kKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIGlmIChuaWNlKSBzY2FsZS5uaWNlKCk7XG4gIGlmIChjbGFtcCkgc2NhbGUuY2xhbXAodHJ1ZSk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBsb2cgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIGJhc2UgPSBfcmVmLmJhc2UsXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZSxcbiAgICAgIF9yZWYkY2xhbXAgPSBfcmVmLmNsYW1wLFxuICAgICAgY2xhbXAgPSBfcmVmJGNsYW1wID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkY2xhbXA7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVMb2coKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAoY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuICBpZiAoYmFzZSkgc2NhbGUuYmFzZShiYXNlKTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHBvd2VyID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBleHBvbmVudCA9IF9yZWYuZXhwb25lbnQsXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZSxcbiAgICAgIF9yZWYkY2xhbXAgPSBfcmVmLmNsYW1wLFxuICAgICAgY2xhbXAgPSBfcmVmJGNsYW1wID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkY2xhbXA7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVQb3coKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAoY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuICBpZiAoZXhwb25lbnQpIHNjYWxlLmV4cG9uZW50KGV4cG9uZW50KTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIG9yZGluYWwgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIGRvbWFpbiA9IF9yZWYuZG9tYWluLFxuICAgICAgdW5rbm93biA9IF9yZWYudW5rbm93bjtcblxuICB2YXIgc2NhbGUgPSBzY2FsZU9yZGluYWwoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIGlmICh1bmtub3duKSBzY2FsZS51bmtub3duKHVua25vd24pO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgcXVhbnRpemUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIGRvbWFpbiA9IF9yZWYuZG9tYWluLFxuICAgICAgdGlja3MgPSBfcmVmLnRpY2tzLFxuICAgICAgdGlja0Zvcm1hdCA9IF9yZWYudGlja0Zvcm1hdCxcbiAgICAgIF9yZWYkbmljZSA9IF9yZWYubmljZSxcbiAgICAgIG5pY2UgPSBfcmVmJG5pY2UgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRuaWNlO1xuXG4gIHZhciBzY2FsZSA9IHNjYWxlUXVhbnRpemUoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIGlmIChuaWNlKSBzY2FsZS5uaWNlKCk7XG4gIGlmICh0aWNrcykgc2NhbGUudGlja3ModGlja3MpO1xuICBpZiAodGlja0Zvcm1hdCkgc2NhbGUudGlja0Zvcm1hdCh0aWNrRm9ybWF0KTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHF1YW50aWxlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbjtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVF1YW50aWxlKCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgdGhyZXNob2xkID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbjtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVRocmVzaG9sZCgpO1xuXG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UocmFuZ2UpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVTY2FsZShzY2FsZSwgX3JlZikge1xuICB2YXIgYXJncyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtdKTtcblxuICB2YXIgbmV4dFNjYWxlID0gc2NhbGUuY29weSgpO1xuICBPYmplY3Qua2V5cyhhcmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAobmV4dFNjYWxlLmhhc093blByb3BlcnR5KGtleSkpIG5leHRTY2FsZVtrZXldKGFyZ3Nba2V5XSk7XG4gIH0pO1xuICByZXR1cm4gbmV4dFNjYWxlO1xufVxuXG5leHBvcnQgeyBiYW5kIGFzIHNjYWxlQmFuZCwgcG9pbnQgYXMgc2NhbGVQb2ludCwgbGluZWFyIGFzIHNjYWxlTGluZWFyLCB0aW1lIGFzIHNjYWxlVGltZSwgdXRjIGFzIHNjYWxlVXRjLCBsb2cgYXMgc2NhbGVMb2csIHBvd2VyIGFzIHNjYWxlUG93ZXIsIG9yZGluYWwgYXMgc2NhbGVPcmRpbmFsLCBxdWFudGl6ZSBhcyBzY2FsZVF1YW50aXplLCBxdWFudGlsZSBhcyBzY2FsZVF1YW50aWxlLCB0aHJlc2hvbGQgYXMgc2NhbGVUaHJlc2hvbGQsIHVwZGF0ZVNjYWxlIH07XG4iLCJmdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCB7IHNjYWxlTGluZWFyLCBzY2FsZVRpbWUsIHNjYWxlVXRjLCBzY2FsZUJhbmQsIHNjYWxlT3JkaW5hbCB9IGZyb20gJ0B2eC9zY2FsZSc7XG5pbXBvcnQgeyBleHRlbnQgfSBmcm9tICdkMy1hcnJheSc7XG5leHBvcnQgdmFyIHNjYWxlVHlwZVRvU2NhbGUgPSB7XG4gIHRpbWU6IHNjYWxlVGltZSxcbiAgdGltZVV0Yzogc2NhbGVVdGMsXG4gIGxpbmVhcjogc2NhbGVMaW5lYXIsXG4gIGJhbmQ6IHNjYWxlQmFuZCxcbiAgb3JkaW5hbDogc2NhbGVPcmRpbmFsXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2NhbGVGb3JBY2Nlc3NvcihfcmVmKSB7XG4gIHZhciBhbGxEYXRhID0gX3JlZi5hbGxEYXRhLFxuICAgICAgbWluQWNjZXNzb3IgPSBfcmVmLm1pbkFjY2Vzc29yLFxuICAgICAgbWF4QWNjZXNzb3IgPSBfcmVmLm1heEFjY2Vzc29yLFxuICAgICAgdHlwZSA9IF9yZWYudHlwZSxcbiAgICAgIF9yZWYkaW5jbHVkZVplcm8gPSBfcmVmLmluY2x1ZGVaZXJvLFxuICAgICAgaW5jbHVkZVplcm8gPSBfcmVmJGluY2x1ZGVaZXJvID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRpbmNsdWRlWmVybyxcbiAgICAgIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJhbGxEYXRhXCIsIFwibWluQWNjZXNzb3JcIiwgXCJtYXhBY2Nlc3NvclwiLCBcInR5cGVcIiwgXCJpbmNsdWRlWmVyb1wiLCBcInJhbmdlXCJdKTtcblxuICB2YXIgZG9tYWluO1xuXG4gIGlmICh0eXBlID09PSAnYmFuZCcgfHwgdHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgZG9tYWluID0gYWxsRGF0YS5tYXAobWluQWNjZXNzb3IpO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdsaW5lYXInIHx8IHR5cGUgPT09ICd0aW1lJyB8fCB0eXBlID09PSAndGltZVV0YycpIHtcbiAgICB2YXIgX2V4dGVudCA9IGV4dGVudChbXS5jb25jYXQoZXh0ZW50KGFsbERhdGEsIG1pbkFjY2Vzc29yKSwgZXh0ZW50KGFsbERhdGEsIG1heEFjY2Vzc29yKSkpLFxuICAgICAgICBtaW4gPSBfZXh0ZW50WzBdLFxuICAgICAgICBtYXggPSBfZXh0ZW50WzFdO1xuXG4gICAgZG9tYWluID0gW3R5cGUgPT09ICdsaW5lYXInICYmIGluY2x1ZGVaZXJvID8gTWF0aC5taW4oMCwgbWluKSA6IG1pbiwgdHlwZSA9PT0gJ2xpbmVhcicgJiYgaW5jbHVkZVplcm8gPyBNYXRoLm1heCgwLCBtYXgpIDogbWF4XTtcbiAgfVxuXG4gIHJldHVybiBzY2FsZVR5cGVUb1NjYWxlW3R5cGVdKF9leHRlbmRzKHtcbiAgICBkb21haW46IGRvbWFpbixcbiAgICByYW5nZTogcmFuZ2VcbiAgfSwgcmVzdCkpO1xufSIsImZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmltcG9ydCB7IENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNvbGxlY3REYXRhRnJvbUNoaWxkU2VyaWVzIGZyb20gJy4vY29sbGVjdERhdGFGcm9tQ2hpbGRTZXJpZXMnOyAvLyBpbXBvcnQgY29sbGVjdEV4dGVudHNGcm9tQ2hpbGRTZXJpZXMgZnJvbSAnLi9jb2xsZWN0RXh0ZW50c0Zyb21DaGlsZFNlcmllcyc7XG5cbmltcG9ydCBnZXRDaGFydERpbWVuc2lvbnMgZnJvbSAnLi9nZXRDaGFydERpbWVuc2lvbnMnO1xuaW1wb3J0IGdldFNjYWxlRm9yQWNjZXNzb3IgZnJvbSAnLi9nZXRTY2FsZUZvckFjY2Vzc29yJztcbmltcG9ydCB7IGNvbXBvbmVudE5hbWUsIGlzQmFyU2VyaWVzLCBpc0NpcmNsZVBhY2tTZXJpZXMgfSBmcm9tICcuL2NoYXJ0VXRpbHMnO1xuXG52YXIgZ2V0WCA9IGZ1bmN0aW9uIGdldFgoZCkge1xuICByZXR1cm4gZCAmJiBkLng7XG59O1xuXG52YXIgeFN0cmluZyA9IGZ1bmN0aW9uIHhTdHJpbmcoZCkge1xuICByZXR1cm4gZ2V0WChkKS50b1N0cmluZygpO1xufTtcblxudmFyIGdldFkgPSBmdW5jdGlvbiBnZXRZKGQpIHtcbiAgcmV0dXJuIGQgJiYgZC55O1xufTtcblxudmFyIHlTdHJpbmcgPSBmdW5jdGlvbiB5U3RyaW5nKGQpIHtcbiAgcmV0dXJuIGdldFkoZCkudG9TdHJpbmcoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbGxlY3RTY2FsZXNGcm9tUHJvcHMocHJvcHMpIHtcbiAgdmFyIHhTY2FsZU9iamVjdCA9IHByb3BzLnhTY2FsZSxcbiAgICAgIHlTY2FsZU9iamVjdCA9IHByb3BzLnlTY2FsZSxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgdmFyIF9nZXRDaGFydERpbWVuc2lvbnMgPSBnZXRDaGFydERpbWVuc2lvbnMocHJvcHMpLFxuICAgICAgaW5uZXJXaWR0aCA9IF9nZXRDaGFydERpbWVuc2lvbnMuaW5uZXJXaWR0aCxcbiAgICAgIGlubmVySGVpZ2h0ID0gX2dldENoYXJ0RGltZW5zaW9ucy5pbm5lckhlaWdodDtcblxuICB2YXIgYWxsRGF0YSA9IGNvbGxlY3REYXRhRnJvbUNoaWxkU2VyaWVzKGNoaWxkcmVuKTsgLy8gVE9ETyBjb3VsZCBjb2xsZWN0IGRhdGEgZXh0ZW50cyBmcm9tIGNoaWxkIHNlcmllc1xuICAvLyB3aGljaCB3b3VsZCBzdXBwb3J0IHBhc3NpbmcgYXJiaXRyYXJ5IHgveSBhY2Nlc3NvcnNcbiAgLy8gY29uc3QgW3hFeHRlbnQsIHlFeHRlbnRdID0gY29sbGVjdEV4dGVudHNGcm9tQ2hpbGRTZXJpZXMoY2hpbGRyZW4pO1xuICAvLyBpc3N1ZXM6XG4gIC8vICB2b3Jvbm9pIHRyYW5zZm9ybXMgZGF0YSB2aWEgc2NhbGUoZ2V0WG9yWShkKSlcbiAgLy8gICAgPT4gQ291bGQgYmUgc29sdmVkIGJ5IHRyYW5zZm9ybWluZyBpbiBkYXRhIGNvbGxlY3Rpb25cbiAgLy8gIHRvb2x0aXAvY3Jvc3NoYWlyIHRyYW5zZm9ybXMgZGF0YSB2aWEgc2NhbGUoZ2V0WG9yWShkKSlcbiAgLy8gICAgPT4gY291bGQgYmUgc29sdmVkIGJ5IHRyYW5zZm9ybWluZyBpbiB0aGUgbW91c2Vtb3ZlIGNhbGwgc28gc2VyaWVzIG93biBpdD9cblxuICB2YXIgeFNjYWxlID0gZ2V0U2NhbGVGb3JBY2Nlc3NvcihfZXh0ZW5kcyh7XG4gICAgYWxsRGF0YTogYWxsRGF0YSxcbiAgICBtaW5BY2Nlc3NvcjogZnVuY3Rpb24gbWluQWNjZXNzb3IoZCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBkLngwID09PSAndW5kZWZpbmVkJyA/IGQueCA6IGQueDA7XG4gICAgfSxcbiAgICBtYXhBY2Nlc3NvcjogZnVuY3Rpb24gbWF4QWNjZXNzb3IoZCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBkLngxID09PSAndW5kZWZpbmVkJyA/IGQueCA6IGQueDE7XG4gICAgfSxcbiAgICByYW5nZTogWzAsIGlubmVyV2lkdGhdXG4gIH0sIHhTY2FsZU9iamVjdCkpO1xuICB2YXIgeVNjYWxlID0gZ2V0U2NhbGVGb3JBY2Nlc3NvcihfZXh0ZW5kcyh7XG4gICAgYWxsRGF0YTogYWxsRGF0YSxcbiAgICBtaW5BY2Nlc3NvcjogZnVuY3Rpb24gbWluQWNjZXNzb3IoZCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBkLnkwID09PSAndW5kZWZpbmVkJyA/IGQueSA6IGQueTA7XG4gICAgfSxcbiAgICBtYXhBY2Nlc3NvcjogZnVuY3Rpb24gbWF4QWNjZXNzb3IoZCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBkLnkxID09PSAndW5kZWZpbmVkJyA/IGQueSA6IGQueTE7XG4gICAgfSxcbiAgICByYW5nZTogW2lubmVySGVpZ2h0LCAwXVxuICB9LCB5U2NhbGVPYmplY3QpKTtcbiAgQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKENoaWxkKSB7XG4gICAgLy8gQ2hpbGQtc3BlY2lmaWMgc2NhbGVzIG9yIGFkanVzdG1lbnRzIGhlcmVcbiAgICB2YXIgbmFtZSA9IGNvbXBvbmVudE5hbWUoQ2hpbGQpO1xuXG4gICAgaWYgKGlzQmFyU2VyaWVzKG5hbWUpKSB7XG4gICAgICB2YXIgaG9yaXpvbnRhbCA9IENoaWxkLnByb3BzLmhvcml6b250YWw7XG4gICAgICB2YXIgY2F0ZWdvcnlTY2FsZU9iamVjdCA9IGhvcml6b250YWwgPyB5U2NhbGVPYmplY3QgOiB4U2NhbGVPYmplY3Q7XG5cbiAgICAgIGlmIChjYXRlZ29yeVNjYWxlT2JqZWN0LnR5cGUgIT09ICdiYW5kJykge1xuICAgICAgICB2YXIgY2F0ZWdvcnlTY2FsZSA9IGhvcml6b250YWwgPyB5U2NhbGUgOiB4U2NhbGU7XG4gICAgICAgIHZhciByYW5nZSA9IGhvcml6b250YWwgPyBpbm5lckhlaWdodCA6IGlubmVyV2lkdGg7XG4gICAgICAgIHZhciBkdW1teUJhbmQgPSBnZXRTY2FsZUZvckFjY2Vzc29yKHtcbiAgICAgICAgICBhbGxEYXRhOiBhbGxEYXRhLFxuICAgICAgICAgIG1pbkFjY2Vzc29yOiBob3Jpem9udGFsID8geVN0cmluZyA6IHhTdHJpbmcsXG4gICAgICAgICAgbWF4QWNjZXNzb3I6IGhvcml6b250YWwgPyB5U3RyaW5nIDogeFN0cmluZyxcbiAgICAgICAgICB0eXBlOiAnYmFuZCcsXG4gICAgICAgICAgcmFuZ2VSb3VuZDogWzAsIHJhbmdlXSxcbiAgICAgICAgICBwYWRkaW5nT3V0ZXI6IDFcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBkdW1teUJhbmQuYmFuZHdpZHRoKCkgLyAyO1xuICAgICAgICBjYXRlZ29yeVNjYWxlLnJhbmdlKFtvZmZzZXQsIHJhbmdlIC0gb2Zmc2V0XSk7XG4gICAgICAgIGNhdGVnb3J5U2NhbGUuYmFyV2lkdGggPSBkdW1teUJhbmQuYmFuZHdpZHRoKCk7XG4gICAgICAgIGNhdGVnb3J5U2NhbGUub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0NpcmNsZVBhY2tTZXJpZXMobmFtZSkpIHtcbiAgICAgIHlTY2FsZS5kb21haW4oWy1pbm5lckhlaWdodCAvIDIsIGlubmVySGVpZ2h0IC8gMl0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgeFNjYWxlOiB4U2NhbGUsXG4gICAgeVNjYWxlOiB5U2NhbGVcbiAgfTtcbn0iLCJmdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgR3JpZENvbHVtbnMsIEdyaWRSb3dzIH0gZnJvbSAnQHZ4L2dyaWQnO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICdAdngvZ3JvdXAnO1xuaW1wb3J0IHsgV2l0aFRvb2x0aXAgfSBmcm9tICdAZGF0YS11aS9zaGFyZWQnO1xuaW1wb3J0IGNvbGxlY3RWb3Jvbm9pRGF0YSBmcm9tICcuLi91dGlscy9jb2xsZWN0Vm9yb25vaURhdGEnO1xuaW1wb3J0IGZpbmRDbG9zZXN0RGF0dW1zIGZyb20gJy4uL3V0aWxzL2ZpbmRDbG9zZXN0RGF0dW1zJztcbmltcG9ydCBzaGFsbG93Q29tcGFyZU9iamVjdEVudHJpZXMgZnJvbSAnLi4vdXRpbHMvc2hhbGxvd0NvbXBhcmVPYmplY3RFbnRyaWVzJztcbmltcG9ydCBWb3Jvbm9pIGZyb20gJy4vVm9yb25vaSc7XG5pbXBvcnQgeyBjb21wb25lbnROYW1lLCBpc0F4aXMsIGlzQ3Jvc3NIYWlyLCBpc0RlZmluZWQsIGlzUmVmZXJlbmNlTGluZSwgaXNTZXJpZXMsIGlzQnJ1c2gsIGdldENoaWxkV2l0aE5hbWUsIG51bVRpY2tzRm9yV2lkdGgsIG51bVRpY2tzRm9ySGVpZ2h0LCBwcm9wT3JGYWxsYmFjaywgREVGQVVMVF9DSEFSVF9NQVJHSU4gfSBmcm9tICcuLi91dGlscy9jaGFydFV0aWxzJztcbmltcG9ydCBjb2xsZWN0U2NhbGVzRnJvbVByb3BzIGZyb20gJy4uL3V0aWxzL2NvbGxlY3RTY2FsZXNGcm9tUHJvcHMnO1xuaW1wb3J0IGdldENoYXJ0RGltZW5zaW9ucyBmcm9tICcuLi91dGlscy9nZXRDaGFydERpbWVuc2lvbnMnO1xuaW1wb3J0IHsgc2NhbGVTaGFwZSwgdGhlbWVTaGFwZSwgc3RyaW5nTnVtYmVyRGF0ZU9iamVjdFByb3BUeXBlIH0gZnJvbSAnLi4vdXRpbHMvcHJvcFNoYXBlcyc7XG5leHBvcnQgdmFyIENPTlRBSU5FUl9UUklHR0VSID0gJ2NvbnRhaW5lcic7XG5leHBvcnQgdmFyIFNFUklFU19UUklHR0VSID0gJ3Nlcmllcyc7XG5leHBvcnQgdmFyIFZPUk9OT0lfVFJJR0dFUiA9ICd2b3Jvbm9pJztcbnZhciBZX0xBQkVMX09GRlNFVCA9IDAuNztcbmV4cG9ydCB2YXIgcHJvcFR5cGVzID0ge1xuICBhcmlhTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBkaXNhYmxlTW91c2VFdmVudHM6IFByb3BUeXBlcy5ib29sLFxuICBldmVudFRyaWdnZXI6IFByb3BUeXBlcy5vbmVPZihbQ09OVEFJTkVSX1RSSUdHRVIsIFNFUklFU19UUklHR0VSLCBWT1JPTk9JX1RSSUdHRVJdKSxcbiAgZXZlbnRUcmlnZ2VyUmVmczogUHJvcFR5cGVzLmZ1bmMsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIG1hcmdpbjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgcmlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgYm90dG9tOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGxlZnQ6IFByb3BUeXBlcy5udW1iZXJcbiAgfSksXG4gIHJlbmRlclRvb2x0aXA6IFByb3BUeXBlcy5mdW5jLFxuICBzaG93WEdyaWQ6IFByb3BUeXBlcy5ib29sLFxuICB4R3JpZFZhbHVlczogUHJvcFR5cGVzLmFycmF5T2Yoc3RyaW5nTnVtYmVyRGF0ZU9iamVjdFByb3BUeXBlKSxcbiAgeEdyaWRPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNob3dZR3JpZDogUHJvcFR5cGVzLmJvb2wsXG4gIHlHcmlkVmFsdWVzOiBQcm9wVHlwZXMuYXJyYXlPZihzdHJpbmdOdW1iZXJEYXRlT2JqZWN0UHJvcFR5cGUpLFxuICB5R3JpZE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgc2hvd1Zvcm9ub2k6IFByb3BUeXBlcy5ib29sLFxuICBzbmFwVG9vbHRpcFRvRGF0YVg6IFByb3BUeXBlcy5ib29sLFxuICBzbmFwVG9vbHRpcFRvRGF0YVk6IFByb3BUeXBlcy5ib29sLFxuICB0aGVtZTogdGhlbWVTaGFwZSxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgeFNjYWxlOiBzY2FsZVNoYXBlLmlzUmVxdWlyZWQsXG4gIHlTY2FsZTogc2NhbGVTaGFwZS5pc1JlcXVpcmVkLFxuICAvLyB0aGVzZSBtYXkgYmUgcGFzc2VkIGZyb20gV2l0aFRvb2x0aXBcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIC8vIGV4cGVjdHMgdG8gYmUgY2FsbGVkIGxpa2UgZnVuYyh7IGV2ZW50LCBkYXR1bSB9KVxuICBvbk1vdXNlTW92ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIC8vIGV4cGVjdHMgdG8gYmUgY2FsbGVkIGxpa2UgZnVuYyh7IGV2ZW50LCBkYXR1bSB9KVxuICBvbk1vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuICAvLyBleHBlY3RzIHRvIGJlIGNhbGxlZCBsaWtlIGZ1bmMoeyBldmVudCwgZGF0dW0gfSlcbiAgdG9vbHRpcERhdGE6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZXZlbnQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgZGF0dW06IFByb3BUeXBlcy5vYmplY3QsXG4gICAgc2VyaWVzOiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pXG59O1xuZXhwb3J0IHZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBkaXNhYmxlTW91c2VFdmVudHM6IGZhbHNlLFxuICBldmVudFRyaWdnZXI6IFNFUklFU19UUklHR0VSLFxuICBldmVudFRyaWdnZXJSZWZzOiBudWxsLFxuICBpbm5lclJlZjogbnVsbCxcbiAgbWFyZ2luOiBERUZBVUxUX0NIQVJUX01BUkdJTixcbiAgcmVuZGVyVG9vbHRpcDogbnVsbCxcbiAgc2hvd1Zvcm9ub2k6IGZhbHNlLFxuICBzaG93WEdyaWQ6IGZhbHNlLFxuICB4R3JpZFZhbHVlczogbnVsbCxcbiAgeEdyaWRPZmZzZXQ6IG51bGwsXG4gIHNob3dZR3JpZDogZmFsc2UsXG4gIHlHcmlkVmFsdWVzOiBudWxsLFxuICB5R3JpZE9mZnNldDogbnVsbCxcbiAgc25hcFRvb2x0aXBUb0RhdGFYOiBmYWxzZSxcbiAgc25hcFRvb2x0aXBUb0RhdGFZOiBmYWxzZSxcbiAgdGhlbWU6IHt9LFxuICBvbkNsaWNrOiBudWxsLFxuICBvbk1vdXNlTW92ZTogbnVsbCxcbiAgb25Nb3VzZUxlYXZlOiBudWxsLFxuICB0b29sdGlwRGF0YTogbnVsbFxufTsgLy8gYWNjZXNzb3JzXG5cbnZhciBnZXRYID0gZnVuY3Rpb24gZ2V0WChkKSB7XG4gIHJldHVybiBkICYmIGQueDtcbn07XG5cbnZhciBnZXRZID0gZnVuY3Rpb24gZ2V0WShkKSB7XG4gIHJldHVybiBkICYmIGQueTtcbn07XG5cbnZhciBYWUNoYXJ0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShYWUNoYXJ0LCBfUmVhY3QkUHVyZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gWFlDaGFydChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JFB1cmVDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpczsgLy8gaWYgcmVuZGVyVG9vbHRpcCBpcyBwYXNzZWQgd2UgcmV0dXJuIGFub3RoZXIgWFlDaGFydCB3cmFwcGVkIGluIFdpdGhUb29sdGlwXG4gICAgLy8gdGhlcmVmb3JlIHdlIGRvbid0IHdhbnQgdG8gY29tcHV0ZSBzdGF0ZSBpZiB0aGUgbmVzdGVkIGNoYXJ0IHdpbGwgZG8gc29cblxuICAgIF90aGlzLnN0YXRlID0gcHJvcHMucmVuZGVyVG9vbHRpcCA/IHt9IDogWFlDaGFydC5nZXRTdGF0ZUZyb21Qcm9wcyhwcm9wcyk7XG4gICAgX3RoaXMuZ2V0RGF0dW1Db29yZHMgPSBfdGhpcy5nZXREYXR1bUNvb3Jkcy5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcbiAgICBfdGhpcy5oYW5kbGVDbGljayA9IF90aGlzLmhhbmRsZUNsaWNrLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuICAgIF90aGlzLmhhbmRsZU1vdXNlTGVhdmUgPSBfdGhpcy5oYW5kbGVNb3VzZUxlYXZlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuICAgIF90aGlzLmhhbmRsZU1vdXNlTW92ZSA9IF90aGlzLmhhbmRsZU1vdXNlTW92ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcbiAgICBfdGhpcy5oYW5kbGVNb3VzZURvd24gPSBfdGhpcy5oYW5kbGVNb3VzZURvd24uYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG4gICAgX3RoaXMuaGFuZGxlQ29udGFpbmVyRXZlbnQgPSBfdGhpcy5oYW5kbGVDb250YWluZXJFdmVudC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gWFlDaGFydC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcmVuZGVyVG9vbHRpcCA9IF90aGlzJHByb3BzLnJlbmRlclRvb2x0aXAsXG4gICAgICAgIGV2ZW50VHJpZ2dlclJlZnMgPSBfdGhpcyRwcm9wcy5ldmVudFRyaWdnZXJSZWZzO1xuXG4gICAgaWYgKCFyZW5kZXJUb29sdGlwICYmIGV2ZW50VHJpZ2dlclJlZnMpIHtcbiAgICAgIGV2ZW50VHJpZ2dlclJlZnMoe1xuICAgICAgICBtb3VzZW1vdmU6IHRoaXMuaGFuZGxlTW91c2VNb3ZlLFxuICAgICAgICBtb3VzZWxlYXZlOiB0aGlzLmhhbmRsZU1vdXNlTGVhdmUsXG4gICAgICAgIGNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHNob3VsZENvbXB1dGVTY2FsZXMgPSBmYWxzZTtcblxuICAgIGlmIChbJ3dpZHRoJywgJ2hlaWdodCcsICdjaGlsZHJlbiddLnNvbWUoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiBfdGhpczIucHJvcHNbcHJvcF0gIT09IG5leHRQcm9wc1twcm9wXTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3QvZGVzdHJ1Y3R1cmluZy1hc3NpZ25tZW50XG4gICAgKSkge1xuICAgICAgc2hvdWxkQ29tcHV0ZVNjYWxlcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFsnbWFyZ2luJywgJ3hTY2FsZScsICd5U2NhbGUnXS5zb21lKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGVzdHJ1Y3R1cmluZy1hc3NpZ25tZW50XG4gICAgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAhc2hhbGxvd0NvbXBhcmVPYmplY3RFbnRyaWVzKF90aGlzMi5wcm9wc1twcm9wXSwgbmV4dFByb3BzW3Byb3BdKTtcbiAgICB9KSkge1xuICAgICAgc2hvdWxkQ29tcHV0ZVNjYWxlcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZENvbXB1dGVTY2FsZXMpIHRoaXMuc2V0U3RhdGUoWFlDaGFydC5nZXRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMpKTtcbiAgfTtcblxuICBYWUNoYXJ0LmdldFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0U3RhdGVGcm9tUHJvcHMocHJvcHMpIHtcbiAgICB2YXIgX2dldENoYXJ0RGltZW5zaW9ucyA9IGdldENoYXJ0RGltZW5zaW9ucyhwcm9wcyksXG4gICAgICAgIG1hcmdpbiA9IF9nZXRDaGFydERpbWVuc2lvbnMubWFyZ2luLFxuICAgICAgICBpbm5lcldpZHRoID0gX2dldENoYXJ0RGltZW5zaW9ucy5pbm5lcldpZHRoLFxuICAgICAgICBpbm5lckhlaWdodCA9IF9nZXRDaGFydERpbWVuc2lvbnMuaW5uZXJIZWlnaHQ7XG5cbiAgICB2YXIgX2NvbGxlY3RTY2FsZXNGcm9tUHJvID0gY29sbGVjdFNjYWxlc0Zyb21Qcm9wcyhwcm9wcyksXG4gICAgICAgIHhTY2FsZSA9IF9jb2xsZWN0U2NhbGVzRnJvbVByby54U2NhbGUsXG4gICAgICAgIHlTY2FsZSA9IF9jb2xsZWN0U2NhbGVzRnJvbVByby55U2NhbGU7XG5cbiAgICB2YXIgdm9yb25vaURhdGEgPSBjb2xsZWN0Vm9yb25vaURhdGEoe1xuICAgICAgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuLFxuICAgICAgZ2V0WDogZ2V0WCxcbiAgICAgIGdldFk6IGdldFlcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5uZXJIZWlnaHQ6IGlubmVySGVpZ2h0LFxuICAgICAgaW5uZXJXaWR0aDogaW5uZXJXaWR0aCxcbiAgICAgIG1hcmdpbjogbWFyZ2luLFxuICAgICAgeFNjYWxlOiB4U2NhbGUsXG4gICAgICB5U2NhbGU6IHlTY2FsZSxcbiAgICAgIHZvcm9ub2lEYXRhOiB2b3Jvbm9pRGF0YSxcbiAgICAgIHZvcm9ub2lYOiBmdW5jdGlvbiB2b3Jvbm9pWChkKSB7XG4gICAgICAgIHJldHVybiB4U2NhbGUoZ2V0WChkKSk7XG4gICAgICB9LFxuICAgICAgdm9yb25vaVk6IGZ1bmN0aW9uIHZvcm9ub2lZKGQpIHtcbiAgICAgICAgcmV0dXJuIHlTY2FsZShnZXRZKGQpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXROdW1UaWNrc0FuZEdyaWRWYWx1ZXMgPSBmdW5jdGlvbiBnZXROdW1UaWNrc0FuZEdyaWRWYWx1ZXMoaW5uZXJXaWR0aCwgaW5uZXJIZWlnaHQpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczIuY2hpbGRyZW4sXG4gICAgICAgIHhHcmlkVmFsdWVzID0gX3RoaXMkcHJvcHMyLnhHcmlkVmFsdWVzLFxuICAgICAgICB5R3JpZFZhbHVlcyA9IF90aGlzJHByb3BzMi55R3JpZFZhbHVlcztcbiAgICB2YXIgeEF4aXMgPSBnZXRDaGlsZFdpdGhOYW1lKCdYQXhpcycsIGNoaWxkcmVuKTtcbiAgICB2YXIgeUF4aXMgPSBnZXRDaGlsZFdpdGhOYW1lKCdZQXhpcycsIGNoaWxkcmVuKTsgLy8gdXNlIG51bSB0aWNrcyBhbmQgdGlja1ZhbHVlcyBkZWZpbmVkIG9uIEF4ZXMsIGlmIHJlbGV2YW50XG5cbiAgICByZXR1cm4ge1xuICAgICAgbnVtWFRpY2tzOiBwcm9wT3JGYWxsYmFjayh4QXhpcyAmJiB4QXhpcy5wcm9wcywgJ251bVRpY2tzJywgbnVtVGlja3NGb3JXaWR0aChpbm5lcldpZHRoKSksXG4gICAgICBudW1ZVGlja3M6IHByb3BPckZhbGxiYWNrKHlBeGlzICYmIHlBeGlzLnByb3BzLCAnbnVtVGlja3MnLCBudW1UaWNrc0ZvckhlaWdodChpbm5lckhlaWdodCkpLFxuICAgICAgeEdyaWRWYWx1ZXM6IHhHcmlkVmFsdWVzIHx8ICh4QXhpcyAmJiB4QXhpcy5wcm9wcyAmJiB4QXhpcy5wcm9wcy50aWNrVmFsdWVzID8geEF4aXMucHJvcHMudGlja1ZhbHVlcyA6IG51bGwpLFxuICAgICAgeUdyaWRWYWx1ZXM6IHlHcmlkVmFsdWVzIHx8ICh5QXhpcyAmJiB5QXhpcy5wcm9wcyAmJiB5QXhpcy5wcm9wcy50aWNrVmFsdWVzID8geUF4aXMucHJvcHMudGlja1ZhbHVlcyA6IG51bGwpXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0RGF0dW1Db29yZHMgPSBmdW5jdGlvbiBnZXREYXR1bUNvb3JkcyhkYXR1bSkge1xuICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIHhTY2FsZSA9IF90aGlzJHN0YXRlLnhTY2FsZSxcbiAgICAgICAgeVNjYWxlID0gX3RoaXMkc3RhdGUueVNjYWxlLFxuICAgICAgICBtYXJnaW4gPSBfdGhpcyRzdGF0ZS5tYXJnaW47XG4gICAgdmFyIGNvb3JkcyA9IHt9OyAvLyB0b29sdGlwIG9wZXJhdGVzIGluIGZ1bGwgd2lkdGgvaGVpZ2h0IHNwYWNlIHNvIHdlIG11c3QgYWNjb3VudCBmb3IgbWFyZ2luc1xuXG4gICAgaWYgKGRhdHVtKSBjb29yZHMueCA9IHhTY2FsZShnZXRYKGRhdHVtKSkgKyBtYXJnaW4ubGVmdDtcbiAgICBpZiAoZGF0dW0pIGNvb3Jkcy55ID0geVNjYWxlKGdldFkoZGF0dW0pKSArIG1hcmdpbi50b3A7XG4gICAgcmV0dXJuIGNvb3JkcztcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlQ29udGFpbmVyRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVDb250YWluZXJFdmVudChldmVudCkge1xuICAgIHZhciBfdGhpcyRzdGF0ZTIgPSB0aGlzLnN0YXRlLFxuICAgICAgICB4U2NhbGUgPSBfdGhpcyRzdGF0ZTIueFNjYWxlLFxuICAgICAgICB5U2NhbGUgPSBfdGhpcyRzdGF0ZTIueVNjYWxlLFxuICAgICAgICBtYXJnaW4gPSBfdGhpcyRzdGF0ZTIubWFyZ2luO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICB2YXIgX2ZpbmRDbG9zZXN0RGF0dW1zID0gZmluZENsb3Nlc3REYXR1bXMoe1xuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgZ2V0WDogZ2V0WCxcbiAgICAgIGdldFk6IGdldFksXG4gICAgICB4U2NhbGU6IHhTY2FsZSxcbiAgICAgIHlTY2FsZTogeVNjYWxlLFxuICAgICAgbWFyZ2luOiBtYXJnaW5cbiAgICB9KSxcbiAgICAgICAgY2xvc2VzdERhdHVtID0gX2ZpbmRDbG9zZXN0RGF0dW1zLmNsb3Nlc3REYXR1bSxcbiAgICAgICAgc2VyaWVzID0gX2ZpbmRDbG9zZXN0RGF0dW1zLnNlcmllcztcblxuICAgIGlmIChjbG9zZXN0RGF0dW0gfHwgT2JqZWN0LmtleXMoc2VyaWVzKS5sZW5ndGggPiAwKSB7XG4gICAgICBldmVudC5wZXJzaXN0KCk7XG4gICAgICB2YXIgYXJncyA9IHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBkYXR1bTogY2xvc2VzdERhdHVtLFxuICAgICAgICBzZXJpZXM6IHNlcmllc1xuICAgICAgfTtcbiAgICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJykgdGhpcy5oYW5kbGVNb3VzZU1vdmUoYXJncyk7ZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykgdGhpcy5oYW5kbGVDbGljayhhcmdzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIGlmICh0aGlzLmZpcmVCcnVzaFN0YXJ0KSB7XG4gICAgICB0aGlzLmZpcmVCcnVzaFN0YXJ0KGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShhcmdzKSB7XG4gICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHNuYXBUb29sdGlwVG9EYXRhWCA9IF90aGlzJHByb3BzMy5zbmFwVG9vbHRpcFRvRGF0YVgsXG4gICAgICAgIHNuYXBUb29sdGlwVG9EYXRhWSA9IF90aGlzJHByb3BzMy5zbmFwVG9vbHRpcFRvRGF0YVksXG4gICAgICAgIG9uTW91c2VNb3ZlID0gX3RoaXMkcHJvcHMzLm9uTW91c2VNb3ZlO1xuICAgIHZhciBpc0ZvY3VzRXZlbnQgPSBhcmdzLmV2ZW50ICYmIGFyZ3MuZXZlbnQudHlwZSA9PT0gJ2ZvY3VzJztcblxuICAgIGlmIChvbk1vdXNlTW92ZSkge1xuICAgICAgdmFyIF90aGlzJGdldERhdHVtQ29vcmRzID0gdGhpcy5nZXREYXR1bUNvb3JkcyhhcmdzLmRhdHVtKSxcbiAgICAgICAgICB4ID0gX3RoaXMkZ2V0RGF0dW1Db29yZHMueCxcbiAgICAgICAgICB5ID0gX3RoaXMkZ2V0RGF0dW1Db29yZHMueTtcblxuICAgICAgb25Nb3VzZU1vdmUoX2V4dGVuZHMoe30sIGFyZ3MsIHtcbiAgICAgICAgY29vcmRzOiBfZXh0ZW5kcyh7fSwgKGlzRm9jdXNFdmVudCB8fCBzbmFwVG9vbHRpcFRvRGF0YVgpICYmIHtcbiAgICAgICAgICB4OiB4XG4gICAgICAgIH0sIChpc0ZvY3VzRXZlbnQgfHwgc25hcFRvb2x0aXBUb0RhdGFZKSAmJiB7XG4gICAgICAgICAgeTogeVxuICAgICAgICB9LCBhcmdzLmNvb3JkcylcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZU1vdXNlTGVhdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZUxlYXZlKGFyZ3MpIHtcbiAgICB2YXIgb25Nb3VzZUxlYXZlID0gdGhpcy5wcm9wcy5vbk1vdXNlTGVhdmU7XG4gICAgaWYgKG9uTW91c2VMZWF2ZSkgb25Nb3VzZUxlYXZlKGFyZ3MpO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGFyZ3MpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgc25hcFRvb2x0aXBUb0RhdGFYID0gX3RoaXMkcHJvcHM0LnNuYXBUb29sdGlwVG9EYXRhWCxcbiAgICAgICAgc25hcFRvb2x0aXBUb0RhdGFZID0gX3RoaXMkcHJvcHM0LnNuYXBUb29sdGlwVG9EYXRhWSxcbiAgICAgICAgb25DbGljayA9IF90aGlzJHByb3BzNC5vbkNsaWNrO1xuXG4gICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLmdldERhdHVtQ29vcmRzKGFyZ3MuZGF0dW0pO1xuICAgICAgb25DbGljayhfZXh0ZW5kcyh7fSwgYXJncywge1xuICAgICAgICBjb29yZHM6IF9leHRlbmRzKHtcbiAgICAgICAgICB4OiBzbmFwVG9vbHRpcFRvRGF0YVggPyBjb29yZHMueCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB5OiBzbmFwVG9vbHRpcFRvRGF0YVkgPyBjb29yZHMueSA6IHVuZGVmaW5lZFxuICAgICAgICB9LCBhcmdzLmNvb3JkcylcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciByZW5kZXJUb29sdGlwID0gdGhpcy5wcm9wcy5yZW5kZXJUb29sdGlwO1xuXG4gICAgaWYgKHJlbmRlclRvb2x0aXApIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFdpdGhUb29sdGlwLCB7XG4gICAgICAgIHJlbmRlclRvb2x0aXA6IHJlbmRlclRvb2x0aXBcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoWFlDaGFydCwgX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgcmVuZGVyVG9vbHRpcDogbnVsbFxuICAgICAgfSkpKTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYXJpYUxhYmVsID0gX3RoaXMkcHJvcHM1LmFyaWFMYWJlbCxcbiAgICAgICAgZXZlbnRUcmlnZ2VyID0gX3RoaXMkcHJvcHM1LmV2ZW50VHJpZ2dlcixcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczUuY2hpbGRyZW4sXG4gICAgICAgIHNob3dYR3JpZCA9IF90aGlzJHByb3BzNS5zaG93WEdyaWQsXG4gICAgICAgIHNob3dZR3JpZCA9IF90aGlzJHByb3BzNS5zaG93WUdyaWQsXG4gICAgICAgIHRoZW1lID0gX3RoaXMkcHJvcHM1LnRoZW1lLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczUuaGVpZ2h0LFxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNS53aWR0aCxcbiAgICAgICAgaW5uZXJSZWYgPSBfdGhpcyRwcm9wczUuaW5uZXJSZWYsXG4gICAgICAgIHRvb2x0aXBEYXRhID0gX3RoaXMkcHJvcHM1LnRvb2x0aXBEYXRhLFxuICAgICAgICBzaG93Vm9yb25vaSA9IF90aGlzJHByb3BzNS5zaG93Vm9yb25vaSxcbiAgICAgICAgeEdyaWRPZmZzZXQgPSBfdGhpcyRwcm9wczUueEdyaWRPZmZzZXQsXG4gICAgICAgIHlHcmlkT2Zmc2V0ID0gX3RoaXMkcHJvcHM1LnlHcmlkT2Zmc2V0O1xuICAgIHZhciBfdGhpcyRzdGF0ZTMgPSB0aGlzLnN0YXRlLFxuICAgICAgICBpbm5lcldpZHRoID0gX3RoaXMkc3RhdGUzLmlubmVyV2lkdGgsXG4gICAgICAgIGlubmVySGVpZ2h0ID0gX3RoaXMkc3RhdGUzLmlubmVySGVpZ2h0LFxuICAgICAgICBtYXJnaW4gPSBfdGhpcyRzdGF0ZTMubWFyZ2luLFxuICAgICAgICB2b3Jvbm9pRGF0YSA9IF90aGlzJHN0YXRlMy52b3Jvbm9pRGF0YSxcbiAgICAgICAgdm9yb25vaVggPSBfdGhpcyRzdGF0ZTMudm9yb25vaVgsXG4gICAgICAgIHZvcm9ub2lZID0gX3RoaXMkc3RhdGUzLnZvcm9ub2lZLFxuICAgICAgICB4U2NhbGUgPSBfdGhpcyRzdGF0ZTMueFNjYWxlLFxuICAgICAgICB5U2NhbGUgPSBfdGhpcyRzdGF0ZTMueVNjYWxlO1xuXG4gICAgdmFyIF90aGlzJGdldE51bVRpY2tzQW5kRyA9IHRoaXMuZ2V0TnVtVGlja3NBbmRHcmlkVmFsdWVzKGlubmVyV2lkdGgsIGlubmVySGVpZ2h0KSxcbiAgICAgICAgbnVtWFRpY2tzID0gX3RoaXMkZ2V0TnVtVGlja3NBbmRHLm51bVhUaWNrcyxcbiAgICAgICAgbnVtWVRpY2tzID0gX3RoaXMkZ2V0TnVtVGlja3NBbmRHLm51bVlUaWNrcyxcbiAgICAgICAgeEdyaWRWYWx1ZXMgPSBfdGhpcyRnZXROdW1UaWNrc0FuZEcueEdyaWRWYWx1ZXMsXG4gICAgICAgIHlHcmlkVmFsdWVzID0gX3RoaXMkZ2V0TnVtVGlja3NBbmRHLnlHcmlkVmFsdWVzO1xuXG4gICAgdmFyIENyb3NzSGFpcnMgPSBbXTsgLy8gZW5zdXJlIHRoZXNlIGFyZSB0aGUgdG9wLW1vc3QgbGF5ZXJcblxuICAgIHZhciBCcnVzaCA9IG51bGw7XG4gICAgdmFyIHhBeGlzT3JpZW50YXRpb247XG4gICAgdmFyIHlBeGlzT3JpZW50YXRpb247XG4gICAgcmV0dXJuIGlubmVyV2lkdGggPiAwICYmIGlubmVySGVpZ2h0ID4gMCAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICAgIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsXG4gICAgICByb2xlOiBcImltZ1wiLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICByZWY6IGlubmVyUmVmXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChHcm91cCwge1xuICAgICAgbGVmdDogbWFyZ2luLmxlZnQsXG4gICAgICB0b3A6IG1hcmdpbi50b3BcbiAgICB9LCBzaG93WEdyaWQgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChHcmlkQ29sdW1ucywge1xuICAgICAgc2NhbGU6IHhTY2FsZSxcbiAgICAgIGhlaWdodDogaW5uZXJIZWlnaHQsXG4gICAgICBudW1UaWNrczogbnVtWFRpY2tzLFxuICAgICAgc3Ryb2tlOiB0aGVtZS5ncmlkU3R5bGVzICYmIHRoZW1lLmdyaWRTdHlsZXMuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHRoZW1lLmdyaWRTdHlsZXMgJiYgdGhlbWUuZ3JpZFN0eWxlcy5zdHJva2VXaWR0aCxcbiAgICAgIHRpY2tWYWx1ZXM6IHhHcmlkVmFsdWVzLFxuICAgICAgb2Zmc2V0OiBpc0RlZmluZWQoeEdyaWRPZmZzZXQpID8geEdyaWRPZmZzZXQgOiB4U2NhbGUuYmFuZHdpZHRoICYmIHhTY2FsZS5iYW5kd2lkdGgoKSAvIDIgfHwgMFxuICAgIH0pLCBzaG93WUdyaWQgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChHcmlkUm93cywge1xuICAgICAgc2NhbGU6IHlTY2FsZSxcbiAgICAgIHdpZHRoOiBpbm5lcldpZHRoLFxuICAgICAgbnVtVGlja3M6IG51bVlUaWNrcyxcbiAgICAgIHN0cm9rZTogdGhlbWUuZ3JpZFN0eWxlcyAmJiB0aGVtZS5ncmlkU3R5bGVzLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiB0aGVtZS5ncmlkU3R5bGVzICYmIHRoZW1lLmdyaWRTdHlsZXMuc3Ryb2tlV2lkdGgsXG4gICAgICB0aWNrVmFsdWVzOiB5R3JpZFZhbHVlcyxcbiAgICAgIG9mZnNldDogaXNEZWZpbmVkKHlHcmlkT2Zmc2V0KSA/IHlHcmlkT2Zmc2V0IDogeVNjYWxlLmJhbmR3aWR0aCAmJiB5U2NhbGUuYmFuZHdpZHRoKCkgLyAyIHx8IDBcbiAgICB9KSwgUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoQ2hpbGQpIHtcbiAgICAgIHZhciBuYW1lID0gY29tcG9uZW50TmFtZShDaGlsZCk7XG5cbiAgICAgIGlmIChpc0F4aXMobmFtZSkpIHtcbiAgICAgICAgdmFyIHN0eWxlS2V5ID0gbmFtZVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgbGFiZWxPZmZzZXQgPSB0eXBlb2YgQ2hpbGQucHJvcHMubGFiZWxPZmZzZXQgPT09ICdudW1iZXInID8gQ2hpbGQucHJvcHMubGFiZWxPZmZzZXQgOiBuYW1lID09PSAnWUF4aXMnICYmIFlfTEFCRUxfT0ZGU0VUICogbWFyZ2luW0NoaWxkLnByb3BzLm9yaWVudGF0aW9uXSB8fCAwO1xuXG4gICAgICAgIGlmIChuYW1lID09PSAnWEF4aXMnKSB7XG4gICAgICAgICAgeEF4aXNPcmllbnRhdGlvbiA9IENoaWxkLnByb3BzLm9yaWVudGF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlBeGlzT3JpZW50YXRpb24gPSBDaGlsZC5wcm9wcy5vcmllbnRhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoQ2hpbGQsIHtcbiAgICAgICAgICBpbm5lckhlaWdodDogaW5uZXJIZWlnaHQsXG4gICAgICAgICAgaW5uZXJXaWR0aDogaW5uZXJXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgbGFiZWxPZmZzZXQ6IGxhYmVsT2Zmc2V0LFxuICAgICAgICAgIG51bVRpY2tzOiBuYW1lID09PSAnWEF4aXMnID8gbnVtWFRpY2tzIDogbnVtWVRpY2tzLFxuICAgICAgICAgIHNjYWxlOiBuYW1lID09PSAnWEF4aXMnID8geFNjYWxlIDogeVNjYWxlLFxuICAgICAgICAgIHJhbmdlUGFkZGluZzogQ2hpbGQucHJvcHMucmFuZ2VQYWRkaW5nIHx8IChuYW1lID09PSAnWEF4aXMnID8geFNjYWxlLm9mZnNldCA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgYXhpc1N0eWxlczogX2V4dGVuZHMoe30sIHRoZW1lW3N0eWxlS2V5ICsgXCJBeGlzU3R5bGVzXCJdLCBDaGlsZC5wcm9wcy5heGlzU3R5bGVzKSxcbiAgICAgICAgICB0aWNrU3R5bGVzOiBfZXh0ZW5kcyh7fSwgdGhlbWVbc3R5bGVLZXkgKyBcIlRpY2tTdHlsZXNcIl0sIENoaWxkLnByb3BzLnRpY2tTdHlsZXMpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc1NlcmllcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KENoaWxkLCB7XG4gICAgICAgICAgeFNjYWxlOiB4U2NhbGUsXG4gICAgICAgICAgeVNjYWxlOiB5U2NhbGUsXG4gICAgICAgICAgbWFyZ2luOiBtYXJnaW4sXG4gICAgICAgICAgb25DbGljazogQ2hpbGQucHJvcHMub25DbGljayB8fCAoQ2hpbGQucHJvcHMuZGlzYWJsZU1vdXNlRXZlbnRzID8gdW5kZWZpbmVkIDogX3RoaXMzLmhhbmRsZUNsaWNrKSxcbiAgICAgICAgICBvbk1vdXNlTGVhdmU6IENoaWxkLnByb3BzLm9uTW91c2VMZWF2ZSB8fCAoQ2hpbGQucHJvcHMuZGlzYWJsZU1vdXNlRXZlbnRzID8gdW5kZWZpbmVkIDogX3RoaXMzLmhhbmRsZU1vdXNlTGVhdmUpLFxuICAgICAgICAgIG9uTW91c2VNb3ZlOiBDaGlsZC5wcm9wcy5vbk1vdXNlTW92ZSB8fCAoQ2hpbGQucHJvcHMuZGlzYWJsZU1vdXNlRXZlbnRzID8gdW5kZWZpbmVkIDogX3RoaXMzLmhhbmRsZU1vdXNlTW92ZSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NIYWlyKG5hbWUpKSB7XG4gICAgICAgIENyb3NzSGFpcnMucHVzaChDaGlsZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChpc1JlZmVyZW5jZUxpbmUobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChDaGlsZCwge1xuICAgICAgICAgIHhTY2FsZTogeFNjYWxlLFxuICAgICAgICAgIHlTY2FsZTogeVNjYWxlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc0JydXNoKG5hbWUpKSB7XG4gICAgICAgIEJydXNoID0gQ2hpbGQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ2hpbGQ7XG4gICAgfSksIGV2ZW50VHJpZ2dlciA9PT0gVk9ST05PSV9UUklHR0VSICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVm9yb25vaSwge1xuICAgICAgZGF0YTogdm9yb25vaURhdGEsXG4gICAgICB4OiB2b3Jvbm9pWCxcbiAgICAgIHk6IHZvcm9ub2lZLFxuICAgICAgd2lkdGg6IGlubmVyV2lkdGgsXG4gICAgICBoZWlnaHQ6IGlubmVySGVpZ2h0LFxuICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDbGljayxcbiAgICAgIG9uTW91c2VEb3duOiB0aGlzLmhhbmRsZU1vdXNlRG93bixcbiAgICAgIG9uTW91c2VNb3ZlOiB0aGlzLmhhbmRsZU1vdXNlTW92ZSxcbiAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5oYW5kbGVNb3VzZUxlYXZlLFxuICAgICAgc2hvd1Zvcm9ub2k6IHNob3dWb3Jvbm9pXG4gICAgfSksIGV2ZW50VHJpZ2dlciA9PT0gQ09OVEFJTkVSX1RSSUdHRVIgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogaW5uZXJIZWlnaHQsXG4gICAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICBmaWxsT3BhY2l0eTogMCxcbiAgICAgIG9uTW91c2VEb3duOiB0aGlzLmhhbmRsZU1vdXNlRG93bixcbiAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ29udGFpbmVyRXZlbnQsXG4gICAgICBvbk1vdXNlTW92ZTogdGhpcy5oYW5kbGVDb250YWluZXJFdmVudCxcbiAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5oYW5kbGVNb3VzZUxlYXZlXG4gICAgfSksIEJydXNoICYmIFJlYWN0LmNsb25lRWxlbWVudChCcnVzaCwge1xuICAgICAgeFNjYWxlOiB4U2NhbGUsXG4gICAgICB5U2NhbGU6IHlTY2FsZSxcbiAgICAgIGlubmVySGVpZ2h0OiBpbm5lckhlaWdodCxcbiAgICAgIGlubmVyV2lkdGg6IGlubmVyV2lkdGgsXG4gICAgICBtYXJnaW46IG1hcmdpbixcbiAgICAgIG9uTW91c2VNb3ZlOiB0aGlzLmhhbmRsZUNvbnRhaW5lckV2ZW50LFxuICAgICAgb25Nb3VzZUxlYXZlOiB0aGlzLmhhbmRsZU1vdXNlTGVhdmUsXG4gICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUNvbnRhaW5lckV2ZW50LFxuICAgICAgeEF4aXNPcmllbnRhdGlvbjogeEF4aXNPcmllbnRhdGlvbixcbiAgICAgIHlBeGlzT3JpZW50YXRpb246IHlBeGlzT3JpZW50YXRpb25cbiAgICB9KSwgdG9vbHRpcERhdGEgJiYgQ3Jvc3NIYWlycy5sZW5ndGggPiAwICYmIENyb3NzSGFpcnMubWFwKGZ1bmN0aW9uIChDcm9zc0hhaXIsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoQ3Jvc3NIYWlyLCB7XG4gICAgICAgIGtleTogXCJjcm9zc2hhaXItXCIgKyBpLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICBkYXR1bTogdG9vbHRpcERhdGEuZGF0dW0sXG4gICAgICAgIHNlcmllczogdG9vbHRpcERhdGEuc2VyaWVzLFxuICAgICAgICBnZXRTY2FsZWRYOiBmdW5jdGlvbiBnZXRTY2FsZWRYKGQpIHtcbiAgICAgICAgICByZXR1cm4geFNjYWxlKGdldFgoZCkgfHwgMCkgKyAoeFNjYWxlLmJhbmR3aWR0aCA/IHhTY2FsZS5iYW5kd2lkdGgoKSAvIDIgOiAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2NhbGVkWTogZnVuY3Rpb24gZ2V0U2NhbGVkWShkKSB7XG4gICAgICAgICAgcmV0dXJuIHlTY2FsZShnZXRZKGQpIHx8IDApICsgKHlTY2FsZS5iYW5kd2lkdGggPyB5U2NhbGUuYmFuZHdpZHRoKCkgLyAyIDogMCk7XG4gICAgICAgIH0sXG4gICAgICAgIHhTY2FsZTogeFNjYWxlLFxuICAgICAgICB5U2NhbGU6IHlTY2FsZVxuICAgICAgfSk7XG4gICAgfSkpKTtcbiAgfTtcblxuICByZXR1cm4gWFlDaGFydDtcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7XG5cblhZQ2hhcnQucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuWFlDaGFydC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5YWUNoYXJ0LmRpc3BsYXlOYW1lID0gJ1hZQ2hhcnQnO1xuZXhwb3J0IGRlZmF1bHQgWFlDaGFydDsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0NBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZGQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQU9BO0FBQ0E7QUFHQTs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2481\n")}}]);