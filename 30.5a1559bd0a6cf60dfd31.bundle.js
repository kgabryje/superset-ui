(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{1856:function(module,exports,__webpack_require__){"use strict";eval("\nvar $ = __webpack_require__(26);\nvar isArray = __webpack_require__(265);\n\nvar nativeReverse = [].reverse;\nvar test = [1, 2];\n\n// `Array.prototype.reverse` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.reverse\n// fix for Safari 12.0 bug\n// https://bugs.webkit.org/show_bug.cgi?id=188794\n$({ target: 'Array', proto: true, forced: String(test) === String(test.reverse()) }, {\n  reverse: function reverse() {\n    // eslint-disable-next-line no-self-assign\n    if (isArray(this)) this.length = this.length;\n    return nativeReverse.call(this);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg1Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJldmVyc2UuanM/NTBhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG5cbnZhciBuYXRpdmVSZXZlcnNlID0gW10ucmV2ZXJzZTtcbnZhciB0ZXN0ID0gWzEsIDJdO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnJldmVyc2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJldmVyc2Vcbi8vIGZpeCBmb3IgU2FmYXJpIDEyLjAgYnVnXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg4Nzk0XG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBTdHJpbmcodGVzdCkgPT09IFN0cmluZyh0ZXN0LnJldmVyc2UoKSkgfSwge1xuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgIGlmIChpc0FycmF5KHRoaXMpKSB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHJldHVybiBuYXRpdmVSZXZlcnNlLmNhbGwodGhpcyk7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1856\n")},2317:function(module,exports,__webpack_require__){eval("var api = __webpack_require__(262);\n            var content = __webpack_require__(2318);\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\nvar exported = content.locals ? content.locals : {};\n\n\n\nmodule.exports = exported;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMxNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmNzcz9kMjRkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNi0xIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3Bvc3Rjc3MhLi9kMy5wYXJjb29yZHMuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG52YXIgZXhwb3J0ZWQgPSBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDoge307XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVkOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2317\n")},2318:function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(263);\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/* [LICENSE TBD] */\\n.parcoords svg,\\n.parcoords canvas {\\n  font-size: 12px;\\n  position: absolute;\\n}\\n.parcoords > canvas {\\n  pointer-events: none;\\n}\\n\\n.parcoords text.label {\\n  font: 100%;\\n  font-size: 12px;\\n  cursor: drag;\\n}\\n\\n.parcoords rect.background {\\n  fill: transparent;\\n}\\n.parcoords rect.background:hover {\\n  fill: rgba(120, 120, 120, 0.2);\\n}\\n.parcoords .resize rect {\\n  fill: rgba(0, 0, 0, 0.1);\\n}\\n.parcoords rect.extent {\\n  fill: rgba(255, 255, 255, 0.25);\\n  stroke: rgba(0, 0, 0, 0.6);\\n}\\n.parcoords .axis line,\\n.parcoords .axis path {\\n  fill: none;\\n  stroke: #222;\\n  shape-rendering: crispEdges;\\n}\\n.parcoords canvas {\\n  opacity: 1;\\n  -moz-transition: opacity 0.3s;\\n  -webkit-transition: opacity 0.3s;\\n  -o-transition: opacity 0.3s;\\n}\\n.parcoords canvas.faded {\\n  opacity: 0.25;\\n}\\n.parcoords {\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n  background-color: white;\\n}\\n\\n/* data table styles */\\n.parcoords .row,\\n.parcoords .header {\\n  clear: left;\\n  font-size: 12px;\\n  line-height: 18px;\\n  height: 18px;\\n  margin: 0px;\\n}\\n.parcoords .row:nth-child(odd) {\\n  background: rgba(0, 0, 0, 0.05);\\n}\\n.parcoords .header {\\n  font-weight: bold;\\n}\\n.parcoords .cell {\\n  float: left;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  width: 100px;\\n  height: 18px;\\n}\\n.parcoords .col-0 {\\n  width: 180px;\\n}\\n", ""]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMxOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmNzcz82OTU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiBbTElDRU5TRSBUQkRdICovXFxuLnBhcmNvb3JkcyBzdmcsXFxuLnBhcmNvb3JkcyBjYW52YXMge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG4ucGFyY29vcmRzID4gY2FudmFzIHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4ucGFyY29vcmRzIHRleHQubGFiZWwge1xcbiAgZm9udDogMTAwJTtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGN1cnNvcjogZHJhZztcXG59XFxuXFxuLnBhcmNvb3JkcyByZWN0LmJhY2tncm91bmQge1xcbiAgZmlsbDogdHJhbnNwYXJlbnQ7XFxufVxcbi5wYXJjb29yZHMgcmVjdC5iYWNrZ3JvdW5kOmhvdmVyIHtcXG4gIGZpbGw6IHJnYmEoMTIwLCAxMjAsIDEyMCwgMC4yKTtcXG59XFxuLnBhcmNvb3JkcyAucmVzaXplIHJlY3Qge1xcbiAgZmlsbDogcmdiYSgwLCAwLCAwLCAwLjEpO1xcbn1cXG4ucGFyY29vcmRzIHJlY3QuZXh0ZW50IHtcXG4gIGZpbGw6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yNSk7XFxuICBzdHJva2U6IHJnYmEoMCwgMCwgMCwgMC42KTtcXG59XFxuLnBhcmNvb3JkcyAuYXhpcyBsaW5lLFxcbi5wYXJjb29yZHMgLmF4aXMgcGF0aCB7XFxuICBmaWxsOiBub25lO1xcbiAgc3Ryb2tlOiAjMjIyO1xcbiAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzO1xcbn1cXG4ucGFyY29vcmRzIGNhbnZhcyB7XFxuICBvcGFjaXR5OiAxO1xcbiAgLW1vei10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcXG4gIC1vLXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcXG59XFxuLnBhcmNvb3JkcyBjYW52YXMuZmFkZWQge1xcbiAgb3BhY2l0eTogMC4yNTtcXG59XFxuLnBhcmNvb3JkcyB7XFxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuLyogZGF0YSB0YWJsZSBzdHlsZXMgKi9cXG4ucGFyY29vcmRzIC5yb3csXFxuLnBhcmNvb3JkcyAuaGVhZGVyIHtcXG4gIGNsZWFyOiBsZWZ0O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbGluZS1oZWlnaHQ6IDE4cHg7XFxuICBoZWlnaHQ6IDE4cHg7XFxuICBtYXJnaW46IDBweDtcXG59XFxuLnBhcmNvb3JkcyAucm93Om50aC1jaGlsZChvZGQpIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wNSk7XFxufVxcbi5wYXJjb29yZHMgLmhlYWRlciB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuLnBhcmNvb3JkcyAuY2VsbCB7XFxuICBmbG9hdDogbGVmdDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgd2lkdGg6IDEwMHB4O1xcbiAgaGVpZ2h0OiAxOHB4O1xcbn1cXG4ucGFyY29vcmRzIC5jb2wtMCB7XFxuICB3aWR0aDogMTgwcHg7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2318\n')},2319:function(module,exports,__webpack_require__){eval("var DESCRIPTORS = __webpack_require__(67);\nvar objectDefinePropertyModule = __webpack_require__(82);\nvar regExpFlags = __webpack_require__(808);\nvar UNSUPPORTED_Y = __webpack_require__(1124).UNSUPPORTED_Y;\n\n// `RegExp.prototype.flags` getter\n// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags\nif (DESCRIPTORS && (/./g.flags != 'g' || UNSUPPORTED_Y)) {\n  objectDefinePropertyModule.f(RegExp.prototype, 'flags', {\n    configurable: true,\n    get: regExpFlags\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMxOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5mbGFncy5qcz8xYThhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIG9iamVjdERlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciByZWdFeHBGbGFncyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZmxhZ3MnKTtcbnZhciBVTlNVUFBPUlRFRF9ZID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1zdGlja3ktaGVscGVycycpLlVOU1VQUE9SVEVEX1k7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBnZXR0ZXJcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG5pZiAoREVTQ1JJUFRPUlMgJiYgKC8uL2cuZmxhZ3MgIT0gJ2cnIHx8IFVOU1VQUE9SVEVEX1kpKSB7XG4gIG9iamVjdERlZmluZVByb3BlcnR5TW9kdWxlLmYoUmVnRXhwLnByb3RvdHlwZSwgJ2ZsYWdzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IHJlZ0V4cEZsYWdzXG4gIH0pO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2319\n")},2497:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(2);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/index.ts\nvar src = __webpack_require__(3);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/style/index.ts\nvar style = __webpack_require__(536);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(17);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/d3/d3.js\nvar d3_d3 = __webpack_require__(137);\nvar d3_default = /*#__PURE__*/__webpack_require__.n(d3_d3);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/color/SequentialSchemeRegistrySingleton.ts\nvar SequentialSchemeRegistrySingleton = __webpack_require__(537);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/core-js/modules/es.array.reverse.js\nvar es_array_reverse = __webpack_require__(1856);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/core-js/modules/es.regexp.flags.js\nvar es_regexp_flags = __webpack_require__(2319);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/core-js/modules/es.regexp.to-string.js\nvar es_regexp_to_string = __webpack_require__(99);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/core-js/modules/es.string.match.js\nvar es_string_match = __webpack_require__(213);\n\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/node_modules/core-js/modules/web.dom-collections.iterator.js\nvar web_dom_collections_iterator = __webpack_require__(47);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\n/* [LICENSE TBD] */ /* eslint-disable *//* harmony default export */ var d3_parcoords = (function(config){var __={data:[],highlighted:[],dimensions:[],dimensionTitles:{},dimensionTitleRotation:0,types:{},brushed:!1,brushedColor:null,alphaOnBrushed:0,mode:"default",rate:20,width:600,height:300,margin:{top:24,right:0,bottom:12,left:0},nullValueSeparator:"undefined",// set to "top" or "bottom"\nnullValueSeparatorPadding:{top:8,right:0,bottom:8,left:0},color:"#069",composite:"source-over",alpha:.7,bundlingStrength:.5,bundleDimension:null,smoothness:0,showControlPoints:!1,hideAxis:[]};(function(target,source){for(var key in source){target[key]=source[key]}return target})(__,config);var pc=function(selection){selection=pc.selection=d3.select(selection);__.width=selection[0][0].clientWidth;__.height=selection[0][0].clientHeight;// canvas data layers\n["marks","foreground","brushed","highlight"].forEach(function(layer){canvas[layer]=selection.append("canvas").attr("class",layer)[0][0];ctx[layer]=canvas[layer].getContext("2d")});// svg tick and brush layers\npc.svg=selection.append("svg").attr("width",__.width).attr("height",__.height).append("svg:g").attr("transform","translate("+__.margin.left+","+__.margin.top+")");return pc},events=d3.dispatch.apply(this,["render","resize","highlight","brush","brushend","axesreorder"].concat(d3.keys(__))),w=function(){return __.width-__.margin.right-__.margin.left},h=function(){return __.height-__.margin.top-__.margin.bottom},flags={brushable:!1,reorderable:!1,axes:!1,interactive:!1,debug:!1},xscale=d3.scale.ordinal(),yscale={},dragging={},line=d3.svg.line(),axis=d3.svg.axis().orient("left").ticks(5),g,// groups for axes, brushes\nctx={},canvas={},side_effects=d3.dispatch.apply(this,d3.keys(__)).on("composite",function(d){ctx.foreground.globalCompositeOperation=d.value;ctx.brushed.globalCompositeOperation=d.value}).on("alpha",function(d){ctx.foreground.globalAlpha=d.value;ctx.brushed.globalAlpha=d.value}).on("brushedColor",function(d){ctx.brushed.strokeStyle=d.value}).on("width",function(){pc.resize()}).on("height",function(){pc.resize()}).on("margin",function(){pc.resize()}).on("rate",function(d){brushedQueue.rate(d.value);foregroundQueue.rate(d.value)}).on("dimensions",function(){xscale.domain(__.dimensions);if(flags.interactive){pc.render().updateAxes()}}).on("bundleDimension",function(d){if(!__.dimensions.length)pc.detectDimensions();if(!(__.dimensions[0]in yscale))pc.autoscale();if("number"==typeof d.value){if(d.value<__.dimensions.length){__.bundleDimension=__.dimensions[d.value]}else if(d.value<__.hideAxis.length){__.bundleDimension=__.hideAxis[d.value]}}else{__.bundleDimension=d.value}__.clusterCentroids=compute_cluster_centroids(__.bundleDimension)}).on("hideAxis",function(d){if(!__.dimensions.length)pc.detectDimensions();pc.dimensions(without(__.dimensions,d.value))});// expose the state of the chart\npc.state=__;pc.flags=flags;// create getter/setters\n(// getter/setter with event firing\nfunction(obj,state,events){d3.keys(state).forEach(function(key){obj[key]=function(x){if(!arguments.length){return state[key]}var old=state[key];state[key]=x;side_effects[key].call(pc,{value:x,previous:old});events[key].call(pc,{value:x,previous:old});return obj}})})(pc,__,events);// expose events\nd3.rebind(pc,events,"on");function without(arr,item){return arr.filter(function(elem){return-1===item.indexOf(elem)})}/** adjusts an axis\' default range [h()+1, 1] if a NullValueSeparator is set */function getRange(){if("bottom"==__.nullValueSeparator){return[h()+1-__.nullValueSeparatorPadding.bottom-__.nullValueSeparatorPadding.top,1]}else if("top"==__.nullValueSeparator){return[h()+1,1+__.nullValueSeparatorPadding.bottom+__.nullValueSeparatorPadding.top]}return[h()+1,1]}pc.autoscale=function(){// yscale\nvar defaultScales={date:function date(k){var extent=d3.extent(__.data,function(d){return d[k]?d[k].getTime():null});// special case if single value\nif(extent[0]===extent[1]){return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange())}return d3.time.scale().domain(extent).range(getRange())},number:function number(k){var extent=d3.extent(__.data,function(d){return+d[k]});// special case if single value\nif(extent[0]===extent[1]){return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange())}return d3.scale.linear().domain(extent).range(getRange())},string:function string(k){var counts={},domain=[];// Let\'s get the count for each value so that we can sort the domain based\n// on the number of items for each value.\n__.data.map(function(p){if(p[k]===void 0&&"undefined"!==__.nullValueSeparator){return;// null values will be drawn beyond the horizontal null value separator!\n}if(counts[p[k]]===void 0){counts[p[k]]=1}else{counts[p[k]]=counts[p[k]]+1}});domain=Object.getOwnPropertyNames(counts).sort(function(a,b){return counts[a]-counts[b]});return d3.scale.ordinal().domain(domain).rangePoints(getRange())}};__.dimensions.forEach(function(k){yscale[k]=defaultScales[__.types[k]](k)});__.hideAxis.forEach(function(k){yscale[k]=defaultScales[__.types[k]](k)});// xscale\nxscale.rangePoints([0,w()],1);// canvas sizes\npc.selection.selectAll("canvas").style("margin-top",__.margin.top+"px").style("margin-left",__.margin.left+"px").attr("width",w()+2).attr("height",h()+2);// default styles, needs to be set when canvas width changes\nctx.foreground.strokeStyle=__.color;ctx.foreground.lineWidth=1.4;ctx.foreground.globalCompositeOperation=__.composite;ctx.foreground.globalAlpha=__.alpha;ctx.brushed.strokeStyle=__.brushedColor;ctx.brushed.lineWidth=1.4;ctx.brushed.globalCompositeOperation=__.composite;ctx.brushed.globalAlpha=__.alpha;ctx.highlight.lineWidth=3;return this};pc.scale=function(d,domain){yscale[d].domain(domain);return this};pc.flip=function(d){//yscale[d].domain().reverse();         // does not work\nyscale[d].domain(yscale[d].domain().reverse());// works\nreturn this};pc.commonScale=function(global,type){if("undefined"==typeof global){global=!0}// scales of the same type\nvar scales=__.dimensions.concat(__.hideAxis).filter(function(p){return __.types[p]==(type||"number")});if(global){var extent=d3.extent(scales.map(function(p){return yscale[p].domain()}).reduce(function(a,b){return a.concat(b)}));scales.forEach(function(d){yscale[d].domain(extent)})}else{scales.forEach(function(k){yscale[k].domain(d3.extent(__.data,function(d){return+d[k]}))})}// update centroids\nif(null!==__.bundleDimension){pc.bundleDimension(__.bundleDimension)}return this};pc.detectDimensions=function(){pc.types(pc.detectDimensionTypes(__.data));pc.dimensions(d3.keys(pc.types()));return this};// a better "typeof" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\npc.toType=function(v){return{}.toString.call(v).match(/\\s([a-zA-Z]+)/)[1].toLowerCase()};// try to coerce to number before returning type\npc.toTypeCoerceNumbers=function(v){if(parseFloat(v)==v&&null!=v){return"number"}return pc.toType(v)};// attempt to determine types of each dimension based on first row of data\npc.detectDimensionTypes=function(data){var types={};d3.keys(data[0]).forEach(function(col){types[col]=pc.toTypeCoerceNumbers(data[0][col])});return types};pc.render=function(){// try to autodetect dimensions and create scales\nif(!__.dimensions.length)pc.detectDimensions();if(!(__.dimensions[0]in yscale))pc.autoscale();pc.render[__.mode]();events.render.call(this);return this};pc.renderBrushed=function(){if(!__.dimensions.length)pc.detectDimensions();if(!(__.dimensions[0]in yscale))pc.autoscale();pc.renderBrushed[__.mode]();events.render.call(this);return this};function isBrushed(){if(__.brushed&&__.brushed.length!==__.data.length)return!0;var object=brush.currentMode().brushState();for(var key in object){if(object.hasOwnProperty(key)){return!0}}return!1}pc.render.default=function(){pc.clear("foreground");pc.clear("highlight");pc.renderBrushed.default();__.data.forEach(path_foreground)};var foregroundQueue=d3.renderQueue(path_foreground).rate(50).clear(function(){pc.clear("foreground");pc.clear("highlight")});pc.render.queue=function(){pc.renderBrushed.queue();foregroundQueue(__.data)};pc.renderBrushed.default=function(){pc.clear("brushed");if(isBrushed()){__.brushed.forEach(path_brushed)}};var brushedQueue=d3.renderQueue(path_brushed).rate(50).clear(function(){pc.clear("brushed")});pc.renderBrushed.queue=function(){if(isBrushed()){brushedQueue(__.brushed)}else{brushedQueue([]);// This is needed to clear the currently brushed items\n}};function compute_cluster_centroids(d){var clusterCentroids=d3.map(),clusterCounts=d3.map();// determine clusterCounts\n__.data.forEach(function(row){var scaled=yscale[d](row[d]);if(!clusterCounts.has(scaled)){clusterCounts.set(scaled,0)}var count=clusterCounts.get(scaled);clusterCounts.set(scaled,count+1)});__.data.forEach(function(row){__.dimensions.map(function(p){var scaled=yscale[d](row[d]);if(!clusterCentroids.has(scaled)){var map=d3.map();clusterCentroids.set(scaled,map)}if(!clusterCentroids.get(scaled).has(p)){clusterCentroids.get(scaled).set(p,0)}var value=clusterCentroids.get(scaled).get(p);value+=yscale[p](row[p])/clusterCounts.get(scaled);clusterCentroids.get(scaled).set(p,value)})});return clusterCentroids}function compute_centroids(row){// center between axes\nfor(var centroids=[],p=__.dimensions,cols=p.length,a=.5,i=0;i<cols;++i){// centroids on \'real\' axes\nvar x=position(p[i]),y=yscale[p[i]](row[p[i]]);centroids.push($V([x,y]));// centroids on \'virtual\' axes\nif(i<cols-1){var cx=x+a*(position(p[i+1])-x),cy=y+a*(yscale[p[i+1]](row[p[i+1]])-y);if(null!==__.bundleDimension){var leftCentroid=__.clusterCentroids.get(yscale[__.bundleDimension](row[__.bundleDimension])).get(p[i]),rightCentroid=__.clusterCentroids.get(yscale[__.bundleDimension](row[__.bundleDimension])).get(p[i+1]),centroid=.5*(leftCentroid+rightCentroid);cy=centroid+(1-__.bundlingStrength)*(cy-centroid)}centroids.push($V([cx,cy]))}}return centroids}function compute_control_points(centroids){var cols=centroids.length,a=__.smoothness,cps=[];cps.push(centroids[0]);cps.push($V([centroids[0].e(1)+2*a*(centroids[1].e(1)-centroids[0].e(1)),centroids[0].e(2)]));for(var col=1;col<cols-1;++col){var mid=centroids[col],left=centroids[col-1],right=centroids[col+1],diff=left.subtract(right);cps.push(mid.add(diff.x(a)));cps.push(mid);cps.push(mid.subtract(diff.x(a)))}cps.push($V([centroids[cols-1].e(1)+2*a*(centroids[cols-2].e(1)-centroids[cols-1].e(1)),centroids[cols-1].e(2)]));cps.push(centroids[cols-1]);return cps}pc.shadows=function(){flags.shadows=!0;pc.alphaOnBrushed(.1);pc.render();return this};// draw dots with radius r on the axis line where data intersects\npc.axisDots=function(r){var r=r||.1,ctx=pc.ctx.marks,endAngle=2*Math.PI;ctx.globalAlpha=d3.min([1/Math.pow(__.data.length,1/2),1]);__.data.forEach(function(d){__.dimensions.map(function(p){ctx.beginPath();ctx.arc(position(p),yscale[p](d[p]),r,0,endAngle);ctx.stroke();ctx.fill()})});return this};// draw single cubic bezier curve\nfunction single_curve(d,ctx){var centroids=compute_centroids(d),cps=compute_control_points(centroids);ctx.moveTo(cps[0].e(1),cps[0].e(2));for(var i=1;i<cps.length;i+=3){if(__.showControlPoints){for(var j=0;3>j;j++){ctx.fillRect(cps[i+j].e(1),cps[i+j].e(2),2,2)}}ctx.bezierCurveTo(cps[i].e(1),cps[i].e(2),cps[i+1].e(1),cps[i+1].e(2),cps[i+2].e(1),cps[i+2].e(2))}}// draw single polyline\nfunction color_path(d,ctx){ctx.beginPath();if(null!==__.bundleDimension&&0<__.bundlingStrength||0<__.smoothness){single_curve(d,ctx)}else{single_path(d,ctx)}ctx.stroke()}// draw many polylines of the same color\n// returns the y-position just beyond the separating null value line\nfunction getNullPosition(){if("bottom"==__.nullValueSeparator){return h()+1}else if("top"==__.nullValueSeparator){return 1}else{console.log("A value is NULL, but nullValueSeparator is not set; set it to \'bottom\' or \'top\'.")}return h()+1}function single_path(d,ctx){__.dimensions.map(function(p,i){if(0==i){ctx.moveTo(position(p),"undefined"==typeof d[p]?getNullPosition():yscale[p](d[p]))}else{ctx.lineTo(position(p),"undefined"==typeof d[p]?getNullPosition():yscale[p](d[p]))}})}function path_brushed(d,i){if(null!==__.brushedColor){ctx.brushed.strokeStyle=d3.functor(__.brushedColor)(d,i)}else{ctx.brushed.strokeStyle=d3.functor(__.color)(d,i)}return color_path(d,ctx.brushed)}function path_foreground(d,i){ctx.foreground.strokeStyle=d3.functor(__.color)(d,i);return color_path(d,ctx.foreground)}function path_highlight(d,i){ctx.highlight.strokeStyle=d3.functor(__.color)(d,i);return color_path(d,ctx.highlight)}pc.clear=function(layer){ctx[layer].clearRect(0,0,w()+2,h()+2);// This will make sure that the foreground items are transparent\n// without the need for changing the opacity style of the foreground canvas\n// as this would stop the css styling from working\nif("brushed"===layer&&isBrushed()){ctx.brushed.fillStyle=pc.selection.style("background-color");ctx.brushed.globalAlpha=1-__.alphaOnBrushed;ctx.brushed.fillRect(0,0,w()+2,h()+2);ctx.brushed.globalAlpha=__.alpha}return this};d3.rebind(pc,axis,"ticks","orient","tickValues","tickSubdivide","tickSize","tickPadding","tickFormat");function flipAxisAndUpdatePCP(dimension){pc.svg.selectAll(".dimension");pc.flip(dimension);d3.select(this.parentElement).transition().duration(1100).call(axis.scale(yscale[dimension]));pc.render()}function rotateLabels(){var delta=d3.event.deltaY;delta=0>delta?-5:delta;delta=0<delta?5:delta;__.dimensionTitleRotation+=delta;pc.svg.selectAll("text.label").attr("transform","translate(0,-5) rotate("+__.dimensionTitleRotation+")");d3.event.preventDefault()}function dimensionLabels(d){return d in __.dimensionTitles?__.dimensionTitles[d]:d;// dimension display names\n}pc.createAxes=function(){if(g)pc.removeAxes();// Add a group element for each dimension.\ng=pc.svg.selectAll(".dimension").data(__.dimensions,function(d){return d}).enter().append("svg:g").attr("class","dimension").attr("transform",function(d){return"translate("+xscale(d)+")"});// Add an axis and title.\ng.append("svg:g").attr("class","axis").attr("transform","translate(0,0)").each(function(d){d3.select(this).call(axis.scale(yscale[d]))}).append("svg:text").attr({"text-anchor":"middle",y:0,transform:"translate(0,-5) rotate("+__.dimensionTitleRotation+")",x:0,class:"label"}).text(dimensionLabels).on("dblclick",flipAxisAndUpdatePCP).on("wheel",rotateLabels);if("top"==__.nullValueSeparator){pc.svg.append("line").attr("x1",0).attr("y1",1+__.nullValueSeparatorPadding.top).attr("x2",w()).attr("y2",1+__.nullValueSeparatorPadding.top).attr("stroke-width",1).attr("stroke","#777").attr("fill","none").attr("shape-rendering","crispEdges")}else if("bottom"==__.nullValueSeparator){pc.svg.append("line").attr("x1",0).attr("y1",h()+1-__.nullValueSeparatorPadding.bottom).attr("x2",w()).attr("y2",h()+1-__.nullValueSeparatorPadding.bottom).attr("stroke-width",1).attr("stroke","#777").attr("fill","none").attr("shape-rendering","crispEdges")}flags.axes=!0;return this};pc.removeAxes=function(){g.remove();return this};pc.updateAxes=function(){var g_data=pc.svg.selectAll(".dimension").data(__.dimensions);// Enter\ng_data.enter().append("svg:g").attr("class","dimension").attr("transform",function(p){return"translate("+position(p)+")"}).style("opacity",0).append("svg:g").attr("class","axis").attr("transform","translate(0,0)").each(function(d){d3.select(this).call(axis.scale(yscale[d]))}).append("svg:text").attr({"text-anchor":"middle",y:0,transform:"translate(0,-5) rotate("+__.dimensionTitleRotation+")",x:0,class:"label"}).text(dimensionLabels).on("dblclick",flipAxisAndUpdatePCP).on("wheel",rotateLabels);// Update\ng_data.attr("opacity",0);g_data.select(".axis").transition().duration(1100).each(function(d){d3.select(this).call(axis.scale(yscale[d]))});g_data.select(".label").transition().duration(1100).text(dimensionLabels).attr("transform","translate(0,-5) rotate("+__.dimensionTitleRotation+")");// Exit\ng_data.exit().remove();g=pc.svg.selectAll(".dimension");g.transition().duration(1100).attr("transform",function(p){return"translate("+position(p)+")"}).style("opacity",1);pc.svg.selectAll(".axis").transition().duration(1100).each(function(d){d3.select(this).call(axis.scale(yscale[d]))});if(flags.brushable)pc.brushable();if(flags.reorderable)pc.reorderable();if("None"!==pc.brushMode()){var mode=pc.brushMode();pc.brushMode("None");pc.brushMode(mode)}return this};// Jason Davies, http://bl.ocks.org/1341281\npc.reorderable=function(){if(!g)pc.createAxes();g.style("cursor","move").call(d3.behavior.drag().on("dragstart",function(d){dragging[d]=this.__origin__=xscale(d)}).on("drag",function(d){dragging[d]=Math.min(w(),Math.max(0,this.__origin__+=d3.event.dx));__.dimensions.sort(function(a,b){return position(a)-position(b)});xscale.domain(__.dimensions);pc.render();g.attr("transform",function(d){return"translate("+position(d)+")"})}).on("dragend",function(d){// Let\'s see if the order has changed and send out an event if so.\nvar i=0,j=__.dimensions.indexOf(d),elem=this,parent=this.parentElement;while(null!=(elem=elem.previousElementSibling))++i;if(i!==j){events.axesreorder.call(pc,__.dimensions);// We now also want to reorder the actual dom elements that represent\n// the axes. That is, the g.dimension elements. If we don\'t do this,\n// we get a weird and confusing transition when updateAxes is called.\n// This is due to the fact that, initially the nth g.dimension element\n// represents the nth axis. However, after a manual reordering,\n// without reordering the dom elements, the nth dom elements no longer\n// necessarily represents the nth axis.\n//\n// i is the original index of the dom element\n// j is the new index of the dom element\nif(i>j){// Element moved left\nparent.insertBefore(this,parent.children[j-1])}else{// Element moved right\nif(j+1<parent.children.length){parent.insertBefore(this,parent.children[j+1])}else{parent.appendChild(this)}}}delete this.__origin__;delete dragging[d];d3.select(this).transition().attr("transform","translate("+xscale(d)+")");pc.render()}));flags.reorderable=!0;return this};// Reorder dimensions, such that the highest value (visually) is on the left and\n// the lowest on the right. Visual values are determined by the data values in\n// the given row.\npc.reorder=function(rowdata){var dims=__.dimensions.slice(0);__.dimensions.sort(function(a,b){var pixelDifference=yscale[a](rowdata[a])-yscale[b](rowdata[b]);// Array.sort is not necessarily stable, this means that if pixelDifference is zero\n// the ordering of dimensions might change unexpectedly. This is solved by sorting on\n// variable name in that case.\nif(0==pixelDifference){return a.localeCompare(b)}// else\nreturn pixelDifference});// NOTE: this is relatively cheap given that:\n// number of dimensions < number of data items\n// Thus we check equality of order to prevent rerendering when this is the case.\nvar reordered=!1;dims.some(function(val,index){reordered=val!==__.dimensions[index];return reordered});if(reordered){xscale.domain(__.dimensions);var highlighted=__.highlighted.slice(0);pc.unhighlight();g.transition().duration(1500).attr("transform",function(d){return"translate("+xscale(d)+")"});pc.render();// pc.highlight() does not check whether highlighted is length zero, so we do that here.\nif(0!==highlighted.length){pc.highlight(highlighted)}}};// pairs of adjacent dimensions\npc.adjacent_pairs=function(arr){for(var ret=[],i=0;i<arr.length-1;i++){ret.push([arr[i],arr[i+1]])}return ret};var brush={modes:{None:{install:function install(){},// Nothing to be done.\nuninstall:function uninstall(){},// Nothing to be done.\nselected:function selected(){return[]},// Nothing to return\nbrushState:function brushState(){return{}}}},mode:"None",predicate:"AND",currentMode:function currentMode(){return this.modes[this.mode]}};// This function can be used for \'live\' updates of brushes. That is, during the\n// specification of a brush, this method can be called to update the view.\n//\n// @param newSelection - The new set of data items that is currently contained\n//                       by the brushes\nfunction brushUpdated(newSelection){__.brushed=newSelection;events.brush.call(pc,__.brushed);pc.renderBrushed()}function brushPredicate(predicate){if(!arguments.length){return brush.predicate}predicate=(predicate+"").toUpperCase();if("AND"!==predicate&&"OR"!==predicate){throw"Invalid predicate "+predicate}brush.predicate=predicate;__.brushed=brush.currentMode().selected();pc.renderBrushed();return pc}pc.brushModes=function(){return Object.getOwnPropertyNames(brush.modes)};pc.brushMode=function(mode){if(0===arguments.length){return brush.mode}if(-1===pc.brushModes().indexOf(mode)){throw"pc.brushmode: Unsupported brush mode: "+mode}// Make sure that we don\'t trigger unnecessary events by checking if the mode\n// actually changes.\nif(mode!==brush.mode){// When changing brush modes, the first thing we need to do is clearing any\n// brushes from the current mode, if any.\nif("None"!==brush.mode){pc.brushReset()}// Next, we need to \'uninstall\' the current brushMode.\nbrush.modes[brush.mode].uninstall(pc);// Finally, we can install the requested one.\nbrush.mode=mode;brush.modes[brush.mode].install();if("None"===mode){delete pc.brushPredicate}else{pc.brushPredicate=brushPredicate}}return pc};// brush mode: 1D-Axes\n(function(){var brushes={};function is_brushed(p){return!brushes[p].empty()}// data within extents\nfunction selected(){var actives=__.dimensions.filter(is_brushed),extents=actives.map(function(p){return brushes[p].extent()});// We don\'t want to return the full data set when there are no axes brushed.\n// Actually, when there are no axes brushed, by definition, no items are\n// selected. So, let\'s avoid the filtering and just return false.\n//if (actives.length === 0) return false;\n// Resolves broken examples for now. They expect to get the full dataset back from empty brushes\nif(0===actives.length)return __.data;// test if within range\nvar within={date:function date(d,p,dimension){if("function"==typeof yscale[p].rangePoints){// if it is ordinal\nreturn extents[dimension][0]<=yscale[p](d[p])&&yscale[p](d[p])<=extents[dimension][1]}else{return extents[dimension][0]<=d[p]&&d[p]<=extents[dimension][1]}},number:function number(d,p,dimension){if("function"==typeof yscale[p].rangePoints){// if it is ordinal\nreturn extents[dimension][0]<=yscale[p](d[p])&&yscale[p](d[p])<=extents[dimension][1]}else{return extents[dimension][0]<=d[p]&&d[p]<=extents[dimension][1]}},string:function string(d,p,dimension){return extents[dimension][0]<=yscale[p](d[p])&&yscale[p](d[p])<=extents[dimension][1]}};return __.data.filter(function(d){switch(brush.predicate){case"AND":return actives.every(function(p,dimension){return within[__.types[p]](d,p,dimension)});case"OR":return actives.some(function(p,dimension){return within[__.types[p]](d,p,dimension)});default:throw"Unknown brush predicate "+__.brushPredicate;}})}function brushExtents(extents){if("undefined"==typeof extents){var extents={};__.dimensions.forEach(function(d){var brush=brushes[d];if(brush!==void 0&&!brush.empty()){var extent=brush.extent();extent.sort(d3.ascending);extents[d]=extent}});return extents}else{//first get all the brush selections\nvar brushSelections={};g.selectAll(".brush").each(function(d){brushSelections[d]=d3.select(this)});// loop over each dimension and update appropriately (if it was passed in through extents)\n__.dimensions.forEach(function(d){if(extents[d]===void 0){return}var brush=brushes[d];if(brush!==void 0){//update the extent\nbrush.extent(extents[d]);//redraw the brush\nbrush(brushSelections[d]);//fire some events\nbrush.event(brushSelections[d])}});//redraw the chart\npc.renderBrushed()}}function brushFor(axis){var brush=d3.svg.brush();brush.y(yscale[axis]).on("brushstart",function(){if(null!==d3.event.sourceEvent){d3.event.sourceEvent.stopPropagation()}}).on("brush",function(){brushUpdated(selected())}).on("brushend",function(){events.brushend.call(pc,__.brushed)});brushes[axis]=brush;return brush}function brushReset(){__.brushed=!1;if(g){g.selectAll(".brush").each(function(d){d3.select(this).call(brushes[d].clear())});pc.renderBrushed()}return this}function install(){if(!g)pc.createAxes();// Add and store a brush for each axis.\ng.append("svg:g").attr("class","brush").each(function(d){d3.select(this).call(brushFor(d))}).selectAll("rect").style("visibility",null).attr("x",-15).attr("width",30);pc.brushExtents=brushExtents;pc.brushReset=brushReset;return pc}brush.modes["1D-axes"]={install:install,uninstall:function uninstall(){g.selectAll(".brush").remove();brushes={};delete pc.brushExtents;delete pc.brushReset},selected:selected,brushState:brushExtents}})();// brush mode: 2D-strums\n// bl.ocks.org/syntagmatic/5441022\n(function(){var strums={},strumRect;function drawStrum(strum,activePoint){var svg=pc.selection.select("svg").select("g#strums"),id=strum.dims.i,points=[strum.p1,strum.p2],line=svg.selectAll("line#strum-"+id).data([strum]),circles=svg.selectAll("circle#strum-"+id).data(points),drag=d3.behavior.drag();line.enter().append("line").attr("id","strum-"+id).attr("class","strum");line.attr("x1",function(d){return d.p1[0]}).attr("y1",function(d){return d.p1[1]}).attr("x2",function(d){return d.p2[0]}).attr("y2",function(d){return d.p2[1]}).attr("stroke","black").attr("stroke-width",2);drag.on("drag",function(d,i){var ev=d3.event;i=i+1;strum["p"+i][0]=Math.min(Math.max(strum.minX+1,ev.x),strum.maxX);strum["p"+i][1]=Math.min(Math.max(strum.minY,ev.y),strum.maxY);drawStrum(strum,i-1)}).on("dragend",onDragEnd());circles.enter().append("circle").attr("id","strum-"+id).attr("class","strum");circles.attr("cx",function(d){return d[0]}).attr("cy",function(d){return d[1]}).attr("r",5).style("opacity",function(d,i){return activePoint!==void 0&&i===activePoint?.8:0}).on("mouseover",function(){d3.select(this).style("opacity",.8)}).on("mouseout",function(){d3.select(this).style("opacity",0)}).call(drag)}function dimensionsForPoint(p){var dims={i:-1,left:void 0,right:void 0};__.dimensions.some(function(dim,i){if(xscale(dim)<p[0]){var next=__.dimensions[i+1];dims.i=i;dims.left=dim;dims.right=next;return!1}return!0});if(dims.left===void 0){// Event on the left side of the first axis.\ndims.i=0;dims.left=__.dimensions[0];dims.right=__.dimensions[1]}else if(dims.right===void 0){// Event on the right side of the last axis\ndims.i=__.dimensions.length-1;dims.right=dims.left;dims.left=__.dimensions[__.dimensions.length-2]}return dims}function onDragStart(){// First we need to determine between which two axes the sturm was started.\n// This will determine the freedom of movement, because a strum can\n// logically only happen between two axes, so no movement outside these axes\n// should be allowed.\nreturn function(){var p=d3.mouse(strumRect[0][0]),dims,strum;p[0]=p[0]-__.margin.left;p[1]=p[1]-__.margin.top;dims=dimensionsForPoint(p),strum={p1:p,dims:dims,minX:xscale(dims.left),maxX:xscale(dims.right),minY:0,maxY:h()};strums[dims.i]=strum;strums.active=dims.i;// Make sure that the point is within the bounds\nstrum.p1[0]=Math.min(Math.max(strum.minX,p[0]),strum.maxX);strum.p2=strum.p1.slice()}}function onDrag(){return function(){var ev=d3.event,strum=strums[strums.active];// Make sure that the point is within the bounds\nstrum.p2[0]=Math.min(Math.max(strum.minX+1,ev.x-__.margin.left),strum.maxX);strum.p2[1]=Math.min(Math.max(strum.minY,ev.y-__.margin.top),strum.maxY);drawStrum(strum,1)}}function containmentTest(strum,width){var p1=[strum.p1[0]-strum.minX,strum.p1[1]-strum.minX],p2=[strum.p2[0]-strum.minX,strum.p2[1]-strum.minX],m1=1-width/p1[0],b1=p1[1]*(1-m1),m2=1-width/p2[0],b2=p2[1]*(1-m2);// test if point falls between lines\nreturn function(p){var x=p[0],y=p[1],y1=m1*x+b1,y2=m2*x+b2;if(y>Math.min(y1,y2)&&y<Math.max(y1,y2)){return!0}return!1}}function selected(){var ids=Object.getOwnPropertyNames(strums),brushed=__.data;// Get the ids of the currently active strums.\nids=ids.filter(function(d){return!isNaN(d)});function crossesStrum(d,id){var strum=strums[id],test=containmentTest(strum,strums.width(id)),d1=strum.dims.left,d2=strum.dims.right,y1=yscale[d1],y2=yscale[d2],point=[y1(d[d1])-strum.minX,y2(d[d2])-strum.minX];return test(point)}if(0===ids.length){return brushed}return brushed.filter(function(d){switch(brush.predicate){case"AND":return ids.every(function(id){return crossesStrum(d,id)});case"OR":return ids.some(function(id){return crossesStrum(d,id)});default:throw"Unknown brush predicate "+__.brushPredicate;}})}function removeStrum(){var strum=strums[strums.active],svg=pc.selection.select("svg").select("g#strums");delete strums[strums.active];strums.active=void 0;svg.selectAll("line#strum-"+strum.dims.i).remove();svg.selectAll("circle#strum-"+strum.dims.i).remove()}function onDragEnd(){return function(){var brushed=__.data,strum=strums[strums.active];// Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n// considered a drag without move. So we have to deal with that case\nif(strum&&strum.p1[0]===strum.p2[0]&&strum.p1[1]===strum.p2[1]){removeStrum(strums)}brushed=selected(strums);strums.active=void 0;__.brushed=brushed;pc.renderBrushed();events.brushend.call(pc,__.brushed)}}function brushReset(strums){return function(){var ids=Object.getOwnPropertyNames(strums).filter(function(d){return!isNaN(d)});ids.forEach(function(d){strums.active=d;removeStrum(strums)});onDragEnd(strums)()}}brush.modes["2D-strums"]={install:function(){var drag=d3.behavior.drag();// Map of current strums. Strums are stored per segment of the PC. A segment,\n// being the area between two axes. The left most area is indexed at 0.\nstrums.active=void 0;// Returns the width of the PC segment where currently a strum is being\n// placed. NOTE: even though they are evenly spaced in our current\n// implementation, we keep for when non-even spaced segments are supported as\n// well.\nstrums.width=function(id){var strum=strums[id];if(strum===void 0){return}return strum.maxX-strum.minX};pc.on("axesreorder.strums",function(){var ids=Object.getOwnPropertyNames(strums).filter(function(d){return!isNaN(d)});// Checks if the first dimension is directly left of the second dimension.\nfunction consecutive(first,second){var length=__.dimensions.length;return __.dimensions.some(function(d,i){return d===first?i+i<length&&__.dimensions[i+1]===second:!1})}if(0<ids.length){// We have some strums, which might need to be removed.\nids.forEach(function(d){var dims=strums[d].dims;strums.active=d;// If the two dimensions of the current strum are not next to each other\n// any more, than we\'ll need to remove the strum. Otherwise we keep it.\nif(!consecutive(dims.left,dims.right)){removeStrum(strums)}});onDragEnd(strums)()}});// Add a new svg group in which we draw the strums.\npc.selection.select("svg").append("g").attr("id","strums").attr("transform","translate("+__.margin.left+","+__.margin.top+")");// Install the required brushReset function\npc.brushReset=brushReset(strums);drag.on("dragstart",onDragStart(strums)).on("drag",onDrag(strums)).on("dragend",onDragEnd(strums));// NOTE: The styling needs to be done here and not in the css. This is because\n//       for 1D brushing, the canvas layers should not listen to\n//       pointer-events.\nstrumRect=pc.selection.select("svg").insert("rect","g#strums").attr("id","strum-events").attr("x",__.margin.left).attr("y",__.margin.top).attr("width",w()).attr("height",h()+2).style("opacity",0).call(drag)},uninstall:function uninstall(){pc.selection.select("svg").select("g#strums").remove();pc.selection.select("svg").select("rect#strum-events").remove();pc.on("axesreorder.strums",void 0);delete pc.brushReset;strumRect=void 0},selected:selected,brushState:function brushState(){return strums}}})();// brush mode: 1D-Axes with multiple extents\n// requires d3.svg.multibrush\n(function(){if("function"!=typeof d3.svg.multibrush){return}var brushes={};function is_brushed(p){return!brushes[p].empty()}// data within extents\nfunction selected(){var actives=__.dimensions.filter(is_brushed),extents=actives.map(function(p){return brushes[p].extent()});// We don\'t want to return the full data set when there are no axes brushed.\n// Actually, when there are no axes brushed, by definition, no items are\n// selected. So, let\'s avoid the filtering and just return false.\n//if (actives.length === 0) return false;\n// Resolves broken examples for now. They expect to get the full dataset back from empty brushes\nif(0===actives.length)return __.data;// test if within range\nvar within={date:function date(d,p,dimension,b){if("function"==typeof yscale[p].rangePoints){// if it is ordinal\nreturn b[0]<=yscale[p](d[p])&&yscale[p](d[p])<=b[1]}else{return b[0]<=d[p]&&d[p]<=b[1]}},number:function number(d,p,dimension,b){if("function"==typeof yscale[p].rangePoints){// if it is ordinal\nreturn b[0]<=yscale[p](d[p])&&yscale[p](d[p])<=b[1]}else{return b[0]<=d[p]&&d[p]<=b[1]}},string:function string(d,p,dimension,b){return b[0]<=yscale[p](d[p])&&yscale[p](d[p])<=b[1]}};return __.data.filter(function(d){switch(brush.predicate){case"AND":return actives.every(function(p,dimension){return extents[dimension].some(function(b){return within[__.types[p]](d,p,dimension,b)})});case"OR":return actives.some(function(p,dimension){return extents[dimension].some(function(b){return within[__.types[p]](d,p,dimension,b)})});default:throw"Unknown brush predicate "+__.brushPredicate;}})}function brushExtents(){var extents={};__.dimensions.forEach(function(d){var brush=brushes[d];if(brush!==void 0&&!brush.empty()){var extent=brush.extent();extents[d]=extent}});return extents}function brushFor(axis){var brush=d3.svg.multibrush();brush.y(yscale[axis]).on("brushstart",function(){if(null!==d3.event.sourceEvent){d3.event.sourceEvent.stopPropagation()}}).on("brush",function(){brushUpdated(selected())}).on("brushend",function(){// d3.svg.multibrush clears extents just before calling \'brushend\'\n// so we have to update here again.\n// This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n// to avoid unnecessary computation.\nbrushUpdated(selected());events.brushend.call(pc,__.brushed)}).extentAdaption(function(selection){selection.style("visibility",null).attr("x",-15).attr("width",30)}).resizeAdaption(function(selection){selection.selectAll("rect").attr("x",-15).attr("width",30)});brushes[axis]=brush;return brush}function brushReset(){__.brushed=!1;if(g){g.selectAll(".brush").each(function(d){d3.select(this).call(brushes[d].clear())});pc.renderBrushed()}return this}function install(){if(!g)pc.createAxes();// Add and store a brush for each axis.\ng.append("svg:g").attr("class","brush").each(function(d){d3.select(this).call(brushFor(d))}).selectAll("rect").style("visibility",null).attr("x",-15).attr("width",30);pc.brushExtents=brushExtents;pc.brushReset=brushReset;return pc}brush.modes["1D-axes-multi"]={install:install,uninstall:function uninstall(){g.selectAll(".brush").remove();brushes={};delete pc.brushExtents;delete pc.brushReset},selected:selected,brushState:brushExtents}})();// brush mode: angular\n// code based on 2D.strums.js\n(function(){var arcs={},strumRect;function drawStrum(arc,activePoint){var svg=pc.selection.select("svg").select("g#arcs"),id=arc.dims.i,points=[arc.p2,arc.p3],line=svg.selectAll("line#arc-"+id).data([{p1:arc.p1,p2:arc.p2},{p1:arc.p1,p2:arc.p3}]),circles=svg.selectAll("circle#arc-"+id).data(points),drag=d3.behavior.drag(),path=svg.selectAll("path#arc-"+id).data([arc]);path.enter().append("path").attr("id","arc-"+id).attr("class","arc").style("fill","orange").style("opacity",.5);path.attr("d",arc.arc).attr("transform","translate("+arc.p1[0]+","+arc.p1[1]+")");line.enter().append("line").attr("id","arc-"+id).attr("class","arc");line.attr("x1",function(d){return d.p1[0]}).attr("y1",function(d){return d.p1[1]}).attr("x2",function(d){return d.p2[0]}).attr("y2",function(d){return d.p2[1]}).attr("stroke","black").attr("stroke-width",2);drag.on("drag",function(d,i){var ev=d3.event,angle=0;i=i+2;arc["p"+i][0]=Math.min(Math.max(arc.minX+1,ev.x),arc.maxX);arc["p"+i][1]=Math.min(Math.max(arc.minY,ev.y),arc.maxY);angle=3===i?arcs.startAngle(id):arcs.endAngle(id);if(arc.startAngle<Math.PI&&arc.endAngle<Math.PI&&angle<Math.PI||arc.startAngle>=Math.PI&&arc.endAngle>=Math.PI&&angle>=Math.PI){if(2===i){arc.endAngle=angle;arc.arc.endAngle(angle)}else if(3===i){arc.startAngle=angle;arc.arc.startAngle(angle)}}drawStrum(arc,i-2)}).on("dragend",onDragEnd());circles.enter().append("circle").attr("id","arc-"+id).attr("class","arc");circles.attr("cx",function(d){return d[0]}).attr("cy",function(d){return d[1]}).attr("r",5).style("opacity",function(d,i){return activePoint!==void 0&&i===activePoint?.8:0}).on("mouseover",function(){d3.select(this).style("opacity",.8)}).on("mouseout",function(){d3.select(this).style("opacity",0)}).call(drag)}function dimensionsForPoint(p){var dims={i:-1,left:void 0,right:void 0};__.dimensions.some(function(dim,i){if(xscale(dim)<p[0]){var next=__.dimensions[i+1];dims.i=i;dims.left=dim;dims.right=next;return!1}return!0});if(dims.left===void 0){// Event on the left side of the first axis.\ndims.i=0;dims.left=__.dimensions[0];dims.right=__.dimensions[1]}else if(dims.right===void 0){// Event on the right side of the last axis\ndims.i=__.dimensions.length-1;dims.right=dims.left;dims.left=__.dimensions[__.dimensions.length-2]}return dims}function onDragStart(){// First we need to determine between which two axes the arc was started.\n// This will determine the freedom of movement, because a arc can\n// logically only happen between two axes, so no movement outside these axes\n// should be allowed.\nreturn function(){var p=d3.mouse(strumRect[0][0]),dims,arc;p[0]=p[0]-__.margin.left;p[1]=p[1]-__.margin.top;dims=dimensionsForPoint(p),arc={p1:p,dims:dims,minX:xscale(dims.left),maxX:xscale(dims.right),minY:0,maxY:h(),startAngle:void 0,endAngle:void 0,arc:d3.svg.arc().innerRadius(0)};arcs[dims.i]=arc;arcs.active=dims.i;// Make sure that the point is within the bounds\narc.p1[0]=Math.min(Math.max(arc.minX,p[0]),arc.maxX);arc.p2=arc.p1.slice();arc.p3=arc.p1.slice()}}function onDrag(){return function(){var ev=d3.event,arc=arcs[arcs.active];// Make sure that the point is within the bounds\narc.p2[0]=Math.min(Math.max(arc.minX+1,ev.x-__.margin.left),arc.maxX);arc.p2[1]=Math.min(Math.max(arc.minY,ev.y-__.margin.top),arc.maxY);arc.p3=arc.p2.slice();drawStrum(arc,1)}}// some helper functions\nfunction hypothenuse(a,b){return Math.sqrt(a*a+b*b)}var rad=function(){var c=Math.PI/180;return function(angle){return angle*c}}(),deg=function(){var c=180/Math.PI;return function(angle){return angle*c}}(),signedAngle=function(angle){var ret=angle;if(angle>Math.PI){ret=angle-1.5*Math.PI;ret=angle-1.5*Math.PI}else{ret=angle-.5*Math.PI;ret=angle-.5*Math.PI}return-ret};/**\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o\'clock.\n     * However, one can only select lines from 0 to PI, so we compute the\n     * \'signed\' angle, where 0 is the horizontal line (3 o\'clock), and +/- PI/2\n     * are 12 and 6 o\'clock respectively.\n     */function containmentTest(arc){var startAngle=signedAngle(arc.startAngle),endAngle=signedAngle(arc.endAngle);if(startAngle>endAngle){var tmp=startAngle;startAngle=endAngle;endAngle=tmp}// test if segment angle is contained in angle interval\nreturn function(a){if(a>=startAngle&&a<=endAngle){return!0}return!1}}function selected(){var ids=Object.getOwnPropertyNames(arcs),brushed=__.data;// Get the ids of the currently active arcs.\nids=ids.filter(function(d){return!isNaN(d)});function crossesStrum(d,id){var arc=arcs[id],test=containmentTest(arc),d1=arc.dims.left,d2=arc.dims.right,y1=yscale[d1],y2=yscale[d2],a=arcs.width(id),b=y1(d[d1])-y2(d[d2]),c=hypothenuse(a,b),angle=Math.asin(b/c);// rad in [-PI/2, PI/2]\nreturn test(angle)}if(0===ids.length){return brushed}return brushed.filter(function(d){switch(brush.predicate){case"AND":return ids.every(function(id){return crossesStrum(d,id)});case"OR":return ids.some(function(id){return crossesStrum(d,id)});default:throw"Unknown brush predicate "+__.brushPredicate;}})}function removeStrum(){var arc=arcs[arcs.active],svg=pc.selection.select("svg").select("g#arcs");delete arcs[arcs.active];arcs.active=void 0;svg.selectAll("line#arc-"+arc.dims.i).remove();svg.selectAll("circle#arc-"+arc.dims.i).remove();svg.selectAll("path#arc-"+arc.dims.i).remove()}function onDragEnd(){return function(){var brushed=__.data,arc=arcs[arcs.active];// Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n// considered a drag without move. So we have to deal with that case\nif(arc&&arc.p1[0]===arc.p2[0]&&arc.p1[1]===arc.p2[1]){removeStrum(arcs)}if(arc){var angle=arcs.startAngle(arcs.active);arc.startAngle=angle;arc.endAngle=angle;arc.arc.outerRadius(arcs.length(arcs.active)).startAngle(angle).endAngle(angle)}brushed=selected(arcs);arcs.active=void 0;__.brushed=brushed;pc.renderBrushed();events.brushend.call(pc,__.brushed)}}function brushReset(arcs){return function(){var ids=Object.getOwnPropertyNames(arcs).filter(function(d){return!isNaN(d)});ids.forEach(function(d){arcs.active=d;removeStrum(arcs)});onDragEnd(arcs)()}}brush.modes.angular={install:function(){var drag=d3.behavior.drag();// Map of current arcs. arcs are stored per segment of the PC. A segment,\n// being the area between two axes. The left most area is indexed at 0.\narcs.active=void 0;// Returns the width of the PC segment where currently a arc is being\n// placed. NOTE: even though they are evenly spaced in our current\n// implementation, we keep for when non-even spaced segments are supported as\n// well.\narcs.width=function(id){var arc=arcs[id];if(arc===void 0){return}return arc.maxX-arc.minX};// returns angles in [-PI/2, PI/2]\nangle=function angle(p1,p2){var a=p1[0]-p2[0],b=p1[1]-p2[1],c=hypothenuse(a,b);return Math.asin(b/c)};// returns angles in [0, 2 * PI]\narcs.endAngle=function(id){var arc=arcs[id];if(arc===void 0){return}var sAngle=angle(arc.p1,arc.p2),uAngle=-sAngle+Math.PI/2;if(arc.p1[0]>arc.p2[0]){uAngle=2*Math.PI-uAngle}return uAngle};arcs.startAngle=function(id){var arc=arcs[id];if(arc===void 0){return}var sAngle=angle(arc.p1,arc.p3),uAngle=-sAngle+Math.PI/2;if(arc.p1[0]>arc.p3[0]){uAngle=2*Math.PI-uAngle}return uAngle};arcs.length=function(id){var arc=arcs[id];if(arc===void 0){return}var a=arc.p1[0]-arc.p2[0],b=arc.p1[1]-arc.p2[1],c=hypothenuse(a,b);return c};pc.on("axesreorder.arcs",function(){var ids=Object.getOwnPropertyNames(arcs).filter(function(d){return!isNaN(d)});// Checks if the first dimension is directly left of the second dimension.\nfunction consecutive(first,second){var length=__.dimensions.length;return __.dimensions.some(function(d,i){return d===first?i+i<length&&__.dimensions[i+1]===second:!1})}if(0<ids.length){// We have some arcs, which might need to be removed.\nids.forEach(function(d){var dims=arcs[d].dims;arcs.active=d;// If the two dimensions of the current arc are not next to each other\n// any more, than we\'ll need to remove the arc. Otherwise we keep it.\nif(!consecutive(dims.left,dims.right)){removeStrum(arcs)}});onDragEnd(arcs)()}});// Add a new svg group in which we draw the arcs.\npc.selection.select("svg").append("g").attr("id","arcs").attr("transform","translate("+__.margin.left+","+__.margin.top+")");// Install the required brushReset function\npc.brushReset=brushReset(arcs);drag.on("dragstart",onDragStart(arcs)).on("drag",onDrag(arcs)).on("dragend",onDragEnd(arcs));// NOTE: The styling needs to be done here and not in the css. This is because\n//       for 1D brushing, the canvas layers should not listen to\n//       pointer-events.\nstrumRect=pc.selection.select("svg").insert("rect","g#arcs").attr("id","arc-events").attr("x",__.margin.left).attr("y",__.margin.top).attr("width",w()).attr("height",h()+2).style("opacity",0).call(drag)},uninstall:function uninstall(){pc.selection.select("svg").select("g#arcs").remove();pc.selection.select("svg").select("rect#arc-events").remove();pc.on("axesreorder.arcs",void 0);delete pc.brushReset;strumRect=void 0},selected:selected,brushState:function brushState(){return arcs}}})();pc.interactive=function(){flags.interactive=!0;return this};// expose a few objects\npc.xscale=xscale;pc.yscale=yscale;pc.ctx=ctx;pc.canvas=canvas;pc.g=function(){return g};// rescale for height, width and margins\n// TODO currently assumes chart is brushable, and destroys old brushes\npc.resize=function(){// selection size\npc.selection.select("svg").attr("width",__.width).attr("height",__.height);pc.svg.attr("transform","translate("+__.margin.left+","+__.margin.top+")");// FIXME: the current brush state should pass through\nif(flags.brushable)pc.brushReset();// scales\npc.autoscale();// axes, destroys old brushes.\nif(g)pc.createAxes();if(flags.brushable)pc.brushable();if(flags.reorderable)pc.reorderable();events.resize.call(this,{width:__.width,height:__.height,margin:__.margin});return this};// highlight an array of data\npc.highlight=function(data){if(0===arguments.length){return __.highlighted}__.highlighted=data;pc.clear("highlight");d3.selectAll([canvas.foreground,canvas.brushed]).classed("faded",!0);data.forEach(path_highlight);events.highlight.call(this,data);return this};// clear highlighting\npc.unhighlight=function(){__.highlighted=[];pc.clear("highlight");d3.selectAll([canvas.foreground,canvas.brushed]).classed("faded",!1);return this};// calculate 2d intersection of line a->b with line c->d\n// points are objects with x and y properties\npc.intersection=function(a,b,c,d){return{x:((a.x*b.y-a.y*b.x)*(c.x-d.x)-(a.x-b.x)*(c.x*d.y-c.y*d.x))/((a.x-b.x)*(c.y-d.y)-(a.y-b.y)*(c.x-d.x)),y:((a.x*b.y-a.y*b.x)*(c.y-d.y)-(a.y-b.y)*(c.x*d.y-c.y*d.x))/((a.x-b.x)*(c.y-d.y)-(a.y-b.y)*(c.x-d.x))}};function position(d){var v=dragging[d];return null==v?xscale(d):v}pc.version="0.7.0";// this descriptive text should live with other introspective methods\npc.toString=function(){return"Parallel Coordinates: "+__.dimensions.length+" dimensions ("+d3.keys(__.data[0]).length+" total) , "+__.data.length+" rows"};return pc});d3.renderQueue=function(func){var _queue=[],// data to be rendered\n_rate=10,// number of calls per frame\n_clear=function(){},// clearing function\n_i=0,rq=function(data){if(data)rq.data(data);rq.invalidate();_clear();rq.render()};// current iteration\nrq.render=function(){_i=0;var valid=!0;rq.invalidate=function(){valid=!1};function doFrame(){if(!valid)return!0;if(_i>_queue.length)return!0;// Typical d3 behavior is to pass a data item *and* its index. As the\n// render queue splits the original data set, we\'ll have to be slightly\n// more carefull about passing the correct index with the data item.\nfor(var end=Math.min(_i+_rate,_queue.length),i=_i;i<end;i++){func(_queue[i],i)}_i+=_rate}d3.timer(doFrame)};rq.data=function(data){rq.invalidate();_queue=data.slice(0);return rq};rq.rate=function(value){if(!arguments.length)return _rate;_rate=value;return rq};rq.remaining=function(){return _queue.length-_i};// clear the canvas\nrq.clear=function(func){if(!arguments.length){_clear();return rq}_clear=func;return rq};rq.invalidate=function(){};return rq};\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js\n/* [LICENSE TBD] */ /* eslint-disable */ // from http://bl.ocks.org/3687826\n/* harmony default export */ var divgrid = (function(){var columns=[],dg=function(selection){if(0==columns.length)columns=d3.keys(selection.data()[0][0]);// header\nselection.selectAll(".header").data([!0]).enter().append("div").attr("class","header");var header=selection.select(".header").selectAll(".cell").data(columns);header.enter().append("div").attr("class",function(d,i){return"col-"+i}).classed("cell",!0);selection.selectAll(".header .cell").text(function(d){return d});header.exit().remove();// rows\nvar rows=selection.selectAll(".row").data(function(d){return d});rows.enter().append("div").attr("class","row");rows.exit().remove();var cells=selection.selectAll(".row").selectAll(".cell").data(function(d){return columns.map(function(col){return d[col]})});// cells\ncells.enter().append("div").attr("class",function(d,i){return"col-"+i}).classed("cell",!0);cells.exit().remove();selection.selectAll(".cell").text(function(d){return d});return dg};dg.columns=function(_){if(!arguments.length)return columns;columns=_;return this};return dg});\n// EXTERNAL MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.css\nvar parcoords_d3_parcoords = __webpack_require__(2317);\n\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */ /* eslint-disable react/sort-prop-types */const propTypes={// Standard tabular data [{ fieldName1: value1, fieldName2: value2 }]\ndata:prop_types_default.a.arrayOf(prop_types_default.a.object),width:prop_types_default.a.number,height:prop_types_default.a.number,colorMetric:prop_types_default.a.string,includeSeries:prop_types_default.a.bool,linearColorScheme:prop_types_default.a.string,metrics:prop_types_default.a.arrayOf(prop_types_default.a.string),series:prop_types_default.a.string,showDatatable:prop_types_default.a.bool};function ParallelCoordinates(element,props){const{data,width,height,colorMetric,includeSeries,linearColorScheme,metrics,series,showDatatable}=props,cols=includeSeries?[series].concat(metrics):metrics,ttypes={};ttypes[series]="string";metrics.forEach(v=>{ttypes[v]="number"});const colorScale=colorMetric?Object(SequentialSchemeRegistrySingleton["a" /* default */])().get(linearColorScheme).createLinearScale(d3_default.a.extent(data,d=>d[colorMetric])):()=>"grey",container=d3_default.a.select(element).classed("superset-legacy-chart-parallel-coordinates",!0);container.selectAll("*").remove();const effHeight=showDatatable?height/2:height,div=container.append("div").style("height","".concat(effHeight,"px")).classed("parcoords",!0),chart=d3_parcoords()(div.node()).width(width).color(d=>colorScale(d[colorMetric])).alpha(.5).composite("darken").height(effHeight).data(data).dimensions(cols).types(ttypes).render().createAxes().shadows().reorderable().brushMode("1D-axes");if(showDatatable){// create data table, row hover highlighting\nconst grid=divgrid();container.append("div").style("height","".concat(effHeight,"px")).datum(data).call(grid).classed("parcoords grid",!0).selectAll(".row").on({mouseover(d){chart.highlight([d])},mouseout:chart.unhighlight});// update data table on brush event\nchart.on("brush",d=>{d3_default.a.select(".grid").datum(d).call(grid).selectAll(".row").on({mouseover(dd){chart.highlight([dd])},mouseout:chart.unhighlight})})}}ParallelCoordinates.displayName="ParallelCoordinates";ParallelCoordinates.propTypes=propTypes;/* harmony default export */ var src_ParallelCoordinates = (ParallelCoordinates);\n// CONCATENATED MODULE: /Users/kamilgabryjelski/projects/superset-ui/plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\nfunction _templateObject(){const data=_taggedTemplateLiteral(["\\n  .superset-legacy-chart-parallel-coordinates {\\n    div.grid {\\n      overflow: auto;\\n      div.row {\\n        &:hover {\\n          background-color: #ccc;\\n        }\\n      }\\n    }\\n  }\\n"]);_templateObject=function(){return data};return data}function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0)}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}))}function _objectWithoutProperties(source,excluded){if(null==source)return{};var target=_objectWithoutPropertiesLoose(source,excluded),key,i;if(Object.getOwnPropertySymbols){var sourceSymbolKeys=Object.getOwnPropertySymbols(source);for(i=0;i<sourceSymbolKeys.length;i++){key=sourceSymbolKeys[i];if(0<=excluded.indexOf(key))continue;if(!Object.prototype.propertyIsEnumerable.call(source,key))continue;target[key]=source[key]}}return target}function _objectWithoutPropertiesLoose(source,excluded){if(null==source)return{};var target={},sourceKeys=Object.keys(source),key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(0<=excluded.indexOf(key))continue;target[key]=source[key]}return target}/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */const ReactComponent=Object(src["reactify"])(src_ParallelCoordinates),ParallelCoordianes=(_ref)=>{let{className}=_ref,otherProps=_objectWithoutProperties(_ref,["className"]);return/*#__PURE__*/react_default.a.createElement("div",{className:className},/*#__PURE__*/react_default.a.createElement(ReactComponent,otherProps))};ParallelCoordianes.displayName="ParallelCoordianes";ParallelCoordianes.propTypes={className:prop_types_default.a.string.isRequired};/* harmony default export */ var ReactParallelCoordinates = __webpack_exports__["default"] = (Object(style["c" /* styled */])(ParallelCoordianes)(_templateObject()));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ5Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmpzPzQyZDEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9zcmMvdmVuZG9yL3BhcmNvb3Jkcy9kaXZncmlkLmpzP2U2NDIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9rYW1pbGdhYnJ5amVsc2tpL3Byb2plY3RzL3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9zcmMvUGFyYWxsZWxDb29yZGluYXRlcy5qcz83NTVhIiwid2VicGFjazovLy8vVXNlcnMva2FtaWxnYWJyeWplbHNraS9wcm9qZWN0cy9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL1JlYWN0UGFyYWxsZWxDb29yZGluYXRlcy5qc3g/NWI4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBbTElDRU5TRSBUQkRdICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgX18gPSB7XG4gICAgZGF0YTogW10sXG4gICAgaGlnaGxpZ2h0ZWQ6IFtdLFxuICAgIGRpbWVuc2lvbnM6IFtdLFxuICAgIGRpbWVuc2lvblRpdGxlczoge30sXG4gICAgZGltZW5zaW9uVGl0bGVSb3RhdGlvbjogMCxcbiAgICB0eXBlczoge30sXG4gICAgYnJ1c2hlZDogZmFsc2UsXG4gICAgYnJ1c2hlZENvbG9yOiBudWxsLFxuICAgIGFscGhhT25CcnVzaGVkOiAwLjAsXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgIHJhdGU6IDIwLFxuICAgIHdpZHRoOiA2MDAsXG4gICAgaGVpZ2h0OiAzMDAsXG4gICAgbWFyZ2luOiB7IHRvcDogMjQsIHJpZ2h0OiAwLCBib3R0b206IDEyLCBsZWZ0OiAwIH0sXG4gICAgbnVsbFZhbHVlU2VwYXJhdG9yOiAndW5kZWZpbmVkJywgLy8gc2V0IHRvIFwidG9wXCIgb3IgXCJib3R0b21cIlxuICAgIG51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmc6IHsgdG9wOiA4LCByaWdodDogMCwgYm90dG9tOiA4LCBsZWZ0OiAwIH0sXG4gICAgY29sb3I6ICcjMDY5JyxcbiAgICBjb21wb3NpdGU6ICdzb3VyY2Utb3ZlcicsXG4gICAgYWxwaGE6IDAuNyxcbiAgICBidW5kbGluZ1N0cmVuZ3RoOiAwLjUsXG4gICAgYnVuZGxlRGltZW5zaW9uOiBudWxsLFxuICAgIHNtb290aG5lc3M6IDAuMCxcbiAgICBzaG93Q29udHJvbFBvaW50czogZmFsc2UsXG4gICAgaGlkZUF4aXM6IFtdLFxuICB9O1xuXG4gIGV4dGVuZChfXywgY29uZmlnKTtcblxuICB2YXIgcGMgPSBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uID0gcGMuc2VsZWN0aW9uID0gZDMuc2VsZWN0KHNlbGVjdGlvbik7XG5cbiAgICBfXy53aWR0aCA9IHNlbGVjdGlvblswXVswXS5jbGllbnRXaWR0aDtcbiAgICBfXy5oZWlnaHQgPSBzZWxlY3Rpb25bMF1bMF0uY2xpZW50SGVpZ2h0O1xuXG4gICAgLy8gY2FudmFzIGRhdGEgbGF5ZXJzXG4gICAgWydtYXJrcycsICdmb3JlZ3JvdW5kJywgJ2JydXNoZWQnLCAnaGlnaGxpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgIGNhbnZhc1tsYXllcl0gPSBzZWxlY3Rpb24uYXBwZW5kKCdjYW52YXMnKS5hdHRyKCdjbGFzcycsIGxheWVyKVswXVswXTtcbiAgICAgIGN0eFtsYXllcl0gPSBjYW52YXNbbGF5ZXJdLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSk7XG5cbiAgICAvLyBzdmcgdGljayBhbmQgYnJ1c2ggbGF5ZXJzXG4gICAgcGMuc3ZnID0gc2VsZWN0aW9uXG4gICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgLmF0dHIoJ3dpZHRoJywgX18ud2lkdGgpXG4gICAgICAuYXR0cignaGVpZ2h0JywgX18uaGVpZ2h0KVxuICAgICAgLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIF9fLm1hcmdpbi5sZWZ0ICsgJywnICsgX18ubWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICByZXR1cm4gcGM7XG4gIH07XG4gIHZhciBldmVudHMgPSBkMy5kaXNwYXRjaC5hcHBseShcbiAgICAgIHRoaXMsXG4gICAgICBbJ3JlbmRlcicsICdyZXNpemUnLCAnaGlnaGxpZ2h0JywgJ2JydXNoJywgJ2JydXNoZW5kJywgJ2F4ZXNyZW9yZGVyJ10uY29uY2F0KGQzLmtleXMoX18pKSxcbiAgICApLFxuICAgIHcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX18ud2lkdGggLSBfXy5tYXJnaW4ucmlnaHQgLSBfXy5tYXJnaW4ubGVmdDtcbiAgICB9LFxuICAgIGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX18uaGVpZ2h0IC0gX18ubWFyZ2luLnRvcCAtIF9fLm1hcmdpbi5ib3R0b207XG4gICAgfSxcbiAgICBmbGFncyA9IHtcbiAgICAgIGJydXNoYWJsZTogZmFsc2UsXG4gICAgICByZW9yZGVyYWJsZTogZmFsc2UsXG4gICAgICBheGVzOiBmYWxzZSxcbiAgICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICB9LFxuICAgIHhzY2FsZSA9IGQzLnNjYWxlLm9yZGluYWwoKSxcbiAgICB5c2NhbGUgPSB7fSxcbiAgICBkcmFnZ2luZyA9IHt9LFxuICAgIGxpbmUgPSBkMy5zdmcubGluZSgpLFxuICAgIGF4aXMgPSBkMy5zdmcuYXhpcygpLm9yaWVudCgnbGVmdCcpLnRpY2tzKDUpLFxuICAgIGcsIC8vIGdyb3VwcyBmb3IgYXhlcywgYnJ1c2hlc1xuICAgIGN0eCA9IHt9LFxuICAgIGNhbnZhcyA9IHt9LFxuICAgIGNsdXN0ZXJDZW50cm9pZHMgPSBbXTtcblxuICAvLyBzaWRlIGVmZmVjdHMgZm9yIHNldHRlcnNcbiAgdmFyIHNpZGVfZWZmZWN0cyA9IGQzLmRpc3BhdGNoXG4gICAgLmFwcGx5KHRoaXMsIGQzLmtleXMoX18pKVxuICAgIC5vbignY29tcG9zaXRlJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIGN0eC5mb3JlZ3JvdW5kLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGQudmFsdWU7XG4gICAgICBjdHguYnJ1c2hlZC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBkLnZhbHVlO1xuICAgIH0pXG4gICAgLm9uKCdhbHBoYScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBjdHguZm9yZWdyb3VuZC5nbG9iYWxBbHBoYSA9IGQudmFsdWU7XG4gICAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IGQudmFsdWU7XG4gICAgfSlcbiAgICAub24oJ2JydXNoZWRDb2xvcicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBjdHguYnJ1c2hlZC5zdHJva2VTdHlsZSA9IGQudmFsdWU7XG4gICAgfSlcbiAgICAub24oJ3dpZHRoJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHBjLnJlc2l6ZSgpO1xuICAgIH0pXG4gICAgLm9uKCdoZWlnaHQnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcGMucmVzaXplKCk7XG4gICAgfSlcbiAgICAub24oJ21hcmdpbicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBwYy5yZXNpemUoKTtcbiAgICB9KVxuICAgIC5vbigncmF0ZScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBicnVzaGVkUXVldWUucmF0ZShkLnZhbHVlKTtcbiAgICAgIGZvcmVncm91bmRRdWV1ZS5yYXRlKGQudmFsdWUpO1xuICAgIH0pXG4gICAgLm9uKCdkaW1lbnNpb25zJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHhzY2FsZS5kb21haW4oX18uZGltZW5zaW9ucyk7XG4gICAgICBpZiAoZmxhZ3MuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgcGMucmVuZGVyKCkudXBkYXRlQXhlcygpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLm9uKCdidW5kbGVEaW1lbnNpb24nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKCFfXy5kaW1lbnNpb25zLmxlbmd0aCkgcGMuZGV0ZWN0RGltZW5zaW9ucygpO1xuICAgICAgaWYgKCEoX18uZGltZW5zaW9uc1swXSBpbiB5c2NhbGUpKSBwYy5hdXRvc2NhbGUoKTtcbiAgICAgIGlmICh0eXBlb2YgZC52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGQudmFsdWUgPCBfXy5kaW1lbnNpb25zLmxlbmd0aCkge1xuICAgICAgICAgIF9fLmJ1bmRsZURpbWVuc2lvbiA9IF9fLmRpbWVuc2lvbnNbZC52YWx1ZV07XG4gICAgICAgIH0gZWxzZSBpZiAoZC52YWx1ZSA8IF9fLmhpZGVBeGlzLmxlbmd0aCkge1xuICAgICAgICAgIF9fLmJ1bmRsZURpbWVuc2lvbiA9IF9fLmhpZGVBeGlzW2QudmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfXy5idW5kbGVEaW1lbnNpb24gPSBkLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBfXy5jbHVzdGVyQ2VudHJvaWRzID0gY29tcHV0ZV9jbHVzdGVyX2NlbnRyb2lkcyhfXy5idW5kbGVEaW1lbnNpb24pO1xuICAgIH0pXG4gICAgLm9uKCdoaWRlQXhpcycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBpZiAoIV9fLmRpbWVuc2lvbnMubGVuZ3RoKSBwYy5kZXRlY3REaW1lbnNpb25zKCk7XG4gICAgICBwYy5kaW1lbnNpb25zKHdpdGhvdXQoX18uZGltZW5zaW9ucywgZC52YWx1ZSkpO1xuICAgIH0pO1xuXG4gIC8vIGV4cG9zZSB0aGUgc3RhdGUgb2YgdGhlIGNoYXJ0XG4gIHBjLnN0YXRlID0gX187XG4gIHBjLmZsYWdzID0gZmxhZ3M7XG5cbiAgLy8gY3JlYXRlIGdldHRlci9zZXR0ZXJzXG4gIGdldHNldChwYywgX18sIGV2ZW50cyk7XG5cbiAgLy8gZXhwb3NlIGV2ZW50c1xuICBkMy5yZWJpbmQocGMsIGV2ZW50cywgJ29uJyk7XG5cbiAgLy8gZ2V0dGVyL3NldHRlciB3aXRoIGV2ZW50IGZpcmluZ1xuICBmdW5jdGlvbiBnZXRzZXQob2JqLCBzdGF0ZSwgZXZlbnRzKSB7XG4gICAgZDMua2V5cyhzdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGQgPSBzdGF0ZVtrZXldO1xuICAgICAgICBzdGF0ZVtrZXldID0geDtcbiAgICAgICAgc2lkZV9lZmZlY3RzW2tleV0uY2FsbChwYywgeyB2YWx1ZTogeCwgcHJldmlvdXM6IG9sZCB9KTtcbiAgICAgICAgZXZlbnRzW2tleV0uY2FsbChwYywgeyB2YWx1ZTogeCwgcHJldmlvdXM6IG9sZCB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aG91dChhcnIsIGl0ZW0pIHtcbiAgICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uaW5kZXhPZihlbGVtKSA9PT0gLTE7XG4gICAgfSk7XG4gIH1cbiAgLyoqIGFkanVzdHMgYW4gYXhpcycgZGVmYXVsdCByYW5nZSBbaCgpKzEsIDFdIGlmIGEgTnVsbFZhbHVlU2VwYXJhdG9yIGlzIHNldCAqL1xuICBmdW5jdGlvbiBnZXRSYW5nZSgpIHtcbiAgICBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4gW2goKSArIDEgLSBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLmJvdHRvbSAtIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcudG9wLCAxXTtcbiAgICB9IGVsc2UgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAndG9wJykge1xuICAgICAgcmV0dXJuIFtoKCkgKyAxLCAxICsgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy5ib3R0b20gKyBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLnRvcF07XG4gICAgfVxuICAgIHJldHVybiBbaCgpICsgMSwgMV07XG4gIH1cblxuICBwYy5hdXRvc2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8geXNjYWxlXG4gICAgdmFyIGRlZmF1bHRTY2FsZXMgPSB7XG4gICAgICBkYXRlOiBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgZXh0ZW50ID0gZDMuZXh0ZW50KF9fLmRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGRba10gPyBkW2tdLmdldFRpbWUoKSA6IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBpZiBzaW5nbGUgdmFsdWVcbiAgICAgICAgaWYgKGV4dGVudFswXSA9PT0gZXh0ZW50WzFdKSB7XG4gICAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5kb21haW4oW2V4dGVudFswXV0pLnJhbmdlUG9pbnRzKGdldFJhbmdlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQzLnRpbWUuc2NhbGUoKS5kb21haW4oZXh0ZW50KS5yYW5nZShnZXRSYW5nZSgpKTtcbiAgICAgIH0sXG4gICAgICBudW1iZXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSBkMy5leHRlbnQoX18uZGF0YSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gK2Rba107XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBpZiBzaW5nbGUgdmFsdWVcbiAgICAgICAgaWYgKGV4dGVudFswXSA9PT0gZXh0ZW50WzFdKSB7XG4gICAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5kb21haW4oW2V4dGVudFswXV0pLnJhbmdlUG9pbnRzKGdldFJhbmdlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlLmxpbmVhcigpLmRvbWFpbihleHRlbnQpLnJhbmdlKGdldFJhbmdlKCkpO1xuICAgICAgfSxcbiAgICAgIHN0cmluZzogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgdmFyIGNvdW50cyA9IHt9LFxuICAgICAgICAgIGRvbWFpbiA9IFtdO1xuXG4gICAgICAgIC8vIExldCdzIGdldCB0aGUgY291bnQgZm9yIGVhY2ggdmFsdWUgc28gdGhhdCB3ZSBjYW4gc29ydCB0aGUgZG9tYWluIGJhc2VkXG4gICAgICAgIC8vIG9uIHRoZSBudW1iZXIgb2YgaXRlbXMgZm9yIGVhY2ggdmFsdWUuXG4gICAgICAgIF9fLmRhdGEubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgaWYgKHBba10gPT09IHVuZGVmaW5lZCAmJiBfXy5udWxsVmFsdWVTZXBhcmF0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG51bGwgdmFsdWVzIHdpbGwgYmUgZHJhd24gYmV5b25kIHRoZSBob3Jpem9udGFsIG51bGwgdmFsdWUgc2VwYXJhdG9yIVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY291bnRzW3Bba11dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvdW50c1twW2tdXSA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50c1twW2tdXSA9IGNvdW50c1twW2tdXSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkb21haW4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb3VudHMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gY291bnRzW2FdIC0gY291bnRzW2JdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLmRvbWFpbihkb21haW4pLnJhbmdlUG9pbnRzKGdldFJhbmdlKCkpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICB5c2NhbGVba10gPSBkZWZhdWx0U2NhbGVzW19fLnR5cGVzW2tdXShrKTtcbiAgICB9KTtcblxuICAgIF9fLmhpZGVBeGlzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIHlzY2FsZVtrXSA9IGRlZmF1bHRTY2FsZXNbX18udHlwZXNba11dKGspO1xuICAgIH0pO1xuXG4gICAgLy8geHNjYWxlXG4gICAgeHNjYWxlLnJhbmdlUG9pbnRzKFswLCB3KCldLCAxKTtcblxuICAgIC8vIGNhbnZhcyBzaXplc1xuICAgIHBjLnNlbGVjdGlvblxuICAgICAgLnNlbGVjdEFsbCgnY2FudmFzJylcbiAgICAgIC5zdHlsZSgnbWFyZ2luLXRvcCcsIF9fLm1hcmdpbi50b3AgKyAncHgnKVxuICAgICAgLnN0eWxlKCdtYXJnaW4tbGVmdCcsIF9fLm1hcmdpbi5sZWZ0ICsgJ3B4JylcbiAgICAgIC5hdHRyKCd3aWR0aCcsIHcoKSArIDIpXG4gICAgICAuYXR0cignaGVpZ2h0JywgaCgpICsgMik7XG5cbiAgICAvLyBkZWZhdWx0IHN0eWxlcywgbmVlZHMgdG8gYmUgc2V0IHdoZW4gY2FudmFzIHdpZHRoIGNoYW5nZXNcbiAgICBjdHguZm9yZWdyb3VuZC5zdHJva2VTdHlsZSA9IF9fLmNvbG9yO1xuICAgIGN0eC5mb3JlZ3JvdW5kLmxpbmVXaWR0aCA9IDEuNDtcbiAgICBjdHguZm9yZWdyb3VuZC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBfXy5jb21wb3NpdGU7XG4gICAgY3R4LmZvcmVncm91bmQuZ2xvYmFsQWxwaGEgPSBfXy5hbHBoYTtcbiAgICBjdHguYnJ1c2hlZC5zdHJva2VTdHlsZSA9IF9fLmJydXNoZWRDb2xvcjtcbiAgICBjdHguYnJ1c2hlZC5saW5lV2lkdGggPSAxLjQ7XG4gICAgY3R4LmJydXNoZWQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gX18uY29tcG9zaXRlO1xuICAgIGN0eC5icnVzaGVkLmdsb2JhbEFscGhhID0gX18uYWxwaGE7XG4gICAgY3R4LmhpZ2hsaWdodC5saW5lV2lkdGggPSAzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMuc2NhbGUgPSBmdW5jdGlvbiAoZCwgZG9tYWluKSB7XG4gICAgeXNjYWxlW2RdLmRvbWFpbihkb21haW4pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMuZmxpcCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgLy95c2NhbGVbZF0uZG9tYWluKCkucmV2ZXJzZSgpOyAgICAgICAgIC8vIGRvZXMgbm90IHdvcmtcbiAgICB5c2NhbGVbZF0uZG9tYWluKHlzY2FsZVtkXS5kb21haW4oKS5yZXZlcnNlKCkpOyAvLyB3b3Jrc1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMuY29tbW9uU2NhbGUgPSBmdW5jdGlvbiAoZ2xvYmFsLCB0eXBlKSB7XG4gICAgdmFyIHQgPSB0eXBlIHx8ICdudW1iZXInO1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBzY2FsZXMgb2YgdGhlIHNhbWUgdHlwZVxuICAgIHZhciBzY2FsZXMgPSBfXy5kaW1lbnNpb25zLmNvbmNhdChfXy5oaWRlQXhpcykuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gX18udHlwZXNbcF0gPT0gdDtcbiAgICB9KTtcblxuICAgIGlmIChnbG9iYWwpIHtcbiAgICAgIHZhciBleHRlbnQgPSBkMy5leHRlbnQoXG4gICAgICAgIHNjYWxlc1xuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB5c2NhbGVbcF0uZG9tYWluKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgICBzY2FsZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICB5c2NhbGVbZF0uZG9tYWluKGV4dGVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgeXNjYWxlW2tdLmRvbWFpbihcbiAgICAgICAgICBkMy5leHRlbnQoX18uZGF0YSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiArZFtrXTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBjZW50cm9pZHNcbiAgICBpZiAoX18uYnVuZGxlRGltZW5zaW9uICE9PSBudWxsKSB7XG4gICAgICBwYy5idW5kbGVEaW1lbnNpb24oX18uYnVuZGxlRGltZW5zaW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcGMuZGV0ZWN0RGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYy50eXBlcyhwYy5kZXRlY3REaW1lbnNpb25UeXBlcyhfXy5kYXRhKSk7XG4gICAgcGMuZGltZW5zaW9ucyhkMy5rZXlzKHBjLnR5cGVzKCkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBhIGJldHRlciBcInR5cGVvZlwiIGZyb20gdGhpcyBwb3N0OiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczOTA0MjYvYmV0dGVyLXdheS10by1nZXQtdHlwZS1vZi1hLWphdmFzY3JpcHQtdmFyaWFibGVcbiAgcGMudG9UeXBlID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmdcbiAgICAgIC5jYWxsKHYpXG4gICAgICAubWF0Y2goL1xccyhbYS16QS1aXSspLylbMV1cbiAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICB9O1xuXG4gIC8vIHRyeSB0byBjb2VyY2UgdG8gbnVtYmVyIGJlZm9yZSByZXR1cm5pbmcgdHlwZVxuICBwYy50b1R5cGVDb2VyY2VOdW1iZXJzID0gZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocGFyc2VGbG9hdCh2KSA9PSB2ICYmIHYgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgIH1cbiAgICByZXR1cm4gcGMudG9UeXBlKHYpO1xuICB9O1xuXG4gIC8vIGF0dGVtcHQgdG8gZGV0ZXJtaW5lIHR5cGVzIG9mIGVhY2ggZGltZW5zaW9uIGJhc2VkIG9uIGZpcnN0IHJvdyBvZiBkYXRhXG4gIHBjLmRldGVjdERpbWVuc2lvblR5cGVzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdHlwZXMgPSB7fTtcbiAgICBkMy5rZXlzKGRhdGFbMF0pLmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgdHlwZXNbY29sXSA9IHBjLnRvVHlwZUNvZXJjZU51bWJlcnMoZGF0YVswXVtjb2xdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHlwZXM7XG4gIH07XG4gIHBjLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB0cnkgdG8gYXV0b2RldGVjdCBkaW1lbnNpb25zIGFuZCBjcmVhdGUgc2NhbGVzXG4gICAgaWYgKCFfXy5kaW1lbnNpb25zLmxlbmd0aCkgcGMuZGV0ZWN0RGltZW5zaW9ucygpO1xuICAgIGlmICghKF9fLmRpbWVuc2lvbnNbMF0gaW4geXNjYWxlKSkgcGMuYXV0b3NjYWxlKCk7XG5cbiAgICBwYy5yZW5kZXJbX18ubW9kZV0oKTtcblxuICAgIGV2ZW50cy5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwYy5yZW5kZXJCcnVzaGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcbiAgICBpZiAoIShfXy5kaW1lbnNpb25zWzBdIGluIHlzY2FsZSkpIHBjLmF1dG9zY2FsZSgpO1xuXG4gICAgcGMucmVuZGVyQnJ1c2hlZFtfXy5tb2RlXSgpO1xuXG4gICAgZXZlbnRzLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzQnJ1c2hlZCgpIHtcbiAgICBpZiAoX18uYnJ1c2hlZCAmJiBfXy5icnVzaGVkLmxlbmd0aCAhPT0gX18uZGF0YS5sZW5ndGgpIHJldHVybiB0cnVlO1xuXG4gICAgdmFyIG9iamVjdCA9IGJydXNoLmN1cnJlbnRNb2RlKCkuYnJ1c2hTdGF0ZSgpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwYy5yZW5kZXIuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYy5jbGVhcignZm9yZWdyb3VuZCcpO1xuICAgIHBjLmNsZWFyKCdoaWdobGlnaHQnKTtcblxuICAgIHBjLnJlbmRlckJydXNoZWQuZGVmYXVsdCgpO1xuXG4gICAgX18uZGF0YS5mb3JFYWNoKHBhdGhfZm9yZWdyb3VuZCk7XG4gIH07XG5cbiAgdmFyIGZvcmVncm91bmRRdWV1ZSA9IGQzXG4gICAgLnJlbmRlclF1ZXVlKHBhdGhfZm9yZWdyb3VuZClcbiAgICAucmF0ZSg1MClcbiAgICAuY2xlYXIoZnVuY3Rpb24gKCkge1xuICAgICAgcGMuY2xlYXIoJ2ZvcmVncm91bmQnKTtcbiAgICAgIHBjLmNsZWFyKCdoaWdobGlnaHQnKTtcbiAgICB9KTtcblxuICBwYy5yZW5kZXIucXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGMucmVuZGVyQnJ1c2hlZC5xdWV1ZSgpO1xuXG4gICAgZm9yZWdyb3VuZFF1ZXVlKF9fLmRhdGEpO1xuICB9O1xuXG4gIHBjLnJlbmRlckJydXNoZWQuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYy5jbGVhcignYnJ1c2hlZCcpO1xuXG4gICAgaWYgKGlzQnJ1c2hlZCgpKSB7XG4gICAgICBfXy5icnVzaGVkLmZvckVhY2gocGF0aF9icnVzaGVkKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJydXNoZWRRdWV1ZSA9IGQzXG4gICAgLnJlbmRlclF1ZXVlKHBhdGhfYnJ1c2hlZClcbiAgICAucmF0ZSg1MClcbiAgICAuY2xlYXIoZnVuY3Rpb24gKCkge1xuICAgICAgcGMuY2xlYXIoJ2JydXNoZWQnKTtcbiAgICB9KTtcblxuICBwYy5yZW5kZXJCcnVzaGVkLnF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc0JydXNoZWQoKSkge1xuICAgICAgYnJ1c2hlZFF1ZXVlKF9fLmJydXNoZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBicnVzaGVkUXVldWUoW10pOyAvLyBUaGlzIGlzIG5lZWRlZCB0byBjbGVhciB0aGUgY3VycmVudGx5IGJydXNoZWQgaXRlbXNcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGNvbXB1dGVfY2x1c3Rlcl9jZW50cm9pZHMoZCkge1xuICAgIHZhciBjbHVzdGVyQ2VudHJvaWRzID0gZDMubWFwKCk7XG4gICAgdmFyIGNsdXN0ZXJDb3VudHMgPSBkMy5tYXAoKTtcbiAgICAvLyBkZXRlcm1pbmUgY2x1c3RlckNvdW50c1xuICAgIF9fLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICB2YXIgc2NhbGVkID0geXNjYWxlW2RdKHJvd1tkXSk7XG4gICAgICBpZiAoIWNsdXN0ZXJDb3VudHMuaGFzKHNjYWxlZCkpIHtcbiAgICAgICAgY2x1c3RlckNvdW50cy5zZXQoc2NhbGVkLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb3VudCA9IGNsdXN0ZXJDb3VudHMuZ2V0KHNjYWxlZCk7XG4gICAgICBjbHVzdGVyQ291bnRzLnNldChzY2FsZWQsIGNvdW50ICsgMSk7XG4gICAgfSk7XG5cbiAgICBfXy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgX18uZGltZW5zaW9ucy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgdmFyIHNjYWxlZCA9IHlzY2FsZVtkXShyb3dbZF0pO1xuICAgICAgICBpZiAoIWNsdXN0ZXJDZW50cm9pZHMuaGFzKHNjYWxlZCkpIHtcbiAgICAgICAgICB2YXIgbWFwID0gZDMubWFwKCk7XG4gICAgICAgICAgY2x1c3RlckNlbnRyb2lkcy5zZXQoc2NhbGVkLCBtYXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5oYXMocCkpIHtcbiAgICAgICAgICBjbHVzdGVyQ2VudHJvaWRzLmdldChzY2FsZWQpLnNldChwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBjbHVzdGVyQ2VudHJvaWRzLmdldChzY2FsZWQpLmdldChwKTtcbiAgICAgICAgdmFsdWUgKz0geXNjYWxlW3BdKHJvd1twXSkgLyBjbHVzdGVyQ291bnRzLmdldChzY2FsZWQpO1xuICAgICAgICBjbHVzdGVyQ2VudHJvaWRzLmdldChzY2FsZWQpLnNldChwLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjbHVzdGVyQ2VudHJvaWRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZV9jZW50cm9pZHMocm93KSB7XG4gICAgdmFyIGNlbnRyb2lkcyA9IFtdO1xuXG4gICAgdmFyIHAgPSBfXy5kaW1lbnNpb25zO1xuICAgIHZhciBjb2xzID0gcC5sZW5ndGg7XG4gICAgdmFyIGEgPSAwLjU7IC8vIGNlbnRlciBiZXR3ZWVuIGF4ZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHM7ICsraSkge1xuICAgICAgLy8gY2VudHJvaWRzIG9uICdyZWFsJyBheGVzXG4gICAgICB2YXIgeCA9IHBvc2l0aW9uKHBbaV0pO1xuICAgICAgdmFyIHkgPSB5c2NhbGVbcFtpXV0ocm93W3BbaV1dKTtcbiAgICAgIGNlbnRyb2lkcy5wdXNoKCRWKFt4LCB5XSkpO1xuXG4gICAgICAvLyBjZW50cm9pZHMgb24gJ3ZpcnR1YWwnIGF4ZXNcbiAgICAgIGlmIChpIDwgY29scyAtIDEpIHtcbiAgICAgICAgdmFyIGN4ID0geCArIGEgKiAocG9zaXRpb24ocFtpICsgMV0pIC0geCk7XG4gICAgICAgIHZhciBjeSA9IHkgKyBhICogKHlzY2FsZVtwW2kgKyAxXV0ocm93W3BbaSArIDFdXSkgLSB5KTtcbiAgICAgICAgaWYgKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBsZWZ0Q2VudHJvaWQgPSBfXy5jbHVzdGVyQ2VudHJvaWRzXG4gICAgICAgICAgICAuZ2V0KHlzY2FsZVtfXy5idW5kbGVEaW1lbnNpb25dKHJvd1tfXy5idW5kbGVEaW1lbnNpb25dKSlcbiAgICAgICAgICAgIC5nZXQocFtpXSk7XG4gICAgICAgICAgdmFyIHJpZ2h0Q2VudHJvaWQgPSBfXy5jbHVzdGVyQ2VudHJvaWRzXG4gICAgICAgICAgICAuZ2V0KHlzY2FsZVtfXy5idW5kbGVEaW1lbnNpb25dKHJvd1tfXy5idW5kbGVEaW1lbnNpb25dKSlcbiAgICAgICAgICAgIC5nZXQocFtpICsgMV0pO1xuICAgICAgICAgIHZhciBjZW50cm9pZCA9IDAuNSAqIChsZWZ0Q2VudHJvaWQgKyByaWdodENlbnRyb2lkKTtcbiAgICAgICAgICBjeSA9IGNlbnRyb2lkICsgKDEgLSBfXy5idW5kbGluZ1N0cmVuZ3RoKSAqIChjeSAtIGNlbnRyb2lkKTtcbiAgICAgICAgfVxuICAgICAgICBjZW50cm9pZHMucHVzaCgkVihbY3gsIGN5XSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjZW50cm9pZHM7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlX2NvbnRyb2xfcG9pbnRzKGNlbnRyb2lkcykge1xuICAgIHZhciBjb2xzID0gY2VudHJvaWRzLmxlbmd0aDtcbiAgICB2YXIgYSA9IF9fLnNtb290aG5lc3M7XG4gICAgdmFyIGNwcyA9IFtdO1xuXG4gICAgY3BzLnB1c2goY2VudHJvaWRzWzBdKTtcbiAgICBjcHMucHVzaChcbiAgICAgICRWKFtjZW50cm9pZHNbMF0uZSgxKSArIGEgKiAyICogKGNlbnRyb2lkc1sxXS5lKDEpIC0gY2VudHJvaWRzWzBdLmUoMSkpLCBjZW50cm9pZHNbMF0uZSgyKV0pLFxuICAgICk7XG4gICAgZm9yICh2YXIgY29sID0gMTsgY29sIDwgY29scyAtIDE7ICsrY29sKSB7XG4gICAgICB2YXIgbWlkID0gY2VudHJvaWRzW2NvbF07XG4gICAgICB2YXIgbGVmdCA9IGNlbnRyb2lkc1tjb2wgLSAxXTtcbiAgICAgIHZhciByaWdodCA9IGNlbnRyb2lkc1tjb2wgKyAxXTtcblxuICAgICAgdmFyIGRpZmYgPSBsZWZ0LnN1YnRyYWN0KHJpZ2h0KTtcbiAgICAgIGNwcy5wdXNoKG1pZC5hZGQoZGlmZi54KGEpKSk7XG4gICAgICBjcHMucHVzaChtaWQpO1xuICAgICAgY3BzLnB1c2gobWlkLnN1YnRyYWN0KGRpZmYueChhKSkpO1xuICAgIH1cbiAgICBjcHMucHVzaChcbiAgICAgICRWKFtcbiAgICAgICAgY2VudHJvaWRzW2NvbHMgLSAxXS5lKDEpICsgYSAqIDIgKiAoY2VudHJvaWRzW2NvbHMgLSAyXS5lKDEpIC0gY2VudHJvaWRzW2NvbHMgLSAxXS5lKDEpKSxcbiAgICAgICAgY2VudHJvaWRzW2NvbHMgLSAxXS5lKDIpLFxuICAgICAgXSksXG4gICAgKTtcbiAgICBjcHMucHVzaChjZW50cm9pZHNbY29scyAtIDFdKTtcblxuICAgIHJldHVybiBjcHM7XG4gIH1cblxuICBwYy5zaGFkb3dzID0gZnVuY3Rpb24gKCkge1xuICAgIGZsYWdzLnNoYWRvd3MgPSB0cnVlO1xuICAgIHBjLmFscGhhT25CcnVzaGVkKDAuMSk7XG4gICAgcGMucmVuZGVyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gZHJhdyBkb3RzIHdpdGggcmFkaXVzIHIgb24gdGhlIGF4aXMgbGluZSB3aGVyZSBkYXRhIGludGVyc2VjdHNcbiAgcGMuYXhpc0RvdHMgPSBmdW5jdGlvbiAocikge1xuICAgIHZhciByID0gciB8fCAwLjE7XG4gICAgdmFyIGN0eCA9IHBjLmN0eC5tYXJrcztcbiAgICB2YXIgc3RhcnRBbmdsZSA9IDA7XG4gICAgdmFyIGVuZEFuZ2xlID0gMiAqIE1hdGguUEk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gZDMubWluKFsxIC8gTWF0aC5wb3coX18uZGF0YS5sZW5ndGgsIDEgLyAyKSwgMV0pO1xuICAgIF9fLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgX18uZGltZW5zaW9ucy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKHBvc2l0aW9uKHApLCB5c2NhbGVbcF0oZFtwXSksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gZHJhdyBzaW5nbGUgY3ViaWMgYmV6aWVyIGN1cnZlXG4gIGZ1bmN0aW9uIHNpbmdsZV9jdXJ2ZShkLCBjdHgpIHtcbiAgICB2YXIgY2VudHJvaWRzID0gY29tcHV0ZV9jZW50cm9pZHMoZCk7XG4gICAgdmFyIGNwcyA9IGNvbXB1dGVfY29udHJvbF9wb2ludHMoY2VudHJvaWRzKTtcblxuICAgIGN0eC5tb3ZlVG8oY3BzWzBdLmUoMSksIGNwc1swXS5lKDIpKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNwcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgaWYgKF9fLnNob3dDb250cm9sUG9pbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KGNwc1tpICsgal0uZSgxKSwgY3BzW2kgKyBqXS5lKDIpLCAyLCAyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgIGNwc1tpXS5lKDEpLFxuICAgICAgICBjcHNbaV0uZSgyKSxcbiAgICAgICAgY3BzW2kgKyAxXS5lKDEpLFxuICAgICAgICBjcHNbaSArIDFdLmUoMiksXG4gICAgICAgIGNwc1tpICsgMl0uZSgxKSxcbiAgICAgICAgY3BzW2kgKyAyXS5lKDIpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBkcmF3IHNpbmdsZSBwb2x5bGluZVxuICBmdW5jdGlvbiBjb2xvcl9wYXRoKGQsIGN0eCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCAmJiBfXy5idW5kbGluZ1N0cmVuZ3RoID4gMCkgfHwgX18uc21vb3RobmVzcyA+IDApIHtcbiAgICAgIHNpbmdsZV9jdXJ2ZShkLCBjdHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaW5nbGVfcGF0aChkLCBjdHgpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cblxuICAvLyBkcmF3IG1hbnkgcG9seWxpbmVzIG9mIHRoZSBzYW1lIGNvbG9yXG4gIGZ1bmN0aW9uIHBhdGhzKGRhdGEsIGN0eCkge1xuICAgIGN0eC5jbGVhclJlY3QoLTEsIC0xLCB3KCkgKyAyLCBoKCkgKyAyKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICBpZiAoKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCAmJiBfXy5idW5kbGluZ1N0cmVuZ3RoID4gMCkgfHwgX18uc21vb3RobmVzcyA+IDApIHtcbiAgICAgICAgc2luZ2xlX2N1cnZlKGQsIGN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaW5nbGVfcGF0aChkLCBjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxuXG4gIC8vIHJldHVybnMgdGhlIHktcG9zaXRpb24ganVzdCBiZXlvbmQgdGhlIHNlcGFyYXRpbmcgbnVsbCB2YWx1ZSBsaW5lXG4gIGZ1bmN0aW9uIGdldE51bGxQb3NpdGlvbigpIHtcbiAgICBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4gaCgpICsgMTtcbiAgICB9IGVsc2UgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAndG9wJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIkEgdmFsdWUgaXMgTlVMTCwgYnV0IG51bGxWYWx1ZVNlcGFyYXRvciBpcyBub3Qgc2V0OyBzZXQgaXQgdG8gJ2JvdHRvbScgb3IgJ3RvcCcuXCIsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gaCgpICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpbmdsZV9wYXRoKGQsIGN0eCkge1xuICAgIF9fLmRpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgIGN0eC5tb3ZlVG8ocG9zaXRpb24ocCksIHR5cGVvZiBkW3BdID09ICd1bmRlZmluZWQnID8gZ2V0TnVsbFBvc2l0aW9uKCkgOiB5c2NhbGVbcF0oZFtwXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbihwKSwgdHlwZW9mIGRbcF0gPT0gJ3VuZGVmaW5lZCcgPyBnZXROdWxsUG9zaXRpb24oKSA6IHlzY2FsZVtwXShkW3BdKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXRoX2JydXNoZWQoZCwgaSkge1xuICAgIGlmIChfXy5icnVzaGVkQ29sb3IgIT09IG51bGwpIHtcbiAgICAgIGN0eC5icnVzaGVkLnN0cm9rZVN0eWxlID0gZDMuZnVuY3RvcihfXy5icnVzaGVkQ29sb3IpKGQsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguYnJ1c2hlZC5zdHJva2VTdHlsZSA9IGQzLmZ1bmN0b3IoX18uY29sb3IpKGQsIGkpO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3JfcGF0aChkLCBjdHguYnJ1c2hlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXRoX2ZvcmVncm91bmQoZCwgaSkge1xuICAgIGN0eC5mb3JlZ3JvdW5kLnN0cm9rZVN0eWxlID0gZDMuZnVuY3RvcihfXy5jb2xvcikoZCwgaSk7XG4gICAgcmV0dXJuIGNvbG9yX3BhdGgoZCwgY3R4LmZvcmVncm91bmQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGF0aF9oaWdobGlnaHQoZCwgaSkge1xuICAgIGN0eC5oaWdobGlnaHQuc3Ryb2tlU3R5bGUgPSBkMy5mdW5jdG9yKF9fLmNvbG9yKShkLCBpKTtcbiAgICByZXR1cm4gY29sb3JfcGF0aChkLCBjdHguaGlnaGxpZ2h0KTtcbiAgfVxuICBwYy5jbGVhciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgIGN0eFtsYXllcl0uY2xlYXJSZWN0KDAsIDAsIHcoKSArIDIsIGgoKSArIDIpO1xuXG4gICAgLy8gVGhpcyB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZSBmb3JlZ3JvdW5kIGl0ZW1zIGFyZSB0cmFuc3BhcmVudFxuICAgIC8vIHdpdGhvdXQgdGhlIG5lZWQgZm9yIGNoYW5naW5nIHRoZSBvcGFjaXR5IHN0eWxlIG9mIHRoZSBmb3JlZ3JvdW5kIGNhbnZhc1xuICAgIC8vIGFzIHRoaXMgd291bGQgc3RvcCB0aGUgY3NzIHN0eWxpbmcgZnJvbSB3b3JraW5nXG4gICAgaWYgKGxheWVyID09PSAnYnJ1c2hlZCcgJiYgaXNCcnVzaGVkKCkpIHtcbiAgICAgIGN0eC5icnVzaGVkLmZpbGxTdHlsZSA9IHBjLnNlbGVjdGlvbi5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgY3R4LmJydXNoZWQuZ2xvYmFsQWxwaGEgPSAxIC0gX18uYWxwaGFPbkJydXNoZWQ7XG4gICAgICBjdHguYnJ1c2hlZC5maWxsUmVjdCgwLCAwLCB3KCkgKyAyLCBoKCkgKyAyKTtcbiAgICAgIGN0eC5icnVzaGVkLmdsb2JhbEFscGhhID0gX18uYWxwaGE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGQzLnJlYmluZChcbiAgICBwYyxcbiAgICBheGlzLFxuICAgICd0aWNrcycsXG4gICAgJ29yaWVudCcsXG4gICAgJ3RpY2tWYWx1ZXMnLFxuICAgICd0aWNrU3ViZGl2aWRlJyxcbiAgICAndGlja1NpemUnLFxuICAgICd0aWNrUGFkZGluZycsXG4gICAgJ3RpY2tGb3JtYXQnLFxuICApO1xuXG4gIGZ1bmN0aW9uIGZsaXBBeGlzQW5kVXBkYXRlUENQKGRpbWVuc2lvbikge1xuICAgIHZhciBnID0gcGMuc3ZnLnNlbGVjdEFsbCgnLmRpbWVuc2lvbicpO1xuXG4gICAgcGMuZmxpcChkaW1lbnNpb24pO1xuXG4gICAgZDMuc2VsZWN0KHRoaXMucGFyZW50RWxlbWVudCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKDExMDApLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZGltZW5zaW9uXSkpO1xuXG4gICAgcGMucmVuZGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiByb3RhdGVMYWJlbHMoKSB7XG4gICAgdmFyIGRlbHRhID0gZDMuZXZlbnQuZGVsdGFZO1xuICAgIGRlbHRhID0gZGVsdGEgPCAwID8gLTUgOiBkZWx0YTtcbiAgICBkZWx0YSA9IGRlbHRhID4gMCA/IDUgOiBkZWx0YTtcblxuICAgIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKz0gZGVsdGE7XG4gICAgcGMuc3ZnXG4gICAgICAuc2VsZWN0QWxsKCd0ZXh0LmxhYmVsJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyk7XG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpbWVuc2lvbkxhYmVscyhkKSB7XG4gICAgcmV0dXJuIGQgaW4gX18uZGltZW5zaW9uVGl0bGVzID8gX18uZGltZW5zaW9uVGl0bGVzW2RdIDogZDsgLy8gZGltZW5zaW9uIGRpc3BsYXkgbmFtZXNcbiAgfVxuXG4gIHBjLmNyZWF0ZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGcpIHBjLnJlbW92ZUF4ZXMoKTtcblxuICAgIC8vIEFkZCBhIGdyb3VwIGVsZW1lbnQgZm9yIGVhY2ggZGltZW5zaW9uLlxuICAgIGcgPSBwYy5zdmdcbiAgICAgIC5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKVxuICAgICAgLmRhdGEoX18uZGltZW5zaW9ucywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9KVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdkaW1lbnNpb24nKVxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4c2NhbGUoZCkgKyAnKSc7XG4gICAgICB9KTtcblxuICAgIC8vIEFkZCBhbiBheGlzIGFuZCB0aXRsZS5cbiAgICBnLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2F4aXMnKVxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwwKScpXG4gICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChheGlzLnNjYWxlKHlzY2FsZVtkXSkpO1xuICAgICAgfSlcbiAgICAgIC5hcHBlbmQoJ3N2Zzp0ZXh0JylcbiAgICAgIC5hdHRyKHtcbiAgICAgICAgJ3RleHQtYW5jaG9yJzogJ21pZGRsZScsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgwLC01KSByb3RhdGUoJyArIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKyAnKScsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIGNsYXNzOiAnbGFiZWwnLFxuICAgICAgfSlcbiAgICAgIC50ZXh0KGRpbWVuc2lvbkxhYmVscylcbiAgICAgIC5vbignZGJsY2xpY2snLCBmbGlwQXhpc0FuZFVwZGF0ZVBDUClcbiAgICAgIC5vbignd2hlZWwnLCByb3RhdGVMYWJlbHMpO1xuXG4gICAgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAndG9wJykge1xuICAgICAgcGMuc3ZnXG4gICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAuYXR0cigneDEnLCAwKVxuICAgICAgICAuYXR0cigneTEnLCAxICsgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy50b3ApXG4gICAgICAgIC5hdHRyKCd4MicsIHcoKSlcbiAgICAgICAgLmF0dHIoJ3kyJywgMSArIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcudG9wKVxuICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMSlcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsICcjNzc3JylcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAgIC5hdHRyKCdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycpO1xuICAgIH0gZWxzZSBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICdib3R0b20nKSB7XG4gICAgICBwYy5zdmdcbiAgICAgICAgLmFwcGVuZCgnbGluZScpXG4gICAgICAgIC5hdHRyKCd4MScsIDApXG4gICAgICAgIC5hdHRyKCd5MScsIGgoKSArIDEgLSBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLmJvdHRvbSlcbiAgICAgICAgLmF0dHIoJ3gyJywgdygpKVxuICAgICAgICAuYXR0cigneTInLCBoKCkgKyAxIC0gX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy5ib3R0b20pXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKVxuICAgICAgICAuYXR0cignc3Ryb2tlJywgJyM3NzcnKVxuICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcbiAgICAgICAgLmF0dHIoJ3NoYXBlLXJlbmRlcmluZycsICdjcmlzcEVkZ2VzJyk7XG4gICAgfVxuXG4gICAgZmxhZ3MuYXhlcyA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMucmVtb3ZlQXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBnLnJlbW92ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLnVwZGF0ZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdfZGF0YSA9IHBjLnN2Zy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKS5kYXRhKF9fLmRpbWVuc2lvbnMpO1xuXG4gICAgLy8gRW50ZXJcbiAgICBnX2RhdGFcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdzdmc6ZycpXG4gICAgICAuYXR0cignY2xhc3MnLCAnZGltZW5zaW9uJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcG9zaXRpb24ocCkgKyAnKSc7XG4gICAgICB9KVxuICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMClcbiAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdheGlzJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxuICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZF0pKTtcbiAgICAgIH0pXG4gICAgICAuYXBwZW5kKCdzdmc6dGV4dCcpXG4gICAgICAuYXR0cih7XG4gICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxuICAgICAgICB5OiAwLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwtNSkgcm90YXRlKCcgKyBfXy5kaW1lbnNpb25UaXRsZVJvdGF0aW9uICsgJyknLFxuICAgICAgICB4OiAwLFxuICAgICAgICBjbGFzczogJ2xhYmVsJyxcbiAgICAgIH0pXG4gICAgICAudGV4dChkaW1lbnNpb25MYWJlbHMpXG4gICAgICAub24oJ2RibGNsaWNrJywgZmxpcEF4aXNBbmRVcGRhdGVQQ1ApXG4gICAgICAub24oJ3doZWVsJywgcm90YXRlTGFiZWxzKTtcblxuICAgIC8vIFVwZGF0ZVxuICAgIGdfZGF0YS5hdHRyKCdvcGFjaXR5JywgMCk7XG4gICAgZ19kYXRhXG4gICAgICAuc2VsZWN0KCcuYXhpcycpXG4gICAgICAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oMTEwMClcbiAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XG4gICAgICB9KTtcbiAgICBnX2RhdGFcbiAgICAgIC5zZWxlY3QoJy5sYWJlbCcpXG4gICAgICAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oMTEwMClcbiAgICAgIC50ZXh0KGRpbWVuc2lvbkxhYmVscylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyk7XG5cbiAgICAvLyBFeGl0XG4gICAgZ19kYXRhLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIGcgPSBwYy5zdmcuc2VsZWN0QWxsKCcuZGltZW5zaW9uJyk7XG4gICAgZy50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbigxMTAwKVxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBwb3NpdGlvbihwKSArICcpJztcbiAgICAgIH0pXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcblxuICAgIHBjLnN2Z1xuICAgICAgLnNlbGVjdEFsbCgnLmF4aXMnKVxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDExMDApXG4gICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChheGlzLnNjYWxlKHlzY2FsZVtkXSkpO1xuICAgICAgfSk7XG5cbiAgICBpZiAoZmxhZ3MuYnJ1c2hhYmxlKSBwYy5icnVzaGFibGUoKTtcbiAgICBpZiAoZmxhZ3MucmVvcmRlcmFibGUpIHBjLnJlb3JkZXJhYmxlKCk7XG4gICAgaWYgKHBjLmJydXNoTW9kZSgpICE9PSAnTm9uZScpIHtcbiAgICAgIHZhciBtb2RlID0gcGMuYnJ1c2hNb2RlKCk7XG4gICAgICBwYy5icnVzaE1vZGUoJ05vbmUnKTtcbiAgICAgIHBjLmJydXNoTW9kZShtb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gSmFzb24gRGF2aWVzLCBodHRwOi8vYmwub2Nrcy5vcmcvMTM0MTI4MVxuICBwYy5yZW9yZGVyYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWcpIHBjLmNyZWF0ZUF4ZXMoKTtcblxuICAgIGcuc3R5bGUoJ2N1cnNvcicsICdtb3ZlJykuY2FsbChcbiAgICAgIGQzLmJlaGF2aW9yXG4gICAgICAgIC5kcmFnKClcbiAgICAgICAgLm9uKCdkcmFnc3RhcnQnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGRyYWdnaW5nW2RdID0gdGhpcy5fX29yaWdpbl9fID0geHNjYWxlKGQpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2RyYWcnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGRyYWdnaW5nW2RdID0gTWF0aC5taW4odygpLCBNYXRoLm1heCgwLCAodGhpcy5fX29yaWdpbl9fICs9IGQzLmV2ZW50LmR4KSkpO1xuICAgICAgICAgIF9fLmRpbWVuc2lvbnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uKGEpIC0gcG9zaXRpb24oYik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgeHNjYWxlLmRvbWFpbihfXy5kaW1lbnNpb25zKTtcbiAgICAgICAgICBwYy5yZW5kZXIoKTtcbiAgICAgICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcG9zaXRpb24oZCkgKyAnKSc7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgLy8gTGV0J3Mgc2VlIGlmIHRoZSBvcmRlciBoYXMgY2hhbmdlZCBhbmQgc2VuZCBvdXQgYW4gZXZlbnQgaWYgc28uXG4gICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgaiA9IF9fLmRpbWVuc2lvbnMuaW5kZXhPZihkKSxcbiAgICAgICAgICAgIGVsZW0gPSB0aGlzLFxuICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnRFbGVtZW50O1xuXG4gICAgICAgICAgd2hpbGUgKChlbGVtID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSAhPSBudWxsKSArK2k7XG4gICAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICAgIGV2ZW50cy5heGVzcmVvcmRlci5jYWxsKHBjLCBfXy5kaW1lbnNpb25zKTtcbiAgICAgICAgICAgIC8vIFdlIG5vdyBhbHNvIHdhbnQgdG8gcmVvcmRlciB0aGUgYWN0dWFsIGRvbSBlbGVtZW50cyB0aGF0IHJlcHJlc2VudFxuICAgICAgICAgICAgLy8gdGhlIGF4ZXMuIFRoYXQgaXMsIHRoZSBnLmRpbWVuc2lvbiBlbGVtZW50cy4gSWYgd2UgZG9uJ3QgZG8gdGhpcyxcbiAgICAgICAgICAgIC8vIHdlIGdldCBhIHdlaXJkIGFuZCBjb25mdXNpbmcgdHJhbnNpdGlvbiB3aGVuIHVwZGF0ZUF4ZXMgaXMgY2FsbGVkLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBkdWUgdG8gdGhlIGZhY3QgdGhhdCwgaW5pdGlhbGx5IHRoZSBudGggZy5kaW1lbnNpb24gZWxlbWVudFxuICAgICAgICAgICAgLy8gcmVwcmVzZW50cyB0aGUgbnRoIGF4aXMuIEhvd2V2ZXIsIGFmdGVyIGEgbWFudWFsIHJlb3JkZXJpbmcsXG4gICAgICAgICAgICAvLyB3aXRob3V0IHJlb3JkZXJpbmcgdGhlIGRvbSBlbGVtZW50cywgdGhlIG50aCBkb20gZWxlbWVudHMgbm8gbG9uZ2VyXG4gICAgICAgICAgICAvLyBuZWNlc3NhcmlseSByZXByZXNlbnRzIHRoZSBudGggYXhpcy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpIGlzIHRoZSBvcmlnaW5hbCBpbmRleCBvZiB0aGUgZG9tIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIGogaXMgdGhlIG5ldyBpbmRleCBvZiB0aGUgZG9tIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgICAgICAvLyBFbGVtZW50IG1vdmVkIGxlZnRcbiAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBwYXJlbnQuY2hpbGRyZW5baiAtIDFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEVsZW1lbnQgbW92ZWQgcmlnaHRcbiAgICAgICAgICAgICAgaWYgKGogKyAxIDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgcGFyZW50LmNoaWxkcmVuW2ogKyAxXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX19vcmlnaW5fXztcbiAgICAgICAgICBkZWxldGUgZHJhZ2dpbmdbZF07XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeHNjYWxlKGQpICsgJyknKTtcbiAgICAgICAgICBwYy5yZW5kZXIoKTtcbiAgICAgICAgfSksXG4gICAgKTtcbiAgICBmbGFncy5yZW9yZGVyYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUmVvcmRlciBkaW1lbnNpb25zLCBzdWNoIHRoYXQgdGhlIGhpZ2hlc3QgdmFsdWUgKHZpc3VhbGx5KSBpcyBvbiB0aGUgbGVmdCBhbmRcbiAgLy8gdGhlIGxvd2VzdCBvbiB0aGUgcmlnaHQuIFZpc3VhbCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGRhdGEgdmFsdWVzIGluXG4gIC8vIHRoZSBnaXZlbiByb3cuXG4gIHBjLnJlb3JkZXIgPSBmdW5jdGlvbiAocm93ZGF0YSkge1xuICAgIHZhciBkaW1zID0gX18uZGltZW5zaW9ucy5zbGljZSgwKTtcbiAgICBfXy5kaW1lbnNpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBwaXhlbERpZmZlcmVuY2UgPSB5c2NhbGVbYV0ocm93ZGF0YVthXSkgLSB5c2NhbGVbYl0ocm93ZGF0YVtiXSk7XG5cbiAgICAgIC8vIEFycmF5LnNvcnQgaXMgbm90IG5lY2Vzc2FyaWx5IHN0YWJsZSwgdGhpcyBtZWFucyB0aGF0IGlmIHBpeGVsRGlmZmVyZW5jZSBpcyB6ZXJvXG4gICAgICAvLyB0aGUgb3JkZXJpbmcgb2YgZGltZW5zaW9ucyBtaWdodCBjaGFuZ2UgdW5leHBlY3RlZGx5LiBUaGlzIGlzIHNvbHZlZCBieSBzb3J0aW5nIG9uXG4gICAgICAvLyB2YXJpYWJsZSBuYW1lIGluIHRoYXQgY2FzZS5cbiAgICAgIGlmIChwaXhlbERpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiKTtcbiAgICAgIH0gLy8gZWxzZVxuICAgICAgcmV0dXJuIHBpeGVsRGlmZmVyZW5jZTtcbiAgICB9KTtcblxuICAgIC8vIE5PVEU6IHRoaXMgaXMgcmVsYXRpdmVseSBjaGVhcCBnaXZlbiB0aGF0OlxuICAgIC8vIG51bWJlciBvZiBkaW1lbnNpb25zIDwgbnVtYmVyIG9mIGRhdGEgaXRlbXNcbiAgICAvLyBUaHVzIHdlIGNoZWNrIGVxdWFsaXR5IG9mIG9yZGVyIHRvIHByZXZlbnQgcmVyZW5kZXJpbmcgd2hlbiB0aGlzIGlzIHRoZSBjYXNlLlxuICAgIHZhciByZW9yZGVyZWQgPSBmYWxzZTtcbiAgICBkaW1zLnNvbWUoZnVuY3Rpb24gKHZhbCwgaW5kZXgpIHtcbiAgICAgIHJlb3JkZXJlZCA9IHZhbCAhPT0gX18uZGltZW5zaW9uc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVvcmRlcmVkO1xuICAgIH0pO1xuXG4gICAgaWYgKHJlb3JkZXJlZCkge1xuICAgICAgeHNjYWxlLmRvbWFpbihfXy5kaW1lbnNpb25zKTtcbiAgICAgIHZhciBoaWdobGlnaHRlZCA9IF9fLmhpZ2hsaWdodGVkLnNsaWNlKDApO1xuICAgICAgcGMudW5oaWdobGlnaHQoKTtcblxuICAgICAgZy50cmFuc2l0aW9uKClcbiAgICAgICAgLmR1cmF0aW9uKDE1MDApXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4c2NhbGUoZCkgKyAnKSc7XG4gICAgICAgIH0pO1xuICAgICAgcGMucmVuZGVyKCk7XG5cbiAgICAgIC8vIHBjLmhpZ2hsaWdodCgpIGRvZXMgbm90IGNoZWNrIHdoZXRoZXIgaGlnaGxpZ2h0ZWQgaXMgbGVuZ3RoIHplcm8sIHNvIHdlIGRvIHRoYXQgaGVyZS5cbiAgICAgIGlmIChoaWdobGlnaHRlZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcGMuaGlnaGxpZ2h0KGhpZ2hsaWdodGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gcGFpcnMgb2YgYWRqYWNlbnQgZGltZW5zaW9uc1xuICBwYy5hZGphY2VudF9wYWlycyA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICByZXQucHVzaChbYXJyW2ldLCBhcnJbaSArIDFdXSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgdmFyIGJydXNoID0ge1xuICAgIG1vZGVzOiB7XG4gICAgICBOb25lOiB7XG4gICAgICAgIGluc3RhbGw6IGZ1bmN0aW9uIChwYykge30sIC8vIE5vdGhpbmcgdG8gYmUgZG9uZS5cbiAgICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAocGMpIHt9LCAvLyBOb3RoaW5nIHRvIGJlIGRvbmUuXG4gICAgICAgIHNlbGVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LCAvLyBOb3RoaW5nIHRvIHJldHVyblxuICAgICAgICBicnVzaFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIG1vZGU6ICdOb25lJyxcbiAgICBwcmVkaWNhdGU6ICdBTkQnLFxuICAgIGN1cnJlbnRNb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2Rlc1t0aGlzLm1vZGVdO1xuICAgIH0sXG4gIH07XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCBmb3IgJ2xpdmUnIHVwZGF0ZXMgb2YgYnJ1c2hlcy4gVGhhdCBpcywgZHVyaW5nIHRoZVxuICAvLyBzcGVjaWZpY2F0aW9uIG9mIGEgYnJ1c2gsIHRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gdXBkYXRlIHRoZSB2aWV3LlxuICAvL1xuICAvLyBAcGFyYW0gbmV3U2VsZWN0aW9uIC0gVGhlIG5ldyBzZXQgb2YgZGF0YSBpdGVtcyB0aGF0IGlzIGN1cnJlbnRseSBjb250YWluZWRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGJ5IHRoZSBicnVzaGVzXG4gIGZ1bmN0aW9uIGJydXNoVXBkYXRlZChuZXdTZWxlY3Rpb24pIHtcbiAgICBfXy5icnVzaGVkID0gbmV3U2VsZWN0aW9uO1xuICAgIGV2ZW50cy5icnVzaC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcbiAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBicnVzaFByZWRpY2F0ZShwcmVkaWNhdGUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBicnVzaC5wcmVkaWNhdGU7XG4gICAgfVxuXG4gICAgcHJlZGljYXRlID0gU3RyaW5nKHByZWRpY2F0ZSkudG9VcHBlckNhc2UoKTtcbiAgICBpZiAocHJlZGljYXRlICE9PSAnQU5EJyAmJiBwcmVkaWNhdGUgIT09ICdPUicpIHtcbiAgICAgIHRocm93ICdJbnZhbGlkIHByZWRpY2F0ZSAnICsgcHJlZGljYXRlO1xuICAgIH1cblxuICAgIGJydXNoLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICBfXy5icnVzaGVkID0gYnJ1c2guY3VycmVudE1vZGUoKS5zZWxlY3RlZCgpO1xuICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICByZXR1cm4gcGM7XG4gIH1cblxuICBwYy5icnVzaE1vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhicnVzaC5tb2Rlcyk7XG4gIH07XG5cbiAgcGMuYnJ1c2hNb2RlID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJydXNoLm1vZGU7XG4gICAgfVxuXG4gICAgaWYgKHBjLmJydXNoTW9kZXMoKS5pbmRleE9mKG1vZGUpID09PSAtMSkge1xuICAgICAgdGhyb3cgJ3BjLmJydXNobW9kZTogVW5zdXBwb3J0ZWQgYnJ1c2ggbW9kZTogJyArIG1vZGU7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgdHJpZ2dlciB1bm5lY2Vzc2FyeSBldmVudHMgYnkgY2hlY2tpbmcgaWYgdGhlIG1vZGVcbiAgICAvLyBhY3R1YWxseSBjaGFuZ2VzLlxuICAgIGlmIChtb2RlICE9PSBicnVzaC5tb2RlKSB7XG4gICAgICAvLyBXaGVuIGNoYW5naW5nIGJydXNoIG1vZGVzLCB0aGUgZmlyc3QgdGhpbmcgd2UgbmVlZCB0byBkbyBpcyBjbGVhcmluZyBhbnlcbiAgICAgIC8vIGJydXNoZXMgZnJvbSB0aGUgY3VycmVudCBtb2RlLCBpZiBhbnkuXG4gICAgICBpZiAoYnJ1c2gubW9kZSAhPT0gJ05vbmUnKSB7XG4gICAgICAgIHBjLmJydXNoUmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gTmV4dCwgd2UgbmVlZCB0byAndW5pbnN0YWxsJyB0aGUgY3VycmVudCBicnVzaE1vZGUuXG4gICAgICBicnVzaC5tb2Rlc1ticnVzaC5tb2RlXS51bmluc3RhbGwocGMpO1xuICAgICAgLy8gRmluYWxseSwgd2UgY2FuIGluc3RhbGwgdGhlIHJlcXVlc3RlZCBvbmUuXG4gICAgICBicnVzaC5tb2RlID0gbW9kZTtcbiAgICAgIGJydXNoLm1vZGVzW2JydXNoLm1vZGVdLmluc3RhbGwoKTtcbiAgICAgIGlmIChtb2RlID09PSAnTm9uZScpIHtcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUHJlZGljYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGMuYnJ1c2hQcmVkaWNhdGUgPSBicnVzaFByZWRpY2F0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGM7XG4gIH07XG5cbiAgLy8gYnJ1c2ggbW9kZTogMUQtQXhlc1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJydXNoZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGlzX2JydXNoZWQocCkge1xuICAgICAgcmV0dXJuICFicnVzaGVzW3BdLmVtcHR5KCk7XG4gICAgfVxuXG4gICAgLy8gZGF0YSB3aXRoaW4gZXh0ZW50c1xuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICAgICAgdmFyIGFjdGl2ZXMgPSBfXy5kaW1lbnNpb25zLmZpbHRlcihpc19icnVzaGVkKSxcbiAgICAgICAgZXh0ZW50cyA9IGFjdGl2ZXMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIGJydXNoZXNbcF0uZXh0ZW50KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJldHVybiB0aGUgZnVsbCBkYXRhIHNldCB3aGVuIHRoZXJlIGFyZSBubyBheGVzIGJydXNoZWQuXG4gICAgICAvLyBBY3R1YWxseSwgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLCBieSBkZWZpbml0aW9uLCBubyBpdGVtcyBhcmVcbiAgICAgIC8vIHNlbGVjdGVkLiBTbywgbGV0J3MgYXZvaWQgdGhlIGZpbHRlcmluZyBhbmQganVzdCByZXR1cm4gZmFsc2UuXG4gICAgICAvL2lmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBSZXNvbHZlcyBicm9rZW4gZXhhbXBsZXMgZm9yIG5vdy4gVGhleSBleHBlY3QgdG8gZ2V0IHRoZSBmdWxsIGRhdGFzZXQgYmFjayBmcm9tIGVtcHR5IGJydXNoZXNcbiAgICAgIGlmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIF9fLmRhdGE7XG5cbiAgICAgIC8vIHRlc3QgaWYgd2l0aGluIHJhbmdlXG4gICAgICB2YXIgd2l0aGluID0ge1xuICAgICAgICBkYXRlOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB5c2NhbGVbcF0ucmFuZ2VQb2ludHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9yZGluYWxcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSBkW3BdICYmIGRbcF0gPD0gZXh0ZW50c1tkaW1lbnNpb25dWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB5c2NhbGVbcF0ucmFuZ2VQb2ludHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9yZGluYWxcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSBkW3BdICYmIGRbcF0gPD0gZXh0ZW50c1tkaW1lbnNpb25dWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RyaW5nOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX18uZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcbiAgICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuZXZlcnkoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSAnT1InOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuc29tZShmdW5jdGlvbiAocCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3aXRoaW5bX18udHlwZXNbcF1dKGQsIHAsIGRpbWVuc2lvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gYnJ1c2ggcHJlZGljYXRlICcgKyBfXy5icnVzaFByZWRpY2F0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hFeHRlbnRzKGV4dGVudHMpIHtcbiAgICAgIGlmICh0eXBlb2YgZXh0ZW50cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGV4dGVudHMgPSB7fTtcbiAgICAgICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgdmFyIGJydXNoID0gYnJ1c2hlc1tkXTtcbiAgICAgICAgICBpZiAoYnJ1c2ggIT09IHVuZGVmaW5lZCAmJiAhYnJ1c2guZW1wdHkoKSkge1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IGJydXNoLmV4dGVudCgpO1xuICAgICAgICAgICAgZXh0ZW50LnNvcnQoZDMuYXNjZW5kaW5nKTtcbiAgICAgICAgICAgIGV4dGVudHNbZF0gPSBleHRlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGV4dGVudHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2ZpcnN0IGdldCBhbGwgdGhlIGJydXNoIHNlbGVjdGlvbnNcbiAgICAgICAgdmFyIGJydXNoU2VsZWN0aW9ucyA9IHt9O1xuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGJydXNoU2VsZWN0aW9uc1tkXSA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbG9vcCBvdmVyIGVhY2ggZGltZW5zaW9uIGFuZCB1cGRhdGUgYXBwcm9wcmlhdGVseSAoaWYgaXQgd2FzIHBhc3NlZCBpbiB0aHJvdWdoIGV4dGVudHMpXG4gICAgICAgIF9fLmRpbWVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGlmIChleHRlbnRzW2RdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYnJ1c2ggPSBicnVzaGVzW2RdO1xuICAgICAgICAgIGlmIChicnVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL3VwZGF0ZSB0aGUgZXh0ZW50XG4gICAgICAgICAgICBicnVzaC5leHRlbnQoZXh0ZW50c1tkXSk7XG5cbiAgICAgICAgICAgIC8vcmVkcmF3IHRoZSBicnVzaFxuICAgICAgICAgICAgYnJ1c2goYnJ1c2hTZWxlY3Rpb25zW2RdKTtcblxuICAgICAgICAgICAgLy9maXJlIHNvbWUgZXZlbnRzXG4gICAgICAgICAgICBicnVzaC5ldmVudChicnVzaFNlbGVjdGlvbnNbZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9yZWRyYXcgdGhlIGNoYXJ0XG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYnJ1c2hGb3IoYXhpcykge1xuICAgICAgdmFyIGJydXNoID0gZDMuc3ZnLmJydXNoKCk7XG5cbiAgICAgIGJydXNoXG4gICAgICAgIC55KHlzY2FsZVtheGlzXSlcbiAgICAgICAgLm9uKCdicnVzaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZDMuZXZlbnQuc291cmNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ2JydXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGJydXNoVXBkYXRlZChzZWxlY3RlZCgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdicnVzaGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBldmVudHMuYnJ1c2hlbmQuY2FsbChwYywgX18uYnJ1c2hlZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICBicnVzaGVzW2F4aXNdID0gYnJ1c2g7XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJydXNoUmVzZXQoZGltZW5zaW9uKSB7XG4gICAgICBfXy5icnVzaGVkID0gZmFsc2U7XG4gICAgICBpZiAoZykge1xuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGJydXNoZXNbZF0uY2xlYXIoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgaWYgKCFnKSBwYy5jcmVhdGVBeGVzKCk7XG5cbiAgICAgIC8vIEFkZCBhbmQgc3RvcmUgYSBicnVzaCBmb3IgZWFjaCBheGlzLlxuICAgICAgZy5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JydXNoJylcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChicnVzaEZvcihkKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RBbGwoJ3JlY3QnKVxuICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCBudWxsKVxuICAgICAgICAuYXR0cigneCcsIC0xNSlcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgMzApO1xuXG4gICAgICBwYy5icnVzaEV4dGVudHMgPSBicnVzaEV4dGVudHM7XG4gICAgICBwYy5icnVzaFJlc2V0ID0gYnJ1c2hSZXNldDtcbiAgICAgIHJldHVybiBwYztcbiAgICB9XG5cbiAgICBicnVzaC5tb2Rlc1snMUQtYXhlcyddID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCxcbiAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykucmVtb3ZlKCk7XG4gICAgICAgIGJydXNoZXMgPSB7fTtcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoRXh0ZW50cztcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgYnJ1c2hTdGF0ZTogYnJ1c2hFeHRlbnRzLFxuICAgIH07XG4gIH0pKCk7XG4gIC8vIGJydXNoIG1vZGU6IDJELXN0cnVtc1xuICAvLyBibC5vY2tzLm9yZy9zeW50YWdtYXRpYy81NDQxMDIyXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RydW1zID0ge30sXG4gICAgICBzdHJ1bVJlY3Q7XG5cbiAgICBmdW5jdGlvbiBkcmF3U3RydW0oc3RydW0sIGFjdGl2ZVBvaW50KSB7XG4gICAgICB2YXIgc3ZnID0gcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI3N0cnVtcycpLFxuICAgICAgICBpZCA9IHN0cnVtLmRpbXMuaSxcbiAgICAgICAgcG9pbnRzID0gW3N0cnVtLnAxLCBzdHJ1bS5wMl0sXG4gICAgICAgIGxpbmUgPSBzdmcuc2VsZWN0QWxsKCdsaW5lI3N0cnVtLScgKyBpZCkuZGF0YShbc3RydW1dKSxcbiAgICAgICAgY2lyY2xlcyA9IHN2Zy5zZWxlY3RBbGwoJ2NpcmNsZSNzdHJ1bS0nICsgaWQpLmRhdGEocG9pbnRzKSxcbiAgICAgICAgZHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKTtcblxuICAgICAgbGluZVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3N0cnVtLScgKyBpZClcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3N0cnVtJyk7XG5cbiAgICAgIGxpbmVcbiAgICAgICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5wMVswXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5wMVsxXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5wMlswXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3kyJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5wMlsxXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKTtcblxuICAgICAgZHJhZ1xuICAgICAgICAub24oJ2RyYWcnLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHZhciBldiA9IGQzLmV2ZW50O1xuICAgICAgICAgIGkgPSBpICsgMTtcbiAgICAgICAgICBzdHJ1bVsncCcgKyBpXVswXSA9IE1hdGgubWluKE1hdGgubWF4KHN0cnVtLm1pblggKyAxLCBldi54KSwgc3RydW0ubWF4WCk7XG4gICAgICAgICAgc3RydW1bJ3AnICsgaV1bMV0gPSBNYXRoLm1pbihNYXRoLm1heChzdHJ1bS5taW5ZLCBldi55KSwgc3RydW0ubWF4WSk7XG4gICAgICAgICAgZHJhd1N0cnVtKHN0cnVtLCBpIC0gMSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJhZ2VuZCcsIG9uRHJhZ0VuZCgpKTtcblxuICAgICAgY2lyY2xlc1xuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxuICAgICAgICAuYXR0cignaWQnLCAnc3RydW0tJyArIGlkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnc3RydW0nKTtcblxuICAgICAgY2lyY2xlc1xuICAgICAgICAuYXR0cignY3gnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkWzBdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkWzFdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigncicsIDUpXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZVBvaW50ICE9PSB1bmRlZmluZWQgJiYgaSA9PT0gYWN0aXZlUG9pbnQgPyAwLjggOiAwO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwLjgpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnb3BhY2l0eScsIDApO1xuICAgICAgICB9KVxuICAgICAgICAuY2FsbChkcmFnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaW1lbnNpb25zRm9yUG9pbnQocCkge1xuICAgICAgdmFyIGRpbXMgPSB7IGk6IC0xLCBsZWZ0OiB1bmRlZmluZWQsIHJpZ2h0OiB1bmRlZmluZWQgfTtcbiAgICAgIF9fLmRpbWVuc2lvbnMuc29tZShmdW5jdGlvbiAoZGltLCBpKSB7XG4gICAgICAgIGlmICh4c2NhbGUoZGltKSA8IHBbMF0pIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IF9fLmRpbWVuc2lvbnNbaSArIDFdO1xuICAgICAgICAgIGRpbXMuaSA9IGk7XG4gICAgICAgICAgZGltcy5sZWZ0ID0gZGltO1xuICAgICAgICAgIGRpbXMucmlnaHQgPSBuZXh0O1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZGltcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRXZlbnQgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgZmlyc3QgYXhpcy5cbiAgICAgICAgZGltcy5pID0gMDtcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1swXTtcbiAgICAgICAgZGltcy5yaWdodCA9IF9fLmRpbWVuc2lvbnNbMV07XG4gICAgICB9IGVsc2UgaWYgKGRpbXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBFdmVudCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgbGFzdCBheGlzXG4gICAgICAgIGRpbXMuaSA9IF9fLmRpbWVuc2lvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgZGltcy5yaWdodCA9IGRpbXMubGVmdDtcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1tfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGltcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHtcbiAgICAgIC8vIEZpcnN0IHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGJldHdlZW4gd2hpY2ggdHdvIGF4ZXMgdGhlIHN0dXJtIHdhcyBzdGFydGVkLlxuICAgICAgLy8gVGhpcyB3aWxsIGRldGVybWluZSB0aGUgZnJlZWRvbSBvZiBtb3ZlbWVudCwgYmVjYXVzZSBhIHN0cnVtIGNhblxuICAgICAgLy8gbG9naWNhbGx5IG9ubHkgaGFwcGVuIGJldHdlZW4gdHdvIGF4ZXMsIHNvIG5vIG1vdmVtZW50IG91dHNpZGUgdGhlc2UgYXhlc1xuICAgICAgLy8gc2hvdWxkIGJlIGFsbG93ZWQuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9IGQzLm1vdXNlKHN0cnVtUmVjdFswXVswXSksXG4gICAgICAgICAgZGltcyxcbiAgICAgICAgICBzdHJ1bTtcblxuICAgICAgICBwWzBdID0gcFswXSAtIF9fLm1hcmdpbi5sZWZ0O1xuICAgICAgICBwWzFdID0gcFsxXSAtIF9fLm1hcmdpbi50b3A7XG5cbiAgICAgICAgKGRpbXMgPSBkaW1lbnNpb25zRm9yUG9pbnQocCkpLFxuICAgICAgICAgIChzdHJ1bSA9IHtcbiAgICAgICAgICAgIHAxOiBwLFxuICAgICAgICAgICAgZGltczogZGltcyxcbiAgICAgICAgICAgIG1pblg6IHhzY2FsZShkaW1zLmxlZnQpLFxuICAgICAgICAgICAgbWF4WDogeHNjYWxlKGRpbXMucmlnaHQpLFxuICAgICAgICAgICAgbWluWTogMCxcbiAgICAgICAgICAgIG1heFk6IGgoKSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICBzdHJ1bXNbZGltcy5pXSA9IHN0cnVtO1xuICAgICAgICBzdHJ1bXMuYWN0aXZlID0gZGltcy5pO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuICAgICAgICBzdHJ1bS5wMVswXSA9IE1hdGgubWluKE1hdGgubWF4KHN0cnVtLm1pblgsIHBbMF0pLCBzdHJ1bS5tYXhYKTtcbiAgICAgICAgc3RydW0ucDIgPSBzdHJ1bS5wMS5zbGljZSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWcoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXYgPSBkMy5ldmVudCxcbiAgICAgICAgICBzdHJ1bSA9IHN0cnVtc1tzdHJ1bXMuYWN0aXZlXTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBib3VuZHNcbiAgICAgICAgc3RydW0ucDJbMF0gPSBNYXRoLm1pbihNYXRoLm1heChzdHJ1bS5taW5YICsgMSwgZXYueCAtIF9fLm1hcmdpbi5sZWZ0KSwgc3RydW0ubWF4WCk7XG4gICAgICAgIHN0cnVtLnAyWzFdID0gTWF0aC5taW4oTWF0aC5tYXgoc3RydW0ubWluWSwgZXYueSAtIF9fLm1hcmdpbi50b3ApLCBzdHJ1bS5tYXhZKTtcbiAgICAgICAgZHJhd1N0cnVtKHN0cnVtLCAxKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGFpbm1lbnRUZXN0KHN0cnVtLCB3aWR0aCkge1xuICAgICAgdmFyIHAxID0gW3N0cnVtLnAxWzBdIC0gc3RydW0ubWluWCwgc3RydW0ucDFbMV0gLSBzdHJ1bS5taW5YXSxcbiAgICAgICAgcDIgPSBbc3RydW0ucDJbMF0gLSBzdHJ1bS5taW5YLCBzdHJ1bS5wMlsxXSAtIHN0cnVtLm1pblhdLFxuICAgICAgICBtMSA9IDEgLSB3aWR0aCAvIHAxWzBdLFxuICAgICAgICBiMSA9IHAxWzFdICogKDEgLSBtMSksXG4gICAgICAgIG0yID0gMSAtIHdpZHRoIC8gcDJbMF0sXG4gICAgICAgIGIyID0gcDJbMV0gKiAoMSAtIG0yKTtcblxuICAgICAgLy8gdGVzdCBpZiBwb2ludCBmYWxscyBiZXR3ZWVuIGxpbmVzXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIHggPSBwWzBdLFxuICAgICAgICAgIHkgPSBwWzFdLFxuICAgICAgICAgIHkxID0gbTEgKiB4ICsgYjEsXG4gICAgICAgICAgeTIgPSBtMiAqIHggKyBiMjtcblxuICAgICAgICBpZiAoeSA+IE1hdGgubWluKHkxLCB5MikgJiYgeSA8IE1hdGgubWF4KHkxLCB5MikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RydW1zKSxcbiAgICAgICAgYnJ1c2hlZCA9IF9fLmRhdGE7XG5cbiAgICAgIC8vIEdldCB0aGUgaWRzIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHN0cnVtcy5cbiAgICAgIGlkcyA9IGlkcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBjcm9zc2VzU3RydW0oZCwgaWQpIHtcbiAgICAgICAgdmFyIHN0cnVtID0gc3RydW1zW2lkXSxcbiAgICAgICAgICB0ZXN0ID0gY29udGFpbm1lbnRUZXN0KHN0cnVtLCBzdHJ1bXMud2lkdGgoaWQpKSxcbiAgICAgICAgICBkMSA9IHN0cnVtLmRpbXMubGVmdCxcbiAgICAgICAgICBkMiA9IHN0cnVtLmRpbXMucmlnaHQsXG4gICAgICAgICAgeTEgPSB5c2NhbGVbZDFdLFxuICAgICAgICAgIHkyID0geXNjYWxlW2QyXSxcbiAgICAgICAgICBwb2ludCA9IFt5MShkW2QxXSkgLSBzdHJ1bS5taW5YLCB5MihkW2QyXSkgLSBzdHJ1bS5taW5YXTtcbiAgICAgICAgcmV0dXJuIHRlc3QocG9pbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYnJ1c2hlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJydXNoZWQuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHN3aXRjaCAoYnJ1c2gucHJlZGljYXRlKSB7XG4gICAgICAgICAgY2FzZSAnQU5EJzpcbiAgICAgICAgICAgIHJldHVybiBpZHMuZXZlcnkoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcm9zc2VzU3RydW0oZCwgaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSAnT1InOlxuICAgICAgICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3Jvc3Nlc1N0cnVtKGQsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnVW5rbm93biBicnVzaCBwcmVkaWNhdGUgJyArIF9fLmJydXNoUHJlZGljYXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVTdHJ1bSgpIHtcbiAgICAgIHZhciBzdHJ1bSA9IHN0cnVtc1tzdHJ1bXMuYWN0aXZlXSxcbiAgICAgICAgc3ZnID0gcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI3N0cnVtcycpO1xuXG4gICAgICBkZWxldGUgc3RydW1zW3N0cnVtcy5hY3RpdmVdO1xuICAgICAgc3RydW1zLmFjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ2xpbmUjc3RydW0tJyArIHN0cnVtLmRpbXMuaSkucmVtb3ZlKCk7XG4gICAgICBzdmcuc2VsZWN0QWxsKCdjaXJjbGUjc3RydW0tJyArIHN0cnVtLmRpbXMuaSkucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnRW5kKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJydXNoZWQgPSBfXy5kYXRhLFxuICAgICAgICAgIHN0cnVtID0gc3RydW1zW3N0cnVtcy5hY3RpdmVdO1xuXG4gICAgICAgIC8vIE9rYXksIHNvbWV3aGF0IHVuZXhwZWN0ZWQsIGJ1dCBub3QgdG90YWxseSB1bnN1cnByaXNpbmcsIGEgbW91c2NsaWNrIGlzXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgYSBkcmFnIHdpdGhvdXQgbW92ZS4gU28gd2UgaGF2ZSB0byBkZWFsIHdpdGggdGhhdCBjYXNlXG4gICAgICAgIGlmIChzdHJ1bSAmJiBzdHJ1bS5wMVswXSA9PT0gc3RydW0ucDJbMF0gJiYgc3RydW0ucDFbMV0gPT09IHN0cnVtLnAyWzFdKSB7XG4gICAgICAgICAgcmVtb3ZlU3RydW0oc3RydW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJydXNoZWQgPSBzZWxlY3RlZChzdHJ1bXMpO1xuICAgICAgICBzdHJ1bXMuYWN0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgICBfXy5icnVzaGVkID0gYnJ1c2hlZDtcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgICAgICBldmVudHMuYnJ1c2hlbmQuY2FsbChwYywgX18uYnJ1c2hlZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoUmVzZXQoc3RydW1zKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RydW1zKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHN0cnVtcy5hY3RpdmUgPSBkO1xuICAgICAgICAgIHJlbW92ZVN0cnVtKHN0cnVtcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbkRyYWdFbmQoc3RydW1zKSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgdmFyIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCk7XG5cbiAgICAgIC8vIE1hcCBvZiBjdXJyZW50IHN0cnVtcy4gU3RydW1zIGFyZSBzdG9yZWQgcGVyIHNlZ21lbnQgb2YgdGhlIFBDLiBBIHNlZ21lbnQsXG4gICAgICAvLyBiZWluZyB0aGUgYXJlYSBiZXR3ZWVuIHR3byBheGVzLiBUaGUgbGVmdCBtb3N0IGFyZWEgaXMgaW5kZXhlZCBhdCAwLlxuICAgICAgc3RydW1zLmFjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIC8vIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBQQyBzZWdtZW50IHdoZXJlIGN1cnJlbnRseSBhIHN0cnVtIGlzIGJlaW5nXG4gICAgICAvLyBwbGFjZWQuIE5PVEU6IGV2ZW4gdGhvdWdoIHRoZXkgYXJlIGV2ZW5seSBzcGFjZWQgaW4gb3VyIGN1cnJlbnRcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uLCB3ZSBrZWVwIGZvciB3aGVuIG5vbi1ldmVuIHNwYWNlZCBzZWdtZW50cyBhcmUgc3VwcG9ydGVkIGFzXG4gICAgICAvLyB3ZWxsLlxuICAgICAgc3RydW1zLndpZHRoID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBzdHJ1bSA9IHN0cnVtc1tpZF07XG5cbiAgICAgICAgaWYgKHN0cnVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cnVtLm1heFggLSBzdHJ1bS5taW5YO1xuICAgICAgfTtcblxuICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLnN0cnVtcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0cnVtcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBmaXJzdCBkaW1lbnNpb24gaXMgZGlyZWN0bHkgbGVmdCBvZiB0aGUgc2Vjb25kIGRpbWVuc2lvbi5cbiAgICAgICAgZnVuY3Rpb24gY29uc2VjdXRpdmUoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBfXy5kaW1lbnNpb25zLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZCA9PT0gZmlyc3QgPyBpICsgaSA8IGxlbmd0aCAmJiBfXy5kaW1lbnNpb25zW2kgKyAxXSA9PT0gc2Vjb25kIDogZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIHNvbWUgc3RydW1zLCB3aGljaCBtaWdodCBuZWVkIHRvIGJlIHJlbW92ZWQuXG4gICAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBkaW1zID0gc3RydW1zW2RdLmRpbXM7XG4gICAgICAgICAgICBzdHJ1bXMuYWN0aXZlID0gZDtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0d28gZGltZW5zaW9ucyBvZiB0aGUgY3VycmVudCBzdHJ1bSBhcmUgbm90IG5leHQgdG8gZWFjaCBvdGhlclxuICAgICAgICAgICAgLy8gYW55IG1vcmUsIHRoYW4gd2UnbGwgbmVlZCB0byByZW1vdmUgdGhlIHN0cnVtLiBPdGhlcndpc2Ugd2Uga2VlcCBpdC5cbiAgICAgICAgICAgIGlmICghY29uc2VjdXRpdmUoZGltcy5sZWZ0LCBkaW1zLnJpZ2h0KSkge1xuICAgICAgICAgICAgICByZW1vdmVTdHJ1bShzdHJ1bXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9uRHJhZ0VuZChzdHJ1bXMpKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGQgYSBuZXcgc3ZnIGdyb3VwIGluIHdoaWNoIHdlIGRyYXcgdGhlIHN0cnVtcy5cbiAgICAgIHBjLnNlbGVjdGlvblxuICAgICAgICAuc2VsZWN0KCdzdmcnKVxuICAgICAgICAuYXBwZW5kKCdnJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3N0cnVtcycpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfXy5tYXJnaW4ubGVmdCArICcsJyArIF9fLm1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAvLyBJbnN0YWxsIHRoZSByZXF1aXJlZCBicnVzaFJlc2V0IGZ1bmN0aW9uXG4gICAgICBwYy5icnVzaFJlc2V0ID0gYnJ1c2hSZXNldChzdHJ1bXMpO1xuXG4gICAgICBkcmFnXG4gICAgICAgIC5vbignZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQoc3RydW1zKSlcbiAgICAgICAgLm9uKCdkcmFnJywgb25EcmFnKHN0cnVtcykpXG4gICAgICAgIC5vbignZHJhZ2VuZCcsIG9uRHJhZ0VuZChzdHJ1bXMpKTtcblxuICAgICAgLy8gTk9URTogVGhlIHN0eWxpbmcgbmVlZHMgdG8gYmUgZG9uZSBoZXJlIGFuZCBub3QgaW4gdGhlIGNzcy4gVGhpcyBpcyBiZWNhdXNlXG4gICAgICAvLyAgICAgICBmb3IgMUQgYnJ1c2hpbmcsIHRoZSBjYW52YXMgbGF5ZXJzIHNob3VsZCBub3QgbGlzdGVuIHRvXG4gICAgICAvLyAgICAgICBwb2ludGVyLWV2ZW50cy5cbiAgICAgIHN0cnVtUmVjdCA9IHBjLnNlbGVjdGlvblxuICAgICAgICAuc2VsZWN0KCdzdmcnKVxuICAgICAgICAuaW5zZXJ0KCdyZWN0JywgJ2cjc3RydW1zJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3N0cnVtLWV2ZW50cycpXG4gICAgICAgIC5hdHRyKCd4JywgX18ubWFyZ2luLmxlZnQpXG4gICAgICAgIC5hdHRyKCd5JywgX18ubWFyZ2luLnRvcClcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgdygpKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaCgpICsgMilcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMClcbiAgICAgICAgLmNhbGwoZHJhZyk7XG4gICAgfVxuXG4gICAgYnJ1c2gubW9kZXNbJzJELXN0cnVtcyddID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCxcbiAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ2cjc3RydW1zJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgncmVjdCNzdHJ1bS1ldmVudHMnKS5yZW1vdmUoKTtcbiAgICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLnN0cnVtcycsIHVuZGVmaW5lZCk7XG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaFJlc2V0O1xuXG4gICAgICAgIHN0cnVtUmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBicnVzaFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzdHJ1bXM7XG4gICAgICB9LFxuICAgIH07XG4gIH0pKCk7XG5cbiAgLy8gYnJ1c2ggbW9kZTogMUQtQXhlcyB3aXRoIG11bHRpcGxlIGV4dGVudHNcbiAgLy8gcmVxdWlyZXMgZDMuc3ZnLm11bHRpYnJ1c2hcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgZDMuc3ZnLm11bHRpYnJ1c2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGJydXNoZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGlzX2JydXNoZWQocCkge1xuICAgICAgcmV0dXJuICFicnVzaGVzW3BdLmVtcHR5KCk7XG4gICAgfVxuXG4gICAgLy8gZGF0YSB3aXRoaW4gZXh0ZW50c1xuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICAgICAgdmFyIGFjdGl2ZXMgPSBfXy5kaW1lbnNpb25zLmZpbHRlcihpc19icnVzaGVkKSxcbiAgICAgICAgZXh0ZW50cyA9IGFjdGl2ZXMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIGJydXNoZXNbcF0uZXh0ZW50KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJldHVybiB0aGUgZnVsbCBkYXRhIHNldCB3aGVuIHRoZXJlIGFyZSBubyBheGVzIGJydXNoZWQuXG4gICAgICAvLyBBY3R1YWxseSwgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLCBieSBkZWZpbml0aW9uLCBubyBpdGVtcyBhcmVcbiAgICAgIC8vIHNlbGVjdGVkLiBTbywgbGV0J3MgYXZvaWQgdGhlIGZpbHRlcmluZyBhbmQganVzdCByZXR1cm4gZmFsc2UuXG4gICAgICAvL2lmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBSZXNvbHZlcyBicm9rZW4gZXhhbXBsZXMgZm9yIG5vdy4gVGhleSBleHBlY3QgdG8gZ2V0IHRoZSBmdWxsIGRhdGFzZXQgYmFjayBmcm9tIGVtcHR5IGJydXNoZXNcbiAgICAgIGlmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIF9fLmRhdGE7XG5cbiAgICAgIC8vIHRlc3QgaWYgd2l0aGluIHJhbmdlXG4gICAgICB2YXIgd2l0aGluID0ge1xuICAgICAgICBkYXRlOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uLCBiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB5c2NhbGVbcF0ucmFuZ2VQb2ludHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9yZGluYWxcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJiB5c2NhbGVbcF0oZFtwXSkgPD0gYlsxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGJbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBudW1iZXI6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24sIGIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHlzY2FsZVtwXS5yYW5nZVBvaW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gaWYgaXQgaXMgb3JkaW5hbFxuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBiWzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYlswXSA8PSBkW3BdICYmIGRbcF0gPD0gYlsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbiwgYikge1xuICAgICAgICAgIHJldHVybiBiWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJiB5c2NhbGVbcF0oZFtwXSkgPD0gYlsxXTtcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfXy5kYXRhLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICBzd2l0Y2ggKGJydXNoLnByZWRpY2F0ZSkge1xuICAgICAgICAgIGNhc2UgJ0FORCc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlcy5ldmVyeShmdW5jdGlvbiAocCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHRlbnRzW2RpbWVuc2lvbl0uc29tZShmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoaW5bX18udHlwZXNbcF1dKGQsIHAsIGRpbWVuc2lvbiwgYik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSAnT1InOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuc29tZShmdW5jdGlvbiAocCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHRlbnRzW2RpbWVuc2lvbl0uc29tZShmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoaW5bX18udHlwZXNbcF1dKGQsIHAsIGRpbWVuc2lvbiwgYik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoRXh0ZW50cygpIHtcbiAgICAgIHZhciBleHRlbnRzID0ge307XG4gICAgICBfXy5kaW1lbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGJydXNoID0gYnJ1c2hlc1tkXTtcbiAgICAgICAgaWYgKGJydXNoICE9PSB1bmRlZmluZWQgJiYgIWJydXNoLmVtcHR5KCkpIHtcbiAgICAgICAgICB2YXIgZXh0ZW50ID0gYnJ1c2guZXh0ZW50KCk7XG4gICAgICAgICAgZXh0ZW50c1tkXSA9IGV4dGVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZXh0ZW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaEZvcihheGlzKSB7XG4gICAgICB2YXIgYnJ1c2ggPSBkMy5zdmcubXVsdGlicnVzaCgpO1xuXG4gICAgICBicnVzaFxuICAgICAgICAueSh5c2NhbGVbYXhpc10pXG4gICAgICAgIC5vbignYnJ1c2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGQzLmV2ZW50LnNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdicnVzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBicnVzaFVwZGF0ZWQoc2VsZWN0ZWQoKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignYnJ1c2hlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gZDMuc3ZnLm11bHRpYnJ1c2ggY2xlYXJzIGV4dGVudHMganVzdCBiZWZvcmUgY2FsbGluZyAnYnJ1c2hlbmQnXG4gICAgICAgICAgLy8gc28gd2UgaGF2ZSB0byB1cGRhdGUgaGVyZSBhZ2Fpbi5cbiAgICAgICAgICAvLyBUaGlzIGZpeGVzIGlzc3VlICMxMDMgZm9yIG5vdywgYnV0IHNob3VsZCBiZSBjaGFuZ2VkIGluIGQzLnN2Zy5tdWx0aWJydXNoXG4gICAgICAgICAgLy8gdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29tcHV0YXRpb24uXG4gICAgICAgICAgYnJ1c2hVcGRhdGVkKHNlbGVjdGVkKCkpO1xuICAgICAgICAgIGV2ZW50cy5icnVzaGVuZC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmV4dGVudEFkYXB0aW9uKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUoJ3Zpc2liaWxpdHknLCBudWxsKS5hdHRyKCd4JywgLTE1KS5hdHRyKCd3aWR0aCcsIDMwKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc2l6ZUFkYXB0aW9uKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKCdyZWN0JykuYXR0cigneCcsIC0xNSkuYXR0cignd2lkdGgnLCAzMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICBicnVzaGVzW2F4aXNdID0gYnJ1c2g7XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hSZXNldChkaW1lbnNpb24pIHtcbiAgICAgIF9fLmJydXNoZWQgPSBmYWxzZTtcbiAgICAgIGlmIChnKSB7XG4gICAgICAgIGcuc2VsZWN0QWxsKCcuYnJ1c2gnKS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2hlc1tkXS5jbGVhcigpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICBpZiAoIWcpIHBjLmNyZWF0ZUF4ZXMoKTtcblxuICAgICAgLy8gQWRkIGFuZCBzdG9yZSBhIGJydXNoIGZvciBlYWNoIGF4aXMuXG4gICAgICBnLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYnJ1c2gnKVxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGJydXNoRm9yKGQpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdEFsbCgncmVjdCcpXG4gICAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsIG51bGwpXG4gICAgICAgIC5hdHRyKCd4JywgLTE1KVxuICAgICAgICAuYXR0cignd2lkdGgnLCAzMCk7XG5cbiAgICAgIHBjLmJydXNoRXh0ZW50cyA9IGJydXNoRXh0ZW50cztcbiAgICAgIHBjLmJydXNoUmVzZXQgPSBicnVzaFJlc2V0O1xuICAgICAgcmV0dXJuIHBjO1xuICAgIH1cblxuICAgIGJydXNoLm1vZGVzWycxRC1heGVzLW11bHRpJ10gPSB7XG4gICAgICBpbnN0YWxsOiBpbnN0YWxsLFxuICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGcuc2VsZWN0QWxsKCcuYnJ1c2gnKS5yZW1vdmUoKTtcbiAgICAgICAgYnJ1c2hlcyA9IHt9O1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hFeHRlbnRzO1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hSZXNldDtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBicnVzaFN0YXRlOiBicnVzaEV4dGVudHMsXG4gICAgfTtcbiAgfSkoKTtcbiAgLy8gYnJ1c2ggbW9kZTogYW5ndWxhclxuICAvLyBjb2RlIGJhc2VkIG9uIDJELnN0cnVtcy5qc1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyY3MgPSB7fSxcbiAgICAgIHN0cnVtUmVjdDtcblxuICAgIGZ1bmN0aW9uIGRyYXdTdHJ1bShhcmMsIGFjdGl2ZVBvaW50KSB7XG4gICAgICB2YXIgc3ZnID0gcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI2FyY3MnKSxcbiAgICAgICAgaWQgPSBhcmMuZGltcy5pLFxuICAgICAgICBwb2ludHMgPSBbYXJjLnAyLCBhcmMucDNdLFxuICAgICAgICBsaW5lID0gc3ZnLnNlbGVjdEFsbCgnbGluZSNhcmMtJyArIGlkKS5kYXRhKFtcbiAgICAgICAgICB7IHAxOiBhcmMucDEsIHAyOiBhcmMucDIgfSxcbiAgICAgICAgICB7IHAxOiBhcmMucDEsIHAyOiBhcmMucDMgfSxcbiAgICAgICAgXSksXG4gICAgICAgIGNpcmNsZXMgPSBzdmcuc2VsZWN0QWxsKCdjaXJjbGUjYXJjLScgKyBpZCkuZGF0YShwb2ludHMpLFxuICAgICAgICBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpLFxuICAgICAgICBwYXRoID0gc3ZnLnNlbGVjdEFsbCgncGF0aCNhcmMtJyArIGlkKS5kYXRhKFthcmNdKTtcblxuICAgICAgcGF0aFxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2FyYy0nICsgaWQpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdhcmMnKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnb3JhbmdlJylcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMC41KTtcblxuICAgICAgcGF0aC5hdHRyKCdkJywgYXJjLmFyYykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgYXJjLnAxWzBdICsgJywnICsgYXJjLnAxWzFdICsgJyknKTtcblxuICAgICAgbGluZVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2FyYy0nICsgaWQpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdhcmMnKTtcblxuICAgICAgbGluZVxuICAgICAgICAuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLnAxWzBdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLnAxWzFdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigneDInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLnAyWzBdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLnAyWzFdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xuXG4gICAgICBkcmFnXG4gICAgICAgIC5vbignZHJhZycsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgdmFyIGV2ID0gZDMuZXZlbnQsXG4gICAgICAgICAgICBhbmdsZSA9IDA7XG5cbiAgICAgICAgICBpID0gaSArIDI7XG5cbiAgICAgICAgICBhcmNbJ3AnICsgaV1bMF0gPSBNYXRoLm1pbihNYXRoLm1heChhcmMubWluWCArIDEsIGV2LngpLCBhcmMubWF4WCk7XG4gICAgICAgICAgYXJjWydwJyArIGldWzFdID0gTWF0aC5taW4oTWF0aC5tYXgoYXJjLm1pblksIGV2LnkpLCBhcmMubWF4WSk7XG5cbiAgICAgICAgICBhbmdsZSA9IGkgPT09IDMgPyBhcmNzLnN0YXJ0QW5nbGUoaWQpIDogYXJjcy5lbmRBbmdsZShpZCk7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoYXJjLnN0YXJ0QW5nbGUgPCBNYXRoLlBJICYmIGFyYy5lbmRBbmdsZSA8IE1hdGguUEkgJiYgYW5nbGUgPCBNYXRoLlBJKSB8fFxuICAgICAgICAgICAgKGFyYy5zdGFydEFuZ2xlID49IE1hdGguUEkgJiYgYXJjLmVuZEFuZ2xlID49IE1hdGguUEkgJiYgYW5nbGUgPj0gTWF0aC5QSSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChpID09PSAyKSB7XG4gICAgICAgICAgICAgIGFyYy5lbmRBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgICAgICBhcmMuYXJjLmVuZEFuZ2xlKGFuZ2xlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMykge1xuICAgICAgICAgICAgICBhcmMuc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgICAgICBhcmMuYXJjLnN0YXJ0QW5nbGUoYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRyYXdTdHJ1bShhcmMsIGkgLSAyKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdkcmFnZW5kJywgb25EcmFnRW5kKCkpO1xuXG4gICAgICBjaXJjbGVzXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXG4gICAgICAgIC5hdHRyKCdpZCcsICdhcmMtJyArIGlkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYXJjJyk7XG5cbiAgICAgIGNpcmNsZXNcbiAgICAgICAgLmF0dHIoJ2N4JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZFswXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZFsxXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3InLCA1KVxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVQb2ludCAhPT0gdW5kZWZpbmVkICYmIGkgPT09IGFjdGl2ZVBvaW50ID8gMC44IDogMDtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMC44KTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhbGwoZHJhZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGltZW5zaW9uc0ZvclBvaW50KHApIHtcbiAgICAgIHZhciBkaW1zID0geyBpOiAtMSwgbGVmdDogdW5kZWZpbmVkLCByaWdodDogdW5kZWZpbmVkIH07XG4gICAgICBfXy5kaW1lbnNpb25zLnNvbWUoZnVuY3Rpb24gKGRpbSwgaSkge1xuICAgICAgICBpZiAoeHNjYWxlKGRpbSkgPCBwWzBdKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBfXy5kaW1lbnNpb25zW2kgKyAxXTtcbiAgICAgICAgICBkaW1zLmkgPSBpO1xuICAgICAgICAgIGRpbXMubGVmdCA9IGRpbTtcbiAgICAgICAgICBkaW1zLnJpZ2h0ID0gbmV4dDtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGRpbXMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEV2ZW50IG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGZpcnN0IGF4aXMuXG4gICAgICAgIGRpbXMuaSA9IDA7XG4gICAgICAgIGRpbXMubGVmdCA9IF9fLmRpbWVuc2lvbnNbMF07XG4gICAgICAgIGRpbXMucmlnaHQgPSBfXy5kaW1lbnNpb25zWzFdO1xuICAgICAgfSBlbHNlIGlmIChkaW1zLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRXZlbnQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGxhc3QgYXhpc1xuICAgICAgICBkaW1zLmkgPSBfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDE7XG4gICAgICAgIGRpbXMucmlnaHQgPSBkaW1zLmxlZnQ7XG4gICAgICAgIGRpbXMubGVmdCA9IF9fLmRpbWVuc2lvbnNbX18uZGltZW5zaW9ucy5sZW5ndGggLSAyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnU3RhcnQoKSB7XG4gICAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGRldGVybWluZSBiZXR3ZWVuIHdoaWNoIHR3byBheGVzIHRoZSBhcmMgd2FzIHN0YXJ0ZWQuXG4gICAgICAvLyBUaGlzIHdpbGwgZGV0ZXJtaW5lIHRoZSBmcmVlZG9tIG9mIG1vdmVtZW50LCBiZWNhdXNlIGEgYXJjIGNhblxuICAgICAgLy8gbG9naWNhbGx5IG9ubHkgaGFwcGVuIGJldHdlZW4gdHdvIGF4ZXMsIHNvIG5vIG1vdmVtZW50IG91dHNpZGUgdGhlc2UgYXhlc1xuICAgICAgLy8gc2hvdWxkIGJlIGFsbG93ZWQuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9IGQzLm1vdXNlKHN0cnVtUmVjdFswXVswXSksXG4gICAgICAgICAgZGltcyxcbiAgICAgICAgICBhcmM7XG5cbiAgICAgICAgcFswXSA9IHBbMF0gLSBfXy5tYXJnaW4ubGVmdDtcbiAgICAgICAgcFsxXSA9IHBbMV0gLSBfXy5tYXJnaW4udG9wO1xuXG4gICAgICAgIChkaW1zID0gZGltZW5zaW9uc0ZvclBvaW50KHApKSxcbiAgICAgICAgICAoYXJjID0ge1xuICAgICAgICAgICAgcDE6IHAsXG4gICAgICAgICAgICBkaW1zOiBkaW1zLFxuICAgICAgICAgICAgbWluWDogeHNjYWxlKGRpbXMubGVmdCksXG4gICAgICAgICAgICBtYXhYOiB4c2NhbGUoZGltcy5yaWdodCksXG4gICAgICAgICAgICBtaW5ZOiAwLFxuICAgICAgICAgICAgbWF4WTogaCgpLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5kQW5nbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyYzogZDMuc3ZnLmFyYygpLmlubmVyUmFkaXVzKDApLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGFyY3NbZGltcy5pXSA9IGFyYztcbiAgICAgICAgYXJjcy5hY3RpdmUgPSBkaW1zLmk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgYm91bmRzXG4gICAgICAgIGFyYy5wMVswXSA9IE1hdGgubWluKE1hdGgubWF4KGFyYy5taW5YLCBwWzBdKSwgYXJjLm1heFgpO1xuICAgICAgICBhcmMucDIgPSBhcmMucDEuc2xpY2UoKTtcbiAgICAgICAgYXJjLnAzID0gYXJjLnAxLnNsaWNlKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZygpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldiA9IGQzLmV2ZW50LFxuICAgICAgICAgIGFyYyA9IGFyY3NbYXJjcy5hY3RpdmVdO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuICAgICAgICBhcmMucDJbMF0gPSBNYXRoLm1pbihNYXRoLm1heChhcmMubWluWCArIDEsIGV2LnggLSBfXy5tYXJnaW4ubGVmdCksIGFyYy5tYXhYKTtcbiAgICAgICAgYXJjLnAyWzFdID0gTWF0aC5taW4oTWF0aC5tYXgoYXJjLm1pblksIGV2LnkgLSBfXy5tYXJnaW4udG9wKSwgYXJjLm1heFkpO1xuICAgICAgICBhcmMucDMgPSBhcmMucDIuc2xpY2UoKTtcbiAgICAgICAgZHJhd1N0cnVtKGFyYywgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHNvbWUgaGVscGVyIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIGh5cG90aGVudXNlKGEsIGIpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgfVxuXG4gICAgdmFyIHJhZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYyA9IE1hdGguUEkgLyAxODA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBhbmdsZSAqIGM7XG4gICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICB2YXIgZGVnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjID0gMTgwIC8gTWF0aC5QSTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGFuZ2xlICogYztcbiAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIC8vIFswLCAyKlBJXSAtPiBbLVBJLzIsIFBJLzJdXG4gICAgdmFyIHNpZ25lZEFuZ2xlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICB2YXIgcmV0ID0gYW5nbGU7XG4gICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJKSB7XG4gICAgICAgIHJldCA9IGFuZ2xlIC0gMS41ICogTWF0aC5QSTtcbiAgICAgICAgcmV0ID0gYW5nbGUgLSAxLjUgKiBNYXRoLlBJO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYW5nbGUgLSAwLjUgKiBNYXRoLlBJO1xuICAgICAgICByZXQgPSBhbmdsZSAtIDAuNSAqIE1hdGguUEk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLXJldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYW5nbGVzIGFyZSBzdG9yZWQgaW4gcmFkaWFucyBmcm9tIGluIFswLCAyKlBJXSwgd2hlcmUgMCBpbiAxMiBvJ2Nsb2NrLlxuICAgICAqIEhvd2V2ZXIsIG9uZSBjYW4gb25seSBzZWxlY3QgbGluZXMgZnJvbSAwIHRvIFBJLCBzbyB3ZSBjb21wdXRlIHRoZVxuICAgICAqICdzaWduZWQnIGFuZ2xlLCB3aGVyZSAwIGlzIHRoZSBob3Jpem9udGFsIGxpbmUgKDMgbydjbG9jayksIGFuZCArLy0gUEkvMlxuICAgICAqIGFyZSAxMiBhbmQgNiBvJ2Nsb2NrIHJlc3BlY3RpdmVseS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlubWVudFRlc3QoYXJjKSB7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IHNpZ25lZEFuZ2xlKGFyYy5zdGFydEFuZ2xlKTtcbiAgICAgIHZhciBlbmRBbmdsZSA9IHNpZ25lZEFuZ2xlKGFyYy5lbmRBbmdsZSk7XG5cbiAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgICAgZW5kQW5nbGUgPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIC8vIHRlc3QgaWYgc2VnbWVudCBhbmdsZSBpcyBjb250YWluZWQgaW4gYW5nbGUgaW50ZXJ2YWxcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICBpZiAoYSA+PSBzdGFydEFuZ2xlICYmIGEgPD0gZW5kQW5nbGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJjcyksXG4gICAgICAgIGJydXNoZWQgPSBfXy5kYXRhO1xuXG4gICAgICAvLyBHZXQgdGhlIGlkcyBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBhcmNzLlxuICAgICAgaWRzID0gaWRzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyb3NzZXNTdHJ1bShkLCBpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF0sXG4gICAgICAgICAgdGVzdCA9IGNvbnRhaW5tZW50VGVzdChhcmMpLFxuICAgICAgICAgIGQxID0gYXJjLmRpbXMubGVmdCxcbiAgICAgICAgICBkMiA9IGFyYy5kaW1zLnJpZ2h0LFxuICAgICAgICAgIHkxID0geXNjYWxlW2QxXSxcbiAgICAgICAgICB5MiA9IHlzY2FsZVtkMl0sXG4gICAgICAgICAgYSA9IGFyY3Mud2lkdGgoaWQpLFxuICAgICAgICAgIGIgPSB5MShkW2QxXSkgLSB5MihkW2QyXSksXG4gICAgICAgICAgYyA9IGh5cG90aGVudXNlKGEsIGIpLFxuICAgICAgICAgIGFuZ2xlID0gTWF0aC5hc2luKGIgLyBjKTsgLy8gcmFkIGluIFstUEkvMiwgUEkvMl1cbiAgICAgICAgcmV0dXJuIHRlc3QoYW5nbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYnJ1c2hlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJydXNoZWQuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHN3aXRjaCAoYnJ1c2gucHJlZGljYXRlKSB7XG4gICAgICAgICAgY2FzZSAnQU5EJzpcbiAgICAgICAgICAgIHJldHVybiBpZHMuZXZlcnkoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcm9zc2VzU3RydW0oZCwgaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSAnT1InOlxuICAgICAgICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3Jvc3Nlc1N0cnVtKGQsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnVW5rbm93biBicnVzaCBwcmVkaWNhdGUgJyArIF9fLmJydXNoUHJlZGljYXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVTdHJ1bSgpIHtcbiAgICAgIHZhciBhcmMgPSBhcmNzW2FyY3MuYWN0aXZlXSxcbiAgICAgICAgc3ZnID0gcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI2FyY3MnKTtcblxuICAgICAgZGVsZXRlIGFyY3NbYXJjcy5hY3RpdmVdO1xuICAgICAgYXJjcy5hY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICBzdmcuc2VsZWN0QWxsKCdsaW5lI2FyYy0nICsgYXJjLmRpbXMuaSkucmVtb3ZlKCk7XG4gICAgICBzdmcuc2VsZWN0QWxsKCdjaXJjbGUjYXJjLScgKyBhcmMuZGltcy5pKS5yZW1vdmUoKTtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ3BhdGgjYXJjLScgKyBhcmMuZGltcy5pKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWdFbmQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnJ1c2hlZCA9IF9fLmRhdGEsXG4gICAgICAgICAgYXJjID0gYXJjc1thcmNzLmFjdGl2ZV07XG5cbiAgICAgICAgLy8gT2theSwgc29tZXdoYXQgdW5leHBlY3RlZCwgYnV0IG5vdCB0b3RhbGx5IHVuc3VycHJpc2luZywgYSBtb3VzY2xpY2sgaXNcbiAgICAgICAgLy8gY29uc2lkZXJlZCBhIGRyYWcgd2l0aG91dCBtb3ZlLiBTbyB3ZSBoYXZlIHRvIGRlYWwgd2l0aCB0aGF0IGNhc2VcbiAgICAgICAgaWYgKGFyYyAmJiBhcmMucDFbMF0gPT09IGFyYy5wMlswXSAmJiBhcmMucDFbMV0gPT09IGFyYy5wMlsxXSkge1xuICAgICAgICAgIHJlbW92ZVN0cnVtKGFyY3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyYykge1xuICAgICAgICAgIHZhciBhbmdsZSA9IGFyY3Muc3RhcnRBbmdsZShhcmNzLmFjdGl2ZSk7XG5cbiAgICAgICAgICBhcmMuc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgIGFyYy5lbmRBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgIGFyYy5hcmMub3V0ZXJSYWRpdXMoYXJjcy5sZW5ndGgoYXJjcy5hY3RpdmUpKS5zdGFydEFuZ2xlKGFuZ2xlKS5lbmRBbmdsZShhbmdsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicnVzaGVkID0gc2VsZWN0ZWQoYXJjcyk7XG4gICAgICAgIGFyY3MuYWN0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgICBfXy5icnVzaGVkID0gYnJ1c2hlZDtcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgICAgICBldmVudHMuYnJ1c2hlbmQuY2FsbChwYywgX18uYnJ1c2hlZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoUmVzZXQoYXJjcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyY3MpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiAhaXNOYU4oZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgYXJjcy5hY3RpdmUgPSBkO1xuICAgICAgICAgIHJlbW92ZVN0cnVtKGFyY3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgb25EcmFnRW5kKGFyY3MpKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICB2YXIgZHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKTtcblxuICAgICAgLy8gTWFwIG9mIGN1cnJlbnQgYXJjcy4gYXJjcyBhcmUgc3RvcmVkIHBlciBzZWdtZW50IG9mIHRoZSBQQy4gQSBzZWdtZW50LFxuICAgICAgLy8gYmVpbmcgdGhlIGFyZWEgYmV0d2VlbiB0d28gYXhlcy4gVGhlIGxlZnQgbW9zdCBhcmVhIGlzIGluZGV4ZWQgYXQgMC5cbiAgICAgIGFyY3MuYWN0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgLy8gUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIFBDIHNlZ21lbnQgd2hlcmUgY3VycmVudGx5IGEgYXJjIGlzIGJlaW5nXG4gICAgICAvLyBwbGFjZWQuIE5PVEU6IGV2ZW4gdGhvdWdoIHRoZXkgYXJlIGV2ZW5seSBzcGFjZWQgaW4gb3VyIGN1cnJlbnRcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uLCB3ZSBrZWVwIGZvciB3aGVuIG5vbi1ldmVuIHNwYWNlZCBzZWdtZW50cyBhcmUgc3VwcG9ydGVkIGFzXG4gICAgICAvLyB3ZWxsLlxuICAgICAgYXJjcy53aWR0aCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF07XG5cbiAgICAgICAgaWYgKGFyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcmMubWF4WCAtIGFyYy5taW5YO1xuICAgICAgfTtcblxuICAgICAgLy8gcmV0dXJucyBhbmdsZXMgaW4gWy1QSS8yLCBQSS8yXVxuICAgICAgYW5nbGUgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgICAgIHZhciBhID0gcDFbMF0gLSBwMlswXSxcbiAgICAgICAgICBiID0gcDFbMV0gLSBwMlsxXSxcbiAgICAgICAgICBjID0gaHlwb3RoZW51c2UoYSwgYik7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYXNpbihiIC8gYyk7XG4gICAgICB9O1xuXG4gICAgICAvLyByZXR1cm5zIGFuZ2xlcyBpbiBbMCwgMiAqIFBJXVxuICAgICAgYXJjcy5lbmRBbmdsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF07XG4gICAgICAgIGlmIChhcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNBbmdsZSA9IGFuZ2xlKGFyYy5wMSwgYXJjLnAyKSxcbiAgICAgICAgICB1QW5nbGUgPSAtc0FuZ2xlICsgTWF0aC5QSSAvIDI7XG5cbiAgICAgICAgaWYgKGFyYy5wMVswXSA+IGFyYy5wMlswXSkge1xuICAgICAgICAgIHVBbmdsZSA9IDIgKiBNYXRoLlBJIC0gdUFuZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVBbmdsZTtcbiAgICAgIH07XG5cbiAgICAgIGFyY3Muc3RhcnRBbmdsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF07XG4gICAgICAgIGlmIChhcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc0FuZ2xlID0gYW5nbGUoYXJjLnAxLCBhcmMucDMpLFxuICAgICAgICAgIHVBbmdsZSA9IC1zQW5nbGUgKyBNYXRoLlBJIC8gMjtcblxuICAgICAgICBpZiAoYXJjLnAxWzBdID4gYXJjLnAzWzBdKSB7XG4gICAgICAgICAgdUFuZ2xlID0gMiAqIE1hdGguUEkgLSB1QW5nbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdUFuZ2xlO1xuICAgICAgfTtcblxuICAgICAgYXJjcy5sZW5ndGggPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdO1xuXG4gICAgICAgIGlmIChhcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYSA9IGFyYy5wMVswXSAtIGFyYy5wMlswXSxcbiAgICAgICAgICBiID0gYXJjLnAxWzFdIC0gYXJjLnAyWzFdLFxuICAgICAgICAgIGMgPSBoeXBvdGhlbnVzZShhLCBiKTtcblxuICAgICAgICByZXR1cm4gYztcbiAgICAgIH07XG5cbiAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5hcmNzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJjcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBmaXJzdCBkaW1lbnNpb24gaXMgZGlyZWN0bHkgbGVmdCBvZiB0aGUgc2Vjb25kIGRpbWVuc2lvbi5cbiAgICAgICAgZnVuY3Rpb24gY29uc2VjdXRpdmUoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBfXy5kaW1lbnNpb25zLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZCA9PT0gZmlyc3QgPyBpICsgaSA8IGxlbmd0aCAmJiBfXy5kaW1lbnNpb25zW2kgKyAxXSA9PT0gc2Vjb25kIDogZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIHNvbWUgYXJjcywgd2hpY2ggbWlnaHQgbmVlZCB0byBiZSByZW1vdmVkLlxuICAgICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgZGltcyA9IGFyY3NbZF0uZGltcztcbiAgICAgICAgICAgIGFyY3MuYWN0aXZlID0gZDtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0d28gZGltZW5zaW9ucyBvZiB0aGUgY3VycmVudCBhcmMgYXJlIG5vdCBuZXh0IHRvIGVhY2ggb3RoZXJcbiAgICAgICAgICAgIC8vIGFueSBtb3JlLCB0aGFuIHdlJ2xsIG5lZWQgdG8gcmVtb3ZlIHRoZSBhcmMuIE90aGVyd2lzZSB3ZSBrZWVwIGl0LlxuICAgICAgICAgICAgaWYgKCFjb25zZWN1dGl2ZShkaW1zLmxlZnQsIGRpbXMucmlnaHQpKSB7XG4gICAgICAgICAgICAgIHJlbW92ZVN0cnVtKGFyY3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9uRHJhZ0VuZChhcmNzKSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIGEgbmV3IHN2ZyBncm91cCBpbiB3aGljaCB3ZSBkcmF3IHRoZSBhcmNzLlxuICAgICAgcGMuc2VsZWN0aW9uXG4gICAgICAgIC5zZWxlY3QoJ3N2ZycpXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxuICAgICAgICAuYXR0cignaWQnLCAnYXJjcycpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfXy5tYXJnaW4ubGVmdCArICcsJyArIF9fLm1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAvLyBJbnN0YWxsIHRoZSByZXF1aXJlZCBicnVzaFJlc2V0IGZ1bmN0aW9uXG4gICAgICBwYy5icnVzaFJlc2V0ID0gYnJ1c2hSZXNldChhcmNzKTtcblxuICAgICAgZHJhZ1xuICAgICAgICAub24oJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KGFyY3MpKVxuICAgICAgICAub24oJ2RyYWcnLCBvbkRyYWcoYXJjcykpXG4gICAgICAgIC5vbignZHJhZ2VuZCcsIG9uRHJhZ0VuZChhcmNzKSk7XG5cbiAgICAgIC8vIE5PVEU6IFRoZSBzdHlsaW5nIG5lZWRzIHRvIGJlIGRvbmUgaGVyZSBhbmQgbm90IGluIHRoZSBjc3MuIFRoaXMgaXMgYmVjYXVzZVxuICAgICAgLy8gICAgICAgZm9yIDFEIGJydXNoaW5nLCB0aGUgY2FudmFzIGxheWVycyBzaG91bGQgbm90IGxpc3RlbiB0b1xuICAgICAgLy8gICAgICAgcG9pbnRlci1ldmVudHMuXG4gICAgICBzdHJ1bVJlY3QgPSBwYy5zZWxlY3Rpb25cbiAgICAgICAgLnNlbGVjdCgnc3ZnJylcbiAgICAgICAgLmluc2VydCgncmVjdCcsICdnI2FyY3MnKVxuICAgICAgICAuYXR0cignaWQnLCAnYXJjLWV2ZW50cycpXG4gICAgICAgIC5hdHRyKCd4JywgX18ubWFyZ2luLmxlZnQpXG4gICAgICAgIC5hdHRyKCd5JywgX18ubWFyZ2luLnRvcClcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgdygpKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaCgpICsgMilcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMClcbiAgICAgICAgLmNhbGwoZHJhZyk7XG4gICAgfVxuXG4gICAgYnJ1c2gubW9kZXNbJ2FuZ3VsYXInXSA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI2FyY3MnKS5yZW1vdmUoKTtcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdyZWN0I2FyYy1ldmVudHMnKS5yZW1vdmUoKTtcbiAgICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLmFyY3MnLCB1bmRlZmluZWQpO1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hSZXNldDtcblxuICAgICAgICBzdHJ1bVJlY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgYnJ1c2hTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJjcztcbiAgICAgIH0sXG4gICAgfTtcbiAgfSkoKTtcblxuICBwYy5pbnRlcmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmbGFncy5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gZXhwb3NlIGEgZmV3IG9iamVjdHNcbiAgcGMueHNjYWxlID0geHNjYWxlO1xuICBwYy55c2NhbGUgPSB5c2NhbGU7XG4gIHBjLmN0eCA9IGN0eDtcbiAgcGMuY2FudmFzID0gY2FudmFzO1xuICBwYy5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnO1xuICB9O1xuXG4gIC8vIHJlc2NhbGUgZm9yIGhlaWdodCwgd2lkdGggYW5kIG1hcmdpbnNcbiAgLy8gVE9ETyBjdXJyZW50bHkgYXNzdW1lcyBjaGFydCBpcyBicnVzaGFibGUsIGFuZCBkZXN0cm95cyBvbGQgYnJ1c2hlc1xuICBwYy5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2VsZWN0aW9uIHNpemVcbiAgICBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5hdHRyKCd3aWR0aCcsIF9fLndpZHRoKS5hdHRyKCdoZWlnaHQnLCBfXy5oZWlnaHQpO1xuICAgIHBjLnN2Zy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfXy5tYXJnaW4ubGVmdCArICcsJyArIF9fLm1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgLy8gRklYTUU6IHRoZSBjdXJyZW50IGJydXNoIHN0YXRlIHNob3VsZCBwYXNzIHRocm91Z2hcbiAgICBpZiAoZmxhZ3MuYnJ1c2hhYmxlKSBwYy5icnVzaFJlc2V0KCk7XG5cbiAgICAvLyBzY2FsZXNcbiAgICBwYy5hdXRvc2NhbGUoKTtcblxuICAgIC8vIGF4ZXMsIGRlc3Ryb3lzIG9sZCBicnVzaGVzLlxuICAgIGlmIChnKSBwYy5jcmVhdGVBeGVzKCk7XG4gICAgaWYgKGZsYWdzLmJydXNoYWJsZSkgcGMuYnJ1c2hhYmxlKCk7XG4gICAgaWYgKGZsYWdzLnJlb3JkZXJhYmxlKSBwYy5yZW9yZGVyYWJsZSgpO1xuXG4gICAgZXZlbnRzLnJlc2l6ZS5jYWxsKHRoaXMsIHsgd2lkdGg6IF9fLndpZHRoLCBoZWlnaHQ6IF9fLmhlaWdodCwgbWFyZ2luOiBfXy5tYXJnaW4gfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gaGlnaGxpZ2h0IGFuIGFycmF5IG9mIGRhdGFcbiAgcGMuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIF9fLmhpZ2hsaWdodGVkO1xuICAgIH1cblxuICAgIF9fLmhpZ2hsaWdodGVkID0gZGF0YTtcbiAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XG4gICAgZDMuc2VsZWN0QWxsKFtjYW52YXMuZm9yZWdyb3VuZCwgY2FudmFzLmJydXNoZWRdKS5jbGFzc2VkKCdmYWRlZCcsIHRydWUpO1xuICAgIGRhdGEuZm9yRWFjaChwYXRoX2hpZ2hsaWdodCk7XG4gICAgZXZlbnRzLmhpZ2hsaWdodC5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIGNsZWFyIGhpZ2hsaWdodGluZ1xuICBwYy51bmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfXy5oaWdobGlnaHRlZCA9IFtdO1xuICAgIHBjLmNsZWFyKCdoaWdobGlnaHQnKTtcbiAgICBkMy5zZWxlY3RBbGwoW2NhbnZhcy5mb3JlZ3JvdW5kLCBjYW52YXMuYnJ1c2hlZF0pLmNsYXNzZWQoJ2ZhZGVkJywgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIGNhbGN1bGF0ZSAyZCBpbnRlcnNlY3Rpb24gb2YgbGluZSBhLT5iIHdpdGggbGluZSBjLT5kXG4gIC8vIHBvaW50cyBhcmUgb2JqZWN0cyB3aXRoIHggYW5kIHkgcHJvcGVydGllc1xuICBwYy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OlxuICAgICAgICAoKGEueCAqIGIueSAtIGEueSAqIGIueCkgKiAoYy54IC0gZC54KSAtIChhLnggLSBiLngpICogKGMueCAqIGQueSAtIGMueSAqIGQueCkpIC9cbiAgICAgICAgKChhLnggLSBiLngpICogKGMueSAtIGQueSkgLSAoYS55IC0gYi55KSAqIChjLnggLSBkLngpKSxcbiAgICAgIHk6XG4gICAgICAgICgoYS54ICogYi55IC0gYS55ICogYi54KSAqIChjLnkgLSBkLnkpIC0gKGEueSAtIGIueSkgKiAoYy54ICogZC55IC0gYy55ICogZC54KSkgL1xuICAgICAgICAoKGEueCAtIGIueCkgKiAoYy55IC0gZC55KSAtIChhLnkgLSBiLnkpICogKGMueCAtIGQueCkpLFxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gcG9zaXRpb24oZCkge1xuICAgIHZhciB2ID0gZHJhZ2dpbmdbZF07XG4gICAgcmV0dXJuIHYgPT0gbnVsbCA/IHhzY2FsZShkKSA6IHY7XG4gIH1cbiAgcGMudmVyc2lvbiA9ICcwLjcuMCc7XG4gIC8vIHRoaXMgZGVzY3JpcHRpdmUgdGV4dCBzaG91bGQgbGl2ZSB3aXRoIG90aGVyIGludHJvc3BlY3RpdmUgbWV0aG9kc1xuICBwYy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgJ1BhcmFsbGVsIENvb3JkaW5hdGVzOiAnICtcbiAgICAgIF9fLmRpbWVuc2lvbnMubGVuZ3RoICtcbiAgICAgICcgZGltZW5zaW9ucyAoJyArXG4gICAgICBkMy5rZXlzKF9fLmRhdGFbMF0pLmxlbmd0aCArXG4gICAgICAnIHRvdGFsKSAsICcgK1xuICAgICAgX18uZGF0YS5sZW5ndGggK1xuICAgICAgJyByb3dzJ1xuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIHBjO1xufVxuXG5kMy5yZW5kZXJRdWV1ZSA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIHZhciBfcXVldWUgPSBbXSwgLy8gZGF0YSB0byBiZSByZW5kZXJlZFxuICAgIF9yYXRlID0gMTAsIC8vIG51bWJlciBvZiBjYWxscyBwZXIgZnJhbWVcbiAgICBfY2xlYXIgPSBmdW5jdGlvbiAoKSB7fSwgLy8gY2xlYXJpbmcgZnVuY3Rpb25cbiAgICBfaSA9IDA7IC8vIGN1cnJlbnQgaXRlcmF0aW9uXG5cbiAgdmFyIHJxID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoZGF0YSkgcnEuZGF0YShkYXRhKTtcbiAgICBycS5pbnZhbGlkYXRlKCk7XG4gICAgX2NsZWFyKCk7XG4gICAgcnEucmVuZGVyKCk7XG4gIH07XG5cbiAgcnEucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF9pID0gMDtcbiAgICB2YXIgdmFsaWQgPSB0cnVlO1xuICAgIHJxLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YWxpZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkb0ZyYW1lKCkge1xuICAgICAgaWYgKCF2YWxpZCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoX2kgPiBfcXVldWUubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgLy8gVHlwaWNhbCBkMyBiZWhhdmlvciBpcyB0byBwYXNzIGEgZGF0YSBpdGVtICphbmQqIGl0cyBpbmRleC4gQXMgdGhlXG4gICAgICAvLyByZW5kZXIgcXVldWUgc3BsaXRzIHRoZSBvcmlnaW5hbCBkYXRhIHNldCwgd2UnbGwgaGF2ZSB0byBiZSBzbGlnaHRseVxuICAgICAgLy8gbW9yZSBjYXJlZnVsbCBhYm91dCBwYXNzaW5nIHRoZSBjb3JyZWN0IGluZGV4IHdpdGggdGhlIGRhdGEgaXRlbS5cbiAgICAgIHZhciBlbmQgPSBNYXRoLm1pbihfaSArIF9yYXRlLCBfcXVldWUubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSBfaTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGZ1bmMoX3F1ZXVlW2ldLCBpKTtcbiAgICAgIH1cbiAgICAgIF9pICs9IF9yYXRlO1xuICAgIH1cblxuICAgIGQzLnRpbWVyKGRvRnJhbWUpO1xuICB9O1xuXG4gIHJxLmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJxLmludmFsaWRhdGUoKTtcbiAgICBfcXVldWUgPSBkYXRhLnNsaWNlKDApO1xuICAgIHJldHVybiBycTtcbiAgfTtcblxuICBycS5yYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gX3JhdGU7XG4gICAgX3JhdGUgPSB2YWx1ZTtcbiAgICByZXR1cm4gcnE7XG4gIH07XG5cbiAgcnEucmVtYWluaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcXVldWUubGVuZ3RoIC0gX2k7XG4gIH07XG5cbiAgLy8gY2xlYXIgdGhlIGNhbnZhc1xuICBycS5jbGVhciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBfY2xlYXIoKTtcbiAgICAgIHJldHVybiBycTtcbiAgICB9XG4gICAgX2NsZWFyID0gZnVuYztcbiAgICByZXR1cm4gcnE7XG4gIH07XG5cbiAgcnEuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIHJldHVybiBycTtcbn07XG4iLCIvKiBbTElDRU5TRSBUQkRdICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gZnJvbSBodHRwOi8vYmwub2Nrcy5vcmcvMzY4NzgyNlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgY29sdW1ucyA9IFtdO1xuXG4gIHZhciBkZyA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICBpZiAoY29sdW1ucy5sZW5ndGggPT0gMCkgY29sdW1ucyA9IGQzLmtleXMoc2VsZWN0aW9uLmRhdGEoKVswXVswXSk7XG5cbiAgICAvLyBoZWFkZXJcbiAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKCcuaGVhZGVyJykuZGF0YShbdHJ1ZV0pLmVudGVyKCkuYXBwZW5kKCdkaXYnKS5hdHRyKCdjbGFzcycsICdoZWFkZXInKTtcblxuICAgIHZhciBoZWFkZXIgPSBzZWxlY3Rpb24uc2VsZWN0KCcuaGVhZGVyJykuc2VsZWN0QWxsKCcuY2VsbCcpLmRhdGEoY29sdW1ucyk7XG5cbiAgICBoZWFkZXJcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdkaXYnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuICdjb2wtJyArIGk7XG4gICAgICB9KVxuICAgICAgLmNsYXNzZWQoJ2NlbGwnLCB0cnVlKTtcblxuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5oZWFkZXIgLmNlbGwnKS50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9KTtcblxuICAgIGhlYWRlci5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAvLyByb3dzXG4gICAgdmFyIHJvd3MgPSBzZWxlY3Rpb24uc2VsZWN0QWxsKCcucm93JykuZGF0YShmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSk7XG5cbiAgICByb3dzLmVudGVyKCkuYXBwZW5kKCdkaXYnKS5hdHRyKCdjbGFzcycsICdyb3cnKTtcblxuICAgIHJvd3MuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgdmFyIGNlbGxzID0gc2VsZWN0aW9uXG4gICAgICAuc2VsZWN0QWxsKCcucm93JylcbiAgICAgIC5zZWxlY3RBbGwoJy5jZWxsJylcbiAgICAgIC5kYXRhKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgcmV0dXJuIGRbY29sXTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIC8vIGNlbGxzXG4gICAgY2VsbHNcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdkaXYnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuICdjb2wtJyArIGk7XG4gICAgICB9KVxuICAgICAgLmNsYXNzZWQoJ2NlbGwnLCB0cnVlKTtcblxuICAgIGNlbGxzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5jZWxsJykudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGc7XG4gIH07XG5cbiAgZGcuY29sdW1ucyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sdW1ucztcbiAgICBjb2x1bW5zID0gXztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gZGc7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9zb3J0LXByb3AtdHlwZXMgKi9cbmltcG9ydCBkMyBmcm9tICdkMyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZ2V0U2VxdWVudGlhbFNjaGVtZVJlZ2lzdHJ5IH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuXG5pbXBvcnQgcGFyY29vcmRzIGZyb20gJy4vdmVuZG9yL3BhcmNvb3Jkcy9kMy5wYXJjb29yZHMnO1xuaW1wb3J0IGRpdmdyaWQgZnJvbSAnLi92ZW5kb3IvcGFyY29vcmRzL2RpdmdyaWQnO1xuaW1wb3J0ICcuL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmNzcyc7XG5cbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgLy8gU3RhbmRhcmQgdGFidWxhciBkYXRhIFt7IGZpZWxkTmFtZTE6IHZhbHVlMSwgZmllbGROYW1lMjogdmFsdWUyIH1dXG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vYmplY3QpLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBjb2xvck1ldHJpYzogUHJvcFR5cGVzLnN0cmluZyxcbiAgaW5jbHVkZVNlcmllczogUHJvcFR5cGVzLmJvb2wsXG4gIGxpbmVhckNvbG9yU2NoZW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBtZXRyaWNzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgc2VyaWVzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzaG93RGF0YXRhYmxlOiBQcm9wVHlwZXMuYm9vbCxcbn07XG5cbmZ1bmN0aW9uIFBhcmFsbGVsQ29vcmRpbmF0ZXMoZWxlbWVudCwgcHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGRhdGEsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGNvbG9yTWV0cmljLFxuICAgIGluY2x1ZGVTZXJpZXMsXG4gICAgbGluZWFyQ29sb3JTY2hlbWUsXG4gICAgbWV0cmljcyxcbiAgICBzZXJpZXMsXG4gICAgc2hvd0RhdGF0YWJsZSxcbiAgfSA9IHByb3BzO1xuXG4gIGNvbnN0IGNvbHMgPSBpbmNsdWRlU2VyaWVzID8gW3Nlcmllc10uY29uY2F0KG1ldHJpY3MpIDogbWV0cmljcztcblxuICBjb25zdCB0dHlwZXMgPSB7fTtcbiAgdHR5cGVzW3Nlcmllc10gPSAnc3RyaW5nJztcbiAgbWV0cmljcy5mb3JFYWNoKHYgPT4ge1xuICAgIHR0eXBlc1t2XSA9ICdudW1iZXInO1xuICB9KTtcblxuICBjb25zdCBjb2xvclNjYWxlID0gY29sb3JNZXRyaWNcbiAgICA/IGdldFNlcXVlbnRpYWxTY2hlbWVSZWdpc3RyeSgpXG4gICAgICAgIC5nZXQobGluZWFyQ29sb3JTY2hlbWUpXG4gICAgICAgIC5jcmVhdGVMaW5lYXJTY2FsZShkMy5leHRlbnQoZGF0YSwgZCA9PiBkW2NvbG9yTWV0cmljXSkpXG4gICAgOiAoKSA9PiAnZ3JleSc7XG4gIGNvbnN0IGNvbG9yID0gZCA9PiBjb2xvclNjYWxlKGRbY29sb3JNZXRyaWNdKTtcbiAgY29uc3QgY29udGFpbmVyID0gZDMuc2VsZWN0KGVsZW1lbnQpLmNsYXNzZWQoJ3N1cGVyc2V0LWxlZ2FjeS1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcycsIHRydWUpO1xuICBjb250YWluZXIuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG4gIGNvbnN0IGVmZkhlaWdodCA9IHNob3dEYXRhdGFibGUgPyBoZWlnaHQgLyAyIDogaGVpZ2h0O1xuXG4gIGNvbnN0IGRpdiA9IGNvbnRhaW5lci5hcHBlbmQoJ2RpdicpLnN0eWxlKCdoZWlnaHQnLCBgJHtlZmZIZWlnaHR9cHhgKS5jbGFzc2VkKCdwYXJjb29yZHMnLCB0cnVlKTtcblxuICBjb25zdCBjaGFydCA9IHBhcmNvb3JkcygpKGRpdi5ub2RlKCkpXG4gICAgLndpZHRoKHdpZHRoKVxuICAgIC5jb2xvcihjb2xvcilcbiAgICAuYWxwaGEoMC41KVxuICAgIC5jb21wb3NpdGUoJ2RhcmtlbicpXG4gICAgLmhlaWdodChlZmZIZWlnaHQpXG4gICAgLmRhdGEoZGF0YSlcbiAgICAuZGltZW5zaW9ucyhjb2xzKVxuICAgIC50eXBlcyh0dHlwZXMpXG4gICAgLnJlbmRlcigpXG4gICAgLmNyZWF0ZUF4ZXMoKVxuICAgIC5zaGFkb3dzKClcbiAgICAucmVvcmRlcmFibGUoKVxuICAgIC5icnVzaE1vZGUoJzFELWF4ZXMnKTtcblxuICBpZiAoc2hvd0RhdGF0YWJsZSkge1xuICAgIC8vIGNyZWF0ZSBkYXRhIHRhYmxlLCByb3cgaG92ZXIgaGlnaGxpZ2h0aW5nXG4gICAgY29uc3QgZ3JpZCA9IGRpdmdyaWQoKTtcbiAgICBjb250YWluZXJcbiAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAuc3R5bGUoJ2hlaWdodCcsIGAke2VmZkhlaWdodH1weGApXG4gICAgICAuZGF0dW0oZGF0YSlcbiAgICAgIC5jYWxsKGdyaWQpXG4gICAgICAuY2xhc3NlZCgncGFyY29vcmRzIGdyaWQnLCB0cnVlKVxuICAgICAgLnNlbGVjdEFsbCgnLnJvdycpXG4gICAgICAub24oe1xuICAgICAgICBtb3VzZW92ZXIoZCkge1xuICAgICAgICAgIGNoYXJ0LmhpZ2hsaWdodChbZF0pO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZW91dDogY2hhcnQudW5oaWdobGlnaHQsXG4gICAgICB9KTtcbiAgICAvLyB1cGRhdGUgZGF0YSB0YWJsZSBvbiBicnVzaCBldmVudFxuICAgIGNoYXJ0Lm9uKCdicnVzaCcsIGQgPT4ge1xuICAgICAgZDMuc2VsZWN0KCcuZ3JpZCcpXG4gICAgICAgIC5kYXR1bShkKVxuICAgICAgICAuY2FsbChncmlkKVxuICAgICAgICAuc2VsZWN0QWxsKCcucm93JylcbiAgICAgICAgLm9uKHtcbiAgICAgICAgICBtb3VzZW92ZXIoZGQpIHtcbiAgICAgICAgICAgIGNoYXJ0LmhpZ2hsaWdodChbZGRdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1vdXNlb3V0OiBjaGFydC51bmhpZ2hsaWdodCxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuUGFyYWxsZWxDb29yZGluYXRlcy5kaXNwbGF5TmFtZSA9ICdQYXJhbGxlbENvb3JkaW5hdGVzJztcblBhcmFsbGVsQ29vcmRpbmF0ZXMucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuXG5leHBvcnQgZGVmYXVsdCBQYXJhbGxlbENvb3JkaW5hdGVzO1xuIiwiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHN0eWxlZCwgcmVhY3RpZnkgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL1BhcmFsbGVsQ29vcmRpbmF0ZXMnO1xuXG5jb25zdCBSZWFjdENvbXBvbmVudCA9IHJlYWN0aWZ5KENvbXBvbmVudCk7XG5cbmNvbnN0IFBhcmFsbGVsQ29vcmRpYW5lcyA9ICh7IGNsYXNzTmFtZSwgLi4ub3RoZXJQcm9wcyB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICA8UmVhY3RDb21wb25lbnQgey4uLm90aGVyUHJvcHN9IC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5QYXJhbGxlbENvb3JkaWFuZXMucHJvcFR5cGVzID0ge1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlZChQYXJhbGxlbENvb3JkaWFuZXMpYFxuICAuc3VwZXJzZXQtbGVnYWN5LWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzIHtcbiAgICBkaXYuZ3JpZCB7XG4gICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgIGRpdi5yb3cge1xuICAgICAgICAmOmhvdmVyIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5gO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFtQkE7QUFvQkE7QUFNQTtBQWdDQTtBQTBEQTtBQUlBO0FBTUE7QUFIQTtBQTBDQTtBQU9BO0FBWUE7QUFXQTtBQUNBO0FBR0E7QUF5QkE7QUFHQTtBQVFBO0FBcUJBO0FBRUE7QUFVQTtBQTZCQTtBQWFBO0FBUUE7QUFRQTtBQVNBO0FBMkVBO0FBTUE7QUFrQ0E7QUFBQTtBQU9BO0FBMERBO0FBa0JBO0FBdUJBO0FBd0JBO0FBQ0E7QUE2Q0E7QUFDQTtBQUNBO0FBNkNBO0FBTUE7QUFhQTtBQXVEQTtBQTJCQTtBQWdCQTtBQTZCQTtBQXNCQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQXFCQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQW1CQTtBQU9BO0FBWUE7QUFDQTtBQUdBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW9DQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBRUE7QUFjQTtBQVFBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBSUE7QUFVQTtBQTRDQTtBQU1BO0FBUUE7QUFHQTtBQUdBO0FBS0E7QUFzQ0E7QUE0QkE7QUFFQTtBQXFGQTtBQUtBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFzQkE7QUFXQTtBQWVBO0FBbUJBO0FBbURBO0FBQ0E7QUE4QkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBZ0JBO0FBU0E7QUFJQTtBQUNBO0FBU0E7QUFPQTtBQVFBO0FBQ0E7QUFDQTtBQThCQTtBQUVBO0FBV0E7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFJQTtBQVFBO0FBeURBO0FBQ0E7QUFDQTtBQUNBO0FBNkJBO0FBNEJBO0FBRUE7QUFzSEE7QUFLQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBeUJBO0FBWUE7QUFRQTs7Ozs7QUFxQ0E7QUFXQTtBQWNBO0FBZUE7QUF3Q0E7QUFDQTtBQXNDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQVNBO0FBbURBO0FBU0E7QUFJQTtBQUNBO0FBU0E7QUFPQTtBQVFBO0FBQ0E7QUFDQTtBQW1DQTtBQVNBO0FBQ0E7QUFFQTtBQUlBO0FBR0E7QUFHQTtBQVNBO0FBY0E7QUFRQTtBQUNBO0FBaUJBO0FBaUJBO0FBQ0E7QUFDQTtBQVNBO0FBWUE7QUFDQTtBQUVBO0FBMEJBOztBQzd5RUE7QUFHQTtBQU9BO0FBbUJBO0FBa0JBOzs7OztBQy9DQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFXQTtBQTZEQTtBQWVBOztBQ3pHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2497\n')}}]);